<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka.Streams</name>
    </assembly>
    <members>
        <member name="T:Akka.Streams.ActorMaterializer">
            <summary>
            A ActorMaterializer takes the list of transformations comprising a
            <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and materializes them in the form of
            <see cref="T:Reactive.Streams.IProcessor`2"/> instances. How transformation
            steps are split up into asynchronous regions is implementation
            dependent.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.DefaultConfig">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Create(Akka.Actor.IActorRefFactory,Akka.Streams.ActorMaterializerSettings,System.String)">
            <summary>
            <para>
            Creates a ActorMaterializer which will execute every step of a transformation
            pipeline within its own <see cref="T:Akka.Actor.ActorBase"/>. The required <see cref="T:Akka.Actor.IActorRefFactory"/>
            (which can be either an <see cref="T:Akka.Actor.ActorSystem"/> or an <see cref="T:Akka.Actor.IActorContext"/>)
            will be used to create one actor that in turn creates actors for the transformation steps.
            </para>
            <para>
            The materializer's <see cref="T:Akka.Streams.ActorMaterializerSettings"/> will be obtained from the
            configuration of the <paramref name="context"/>'s underlying <see cref="T:Akka.Actor.ActorSystem"/>.
            </para>
            <para>
            The <paramref name="namePrefix"/> is used as the first part of the names of the actors running
            the processing steps. The default <paramref name="namePrefix"/> is "flow". The actor names are built up of
            `namePrefix-flowNumber-flowStepNumber-stepName`.
            </para>
            </summary>
            <param name="context">TBD</param>
            <param name="settings">TBD</param>
            <param name="namePrefix">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="context"/> is not of type <see cref="T:Akka.Actor.ActorSystem"/> or <see cref="T:Akka.Actor.IActorContext"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="context"/> is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.IsShutdown">
            <summary>
            Indicates if the materializer has been shut down.
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.ExecutionContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.Logger">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.Supervisor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.WithNamePrefix(System.String)">
            <summary>
            TBD
            </summary>
            <param name="namePrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <inheritdoc />
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},Akka.Streams.Attributes)">
            <inheritdoc />
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.EffectiveSettings(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Shutdown">
            <summary>
            Shuts down this materializer and all the stages that have been materialized through this materializer. After
            having shut down, this materializer cannot be used again. Any attempt to materialize stages after having
            shut down will result in an <see cref="T:Akka.Pattern.IllegalStateException"/> being thrown at materialization time.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.ActorOf(Akka.Streams.MaterializationContext,Akka.Actor.Props)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="props">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.MakeLogger(System.Object)">
            <summary>
            Creates a new logging adapter.
            </summary>
            <param name="logSource">The source that produces the log events.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.ActorMaterializerHelper">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerHelper.Downcast(Akka.Streams.IMaterializer)">
            <summary>
            TBD
            </summary>
            <param name="materializer">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="materializer"/> is not of type <see cref="T:Akka.Streams.ActorMaterializer"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.AbruptTerminationException">
            <summary>
            This exception signals that an actor implementing a Reactive Streams Subscriber, Publisher or Processor
            has been terminated without being notified by an onError, onComplete or cancel signal. This usually happens
            when an ActorSystem is shut down while stream processing actors are still running.
            </summary>
        </member>
        <member name="F:Akka.Streams.AbruptTerminationException.Actor">
            <summary>
            The actor that was terminated without notification.
            </summary>
        </member>
        <member name="M:Akka.Streams.AbruptTerminationException.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.AbruptTerminationException" /> class.
            </summary>
            <param name="actor">The actor that was terminated.</param>
        </member>
        <member name="T:Akka.Streams.MaterializationException">
            <summary>
            This exception or subtypes thereof should be used to signal materialization failures.
            </summary>
        </member>
        <member name="M:Akka.Streams.MaterializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.MaterializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.AbruptStageTerminationException">
            <summary>
            Signal that the stage was abruptly terminated, usually seen as a call to <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/> without
            any of the handler callbacks seeing completion or failure from upstream or cancellation from downstream. This can happen when
            the actor running the graph is killed, which happens when the materializer or actor system is terminated.
            </summary>
        </member>
        <member name="T:Akka.Streams.ActorMaterializerSettings">
            <summary>
            This class describes the configurable properties of the <see cref="T:Akka.Streams.ActorMaterializer"/>. 
            Please refer to the withX methods for descriptions of the individual settings.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.Create(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.InitialInputBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.MaxInputBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.SupervisionDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.SubscriptionTimeoutSettings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.IsDebugLogging">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.OutputBurstLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.IsFuzzingMode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.IsAutoFusing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.MaxFixedBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.SyncProcessingLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorMaterializerSettings.StreamRefSettings">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.#ctor(System.Int32,System.Int32,System.String,Akka.Streams.Supervision.Decider,Akka.Streams.StreamSubscriptionTimeoutSettings,Akka.Streams.Dsl.StreamRefSettings,System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="initialInputBufferSize">TBD</param>
            <param name="maxInputBufferSize">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="supervisionDecider">TBD</param>
            <param name="subscriptionTimeoutSettings">TBD</param>
            <param name="streamRefSettings">TBD</param>
            <param name="isDebugLogging">TBD</param>
            <param name="outputBurstLimit">TBD</param>
            <param name="isFuzzingMode">TBD</param>
            <param name="isAutoFusing">TBD</param>
            <param name="maxFixedBufferSize">TBD</param>
            <param name="syncProcessingLimit">TBD</param>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithInputBuffer(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="initialSize">TBD</param>
            <param name="maxSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithDispatcher(System.String)">
            <summary>
            TBD
            </summary>
            <param name="dispatcher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithSupervisionStrategy(Akka.Streams.Supervision.Decider)">
            <summary>
            TBD
            </summary>
            <param name="decider">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithDebugLogging(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="isEnabled">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithFuzzingMode(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="isFuzzingMode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithAutoFusing(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="isAutoFusing">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithMaxFixedBufferSize(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maxFixedBufferSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithSyncProcessingLimit(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="limit">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerSettings.WithSubscriptionTimeoutSettings(Akka.Streams.StreamSubscriptionTimeoutSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.StreamSubscriptionTimeoutSettings">
            <summary>
            Leaked publishers and subscribers are cleaned up when they are not used within a given deadline, configured by <see cref="T:Akka.Streams.StreamSubscriptionTimeoutSettings"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.Create(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutSettings.Mode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutSettings.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.#ctor(Akka.Streams.StreamSubscriptionTimeoutTerminationMode,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="mode">TBD</param>
            <param name="timeout">TBD</param>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.Equals(Akka.Streams.StreamSubscriptionTimeoutSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.StreamSubscriptionTimeoutSettings.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.StreamSubscriptionTimeoutTerminationMode">
            <summary>
            This mode describes what shall happen when the subscription timeout expires 
            for substream Publishers created by operations like <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.PrefixAndTail``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.NoopTermination">
            <summary>
            Do not do anything when timeout expires.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.WarnTermination">
            <summary>
            Log a warning when the timeout expires.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.CancelTermination">
            <summary>
            When the timeout expires attach a Subscriber that will immediately cancel its subscription.
            </summary>
        </member>
        <member name="T:Akka.Streams.ActorMaterializerExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerExtensions.Materializer(Akka.Actor.IActorRefFactory,Akka.Streams.ActorMaterializerSettings,System.String)">
            <summary>
            <para>
            Creates a ActorMaterializer which will execute every step of a transformation
            pipeline within its own <see cref="T:Akka.Actor.ActorBase"/>. The required <see cref="T:Akka.Actor.IActorRefFactory"/>
            (which can be either an <see cref="T:Akka.Actor.ActorSystem"/> or an <see cref="T:Akka.Actor.IActorContext"/>)
            will be used to create one actor that in turn creates actors for the transformation steps.
            </para>
            <para>
            The materializer's <see cref="T:Akka.Streams.ActorMaterializerSettings"/> will be obtained from the
            configuration of the <paramref name="context"/>'s underlying <see cref="T:Akka.Actor.ActorSystem"/>.
            </para>
            <para>
            The <paramref name="namePrefix"/> is used as the first part of the names of the actors running
            the processing steps. The default <paramref name="namePrefix"/> is "flow". The actor names are built up of
            namePrefix-flowNumber-flowStepNumber-stepName.
            </para>
            </summary>
            <param name="context">TBD</param>
            <param name="settings">TBD</param>
            <param name="namePrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.Subscribe`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Actors.Subscribe`1.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.Subscribe`1.#ctor(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="T:Akka.Streams.Actors.LifecycleState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.PreSubscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.Active">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.Canceled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.Completed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.CompleteThenStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.LifecycleState.ErrorEmitted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.IActorPublisherMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.Request">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor when the stream
            subscriber requests more elements.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.Request.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.Request.#ctor(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.Request.MarkProcessed">
            <summary>
            INTERNAL API: needed for stash support
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.Request.IsProcessed">
            <summary>
            INTERNAL API: needed for stash support
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.Cancel">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor when the stream
            subscriber cancels the subscription.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.Cancel.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor in order to signal
            the exceeding of an subscription timeout. Once the actor receives this message, this
            publisher will already be in cancelled state, thus the actor should clean-up and stop itself.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.SubscriptionTimeoutExceeded.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisher`1">
            <summary>
            <para>
            Extend this actor to make it a stream publisher that keeps track of the subscription life cycle and
            requested elements.
            </para>
            <para>
            Create a <see cref="T:Reactive.Streams.IPublisher`1"/> backed by this actor with <see cref="M:Akka.Streams.Actors.ActorPublisher.Create``1(Akka.Actor.IActorRef)"/>.
            </para>
            <para>
            It can be attached to a <see cref="T:Reactive.Streams.ISubscriber`1"/> or be used as an input source for a
            <see cref="T:Akka.Streams.Dsl.IFlow`2"/>. You can only attach one subscriber to this publisher.
            </para>
            <para>
            The life cycle state of the subscription is tracked with the following boolean members:
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/>, <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsCompleted"/>, <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsErrorEmitted"/>,
            and <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsCanceled"/>.
            </para>
            <para>
            You send elements to the stream by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>. You are allowed to send as many
            elements as have been requested by the stream subscriber. This amount can be inquired with
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>. It is only allowed to use <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> when <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/>
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/> &gt; 0, otherwise <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will throw
            <see cref="T:Akka.Pattern.IllegalStateException"/>.
            </para>
            <para>
            When the stream subscriber requests more elements the <see cref="T:Akka.Streams.Actors.Request"/> message
            is delivered to this actor, and you can act on that event. The <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>
            is updated automatically.
            </para>
            <para>
            When the stream subscriber cancels the subscription the <see cref="T:Akka.Streams.Actors.Cancel"/> message
            is delivered to this actor. After that subsequent calls to <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will be ignored.
            </para>
            <para>
            You can complete the stream by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            You can terminate the stream with failure by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            If you suspect that this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> may never get subscribed to,
            you can override the <see cref="P:Akka.Streams.Actors.ActorPublisher`1.SubscriptionTimeout"/> method to provide a timeout after which
            this Publisher should be considered canceled. The actor will be notified when
            the timeout triggers via an <see cref="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded"/> message and MUST then
            perform cleanup and stop itself.
            </para>
            <para>
            If the actor is stopped the stream will be completed, unless it was not already terminated with
            failure, completed or canceled.
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.SubscriptionTimeout">
             <summary>
             Subscription timeout after which this actor will become Canceled and reject any incoming "late" subscriber.
            
             The actor will receive an <see cref="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded"/> message upon which it
             MUST react by performing all necessary cleanup and stopping itself.
            
             Use this feature in order to avoid leaking actors when you suspect that this Publisher may never get subscribed to by some Subscriber.
             </summary>
             <summary>
             <para>
             Subscription timeout after which this actor will become Canceled and reject any incoming "late" subscriber.
             </para>
             <para>
             The actor will receive an <see cref="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded"/> message upon which it
             MUST react by performing all necessary cleanup and stopping itself.
             </para>
             <para>
             Use this feature in order to avoid leaking actors when you suspect that this Publisher
             may never get subscribed to by some Subscriber.
             </para>
             </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsActive">
            <summary>
            The state when the publisher is active, i.e. before the subscriber is attached
            and when an subscriber is attached. It is allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> in this state. It is
            allowed to call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> in this state when <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>
            is greater than zero.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand">
            <summary>
            Total number of requested elements from the stream subscriber.
            This actor automatically keeps tracks of this amount based on
            incoming request messages and outgoing <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsCompleted">
            <summary>
            The terminal state after calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>. It is not allowed to
            <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in this state.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsErrorEmitted">
            <summary>
            The terminal state after calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>. It is not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in this state.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsCanceled">
            <summary>
            The state after the stream subscriber has canceled the subscription.
            It is allowed to call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in
            this state, but the calls will not perform anything.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)">
            <summary>
            Sends an element to the stream subscriber. You are allowed to send as many elements
            as have been requested by the stream subscriber. This amount can be inquired with
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>. It is only allowed to use <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> when
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/> and <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/> &gt; 0,
            otherwise <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will throw <see cref="T:Akka.Pattern.IllegalStateException"/>.
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown for a number of reasons. These include:
            <dl>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.Active"/> or <see cref="F:Akka.Streams.Actors.LifecycleState.PreSubscriber"/> state</dt>
              <dd>This exception is thrown when the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has zero <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>.</dd>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.ErrorEmitted"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already terminated due to an error.</dd>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.Completed"/> or <see cref="F:Akka.Streams.Actors.LifecycleState.CompleteThenStop"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already completed.</dd>
            </dl>
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete">
            <summary>
            Complete the stream. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown for a number of reasons. These include:
            <dl>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.ErrorEmitted"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already terminated due to an error.</dd>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.Completed"/> or <see cref="F:Akka.Streams.Actors.LifecycleState.CompleteThenStop"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already completed.</dd>
            </dl>
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnCompleteThenStop">
            <summary>
            <para>
            Complete the stream. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            After signalling completion the Actor will then stop itself as it has completed the protocol.
            When <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> is called before any <see cref="T:Reactive.Streams.ISubscriber`1"/> has had the chance to subscribe
            to this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> the completion signal (and therefore stopping of the Actor as well)
            will be delayed until such <see cref="T:Reactive.Streams.ISubscriber`1"/> arrives.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)">
            <summary>
            Terminate the stream with failure. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </summary>
            <param name="cause">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown for a number of reasons. These include:
            <dl>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.ErrorEmitted"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already terminated due to an error.</dd>
              <dt>when in the <see cref="F:Akka.Streams.Actors.LifecycleState.Completed"/> or <see cref="F:Akka.Streams.Actors.LifecycleState.CompleteThenStop"/> state</dt>
              <dd>This exception is thrown when this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> has already completed.</dd>
            </dl>
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnErrorThenStop(System.Exception)">
            <summary>
            <para>
            Terminate the stream with failure. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            After signalling the Error the Actor will then stop itself as it has completed the protocol.
            When <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> is called before any <see cref="T:Reactive.Streams.ISubscriber`1"/> has had the chance to subscribe
            to this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> the error signal (and therefore stopping of the Actor as well)
            will be delayed until such <see cref="T:Reactive.Streams.ISubscriber`1"/> arrives.
            </para>
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.AroundReceive(Akka.Actor.Receive,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.AroundPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.AroundPreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.AroundPostRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.AroundPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher.Create``1(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="ref">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisherImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherImpl`1.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="ref"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherImpl`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="subscriber"/> is undefined.
            </exception>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisherSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherSubscription.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="ref"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherSubscription.Request(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherSubscription.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.OnErrorBlock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnErrorBlock.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnErrorBlock.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.OnErrorBlock.#ctor(System.Exception,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="stop">TBD</param>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisherState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisherState.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorPublisherState.State.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorPublisherState.State.Demand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorPublisherState.State.LifecycleState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherState.State.#ctor(Akka.Streams.IUntypedSubscriber,System.Int64,Akka.Streams.Actors.LifecycleState)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="demand">TBD</param>
            <param name="lifecycleState">TBD</param>
        </member>
        <member name="F:Akka.Streams.Actors.ActorPublisherState.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherState.Get(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherState.Set(Akka.Actor.IActorRef,Akka.Streams.Actors.ActorPublisherState.State)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <param name="s">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherState.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisherState.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.OnSubscribe">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnSubscribe.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.OnSubscribe.#ctor(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="T:Akka.Streams.Actors.IActorSubscriberMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.OnNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnNext.Element">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.OnNext.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Actors.OnError">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnError.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.OnError.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Streams.Actors.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OnComplete.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorSubscriber">
            <summary>
            <para>
            Extend this actor to make it a
            stream subscriber with full control of stream back pressure. It will receive
            <see cref="T:Akka.Streams.Actors.OnNext"/>, <see cref="T:Akka.Streams.Actors.OnComplete"/> and <see cref="T:Akka.Streams.Actors.OnError"/>
            messages from the stream. It can also receive other, non-stream messages, in
            the same way as any actor.
            </para>
            <para>
            Attach the actor as a <see cref="T:Reactive.Streams.ISubscriber`1"/> to the stream with
            <see cref="M:Akka.Streams.Actors.ActorSubscriber.Create``1(Akka.Actor.IActorRef)"/>
            </para>
            <para>
            Subclass must define the <see cref="P:Akka.Streams.Actors.ActorSubscriber.RequestStrategy"/> to control stream back pressure.
            After each incoming message the <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> will automatically invoke
            the <see cref="M:Akka.Streams.Actors.IRequestStrategy.RequestDemand(System.Int32)"/> and propagate the returned demand to the stream.
            The provided <see cref="T:Akka.Streams.Actors.WatermarkRequestStrategy"/> is a good strategy if the actor
            performs work itself.
            The provided <see cref="T:Akka.Streams.Actors.MaxInFlightRequestStrategy"/> is useful if messages are
            queued internally or delegated to other actors.
            You can also implement a custom <see cref="T:Akka.Streams.Actors.IRequestStrategy"/> or call <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/> manually
            together with <see cref="T:Akka.Streams.Actors.ZeroRequestStrategy"/> or some other strategy. In that case
            you must also call <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/> when the actor is started or when it is ready, otherwise
            it will not receive any elements.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorSubscriber.RequestStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorSubscriber.IsCanceled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorSubscriber.RemainingRequested">
            <summary>
            The number of stream elements that have already been requested from upstream
            but not yet received.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.AroundReceive(Akka.Actor.Receive,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.AroundPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.AroundPostRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.AroundPreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.AroundPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)">
            <summary>
            Request a number of elements from upstream.
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Cancel">
            <summary>
            <para>
            Cancel upstream subscription.
            No more elements will be delivered after cancel.
            </para>
            <para>
            The <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> will be stopped immediately after signaling cancellation.
            In case the upstream subscription has not yet arrived the Actor will stay alive
            until a subscription arrives, cancel it and then stop itself.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Create``1(Akka.Actor.IActorRef)">
            <summary>
            Attach a <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> actor as a <see cref="T:Reactive.Streams.ISubscriber`1"/>
            to a <see cref="T:Reactive.Streams.IPublisher`1"/> or <see cref="T:Akka.Streams.Dsl.IFlow`2"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="ref">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.ActorSubscriberImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="impl">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="impl"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="subscription"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="element"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="cause"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberImpl`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorSubscriberState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorSubscriberState.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorSubscriberState.State.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorSubscriberState.State.Requested">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ActorSubscriberState.State.IsCanceled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberState.State.#ctor(Reactive.Streams.ISubscription,System.Int64,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <param name="requested">TBD</param>
            <param name="isCanceled">TBD</param>
        </member>
        <member name="F:Akka.Streams.Actors.ActorSubscriberState.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberState.Get(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberState.Set(Akka.Actor.IActorRef,Akka.Streams.Actors.ActorSubscriberState.State)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <param name="s">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberState.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriberState.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.IRequestStrategy">
            <summary>
             An <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> defines a <see cref="T:Akka.Streams.Actors.IRequestStrategy"/>
             to control the stream back pressure.
             </summary>
        </member>
        <member name="M:Akka.Streams.Actors.IRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            Invoked by the <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> after each incoming message to
            determine how many more elements to request from the stream.
            </summary>
            <param name="remainingRequested">current remaining number of elements
            that have been requested from upstream but not received yet</param>
            <returns>demand of more elements from the stream, returning 0 means that no
            more elements will be requested for now</returns>
        </member>
        <member name="T:Akka.Streams.Actors.OneByOneRequestStrategy">
            <summary>
            Requests one more element when remainingRequested is 0, i.e.
            * max one element in flight.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.OneByOneRequestStrategy.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.OneByOneRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="remainingRequested">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.ZeroRequestStrategy">
            <summary>
            When request is only controlled with manual calls to <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.ZeroRequestStrategy.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ZeroRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="remainingRequested">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.WatermarkRequestStrategy">
            <summary>
            Requests up to the highWatermark when the remainingRequested is
            below the lowWatermark. This a good strategy when the actor performs work itself.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.WatermarkRequestStrategy.HighWatermark">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.WatermarkRequestStrategy.LowWatermark">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.WatermarkRequestStrategy.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="highWatermark">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.WatermarkRequestStrategy.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="highWatermark">TBD</param>
            <param name="lowWatermark">TBD</param>
        </member>
        <member name="M:Akka.Streams.Actors.WatermarkRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="remainingRequested">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Actors.MaxInFlightRequestStrategy">
            <summary>
            Requests up to the max and also takes the number of messages
            that have been queued internally or delegated to other actors into account.
            Concrete subclass must implement <see cref="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.InFlight"/>.
            It will request elements in minimum batches of the defined <see cref="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.BatchSize"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.Actors.MaxInFlightRequestStrategy.Max">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.MaxInFlightRequestStrategy.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="max">TBD</param>
        </member>
        <member name="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.InFlight">
            <summary>
            Concrete subclass must implement this method to define how many
            messages that are currently in progress or queued.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.BatchSize">
            <summary>
            Elements will be requested in minimum batches of this size.
            Default is 5. Subclass may override to define the batch size.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.MaxInFlightRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="remainingRequested">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Attributes">
            <summary>
            Holds attributes which can be used to alter <see cref="T:Akka.Streams.Dsl.Flow`3"/>
            or <see cref="T:Akka.Streams.Dsl.GraphDsl"/> materialization.
            
            Note that more attributes for the <see cref="T:Akka.Streams.ActorMaterializer"/> are defined in <see cref="T:Akka.Streams.ActorAttributes"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Attributes.IAttribute">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Attributes.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.Name.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.Name.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="value"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Attributes.Name.Equals(Akka.Streams.Attributes.Name)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.Name.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.Name.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.Name.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Attributes.InputBuffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.InputBuffer.Initial">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.InputBuffer.Max">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.InputBuffer.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="initial">TBD</param>
            <param name="max">TBD</param>
        </member>
        <member name="M:Akka.Streams.Attributes.InputBuffer.Equals(Akka.Streams.Attributes.InputBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.InputBuffer.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.InputBuffer.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.InputBuffer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Attributes.LogLevels">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.LogLevels.Off">
            <summary>
            Use to disable logging on certain operations when configuring <see cref="T:Akka.Streams.Attributes.LogLevels"/>
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.LogLevels.OnElement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.LogLevels.OnFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.LogLevels.OnFailure">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.LogLevels.#ctor(Akka.Event.LogLevel,Akka.Event.LogLevel,Akka.Event.LogLevel)">
            <summary>
            TBD
            </summary>
            <param name="onElement">TBD</param>
            <param name="onFinish">TBD</param>
            <param name="onFailure">TBD</param>
        </member>
        <member name="M:Akka.Streams.Attributes.LogLevels.Equals(Akka.Streams.Attributes.LogLevels)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.LogLevels.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.LogLevels.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.LogLevels.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Attributes.AsyncBoundary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.AsyncBoundary.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.AsyncBoundary.Equals(Akka.Streams.Attributes.AsyncBoundary)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.AsyncBoundary.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Attributes.AsyncBoundary.ToString">
            <inheritdoc/>
        </member>
        <member name="F:Akka.Streams.Attributes.None">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.#ctor(Akka.Streams.Attributes.IAttribute[])">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Attributes.AttributeList">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttributeList``1">
            <summary>
            Get all attributes of a given type or subtype thereof
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttribute``1(``0)">
            <summary>
            Get the last (most specific) attribute of a given type or subtype thereof.
            If no such attribute exists the default value is returned.
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <param name="defaultIfNotFound">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetFirstAttribute``1(``0)">
            <summary>
            Get the first (least specific) attribute of a given type or subtype thereof.
            If no such attribute exists the default value is returned.
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <param name="defaultIfNotFound">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttribute``1">
            <summary>
            Get the last (most specific) attribute of a given type or subtype thereof.
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetFirstAttribute``1">
            <summary>
            Get the first (least specific) attribute of a given type or subtype thereof.
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.And(Akka.Streams.Attributes)">
            <summary>
            Adds given attributes to the end of these attributes.
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.And(Akka.Streams.Attributes.IAttribute)">
            <summary>
            Adds given attribute to the end of these attributes.
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetNameLifted">
            <summary>
            Extracts Name attributes and concatenates them.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.GetNameOrDefault(System.String)">
            <summary>
            TBD
            </summary>
            <param name="defaultIfNotFound">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.Contains``1(``0)">
            <summary>
            Test whether the given attribute is contained within this attributes list.
            </summary>
            <typeparam name="TAttr">TBD</typeparam>
            <param name="attribute">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateName(System.String)">
            <summary>
            Specifies the name of the operation.
            If the name is null or empty the name is ignored, i.e. <see cref="F:Akka.Streams.Attributes.None"/> is returned.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)">
            <summary>
            Specifies the initial and maximum size of the input buffer.
            </summary>
            <param name="initial">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateAsyncBoundary">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateLogLevels(Akka.Event.LogLevel,Akka.Event.LogLevel,Akka.Event.LogLevel)">
            <summary>
             Configures <see cref="M:Akka.Streams.Dsl.FlowOperations.Log``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.String,System.Func{``1,System.Object},Akka.Event.ILoggingAdapter)"/> stage log-levels to be used when logging.
             Logging a certain operation can be completely disabled by using <see cref="F:Akka.Streams.Attributes.LogLevels.Off"/>
            
             Passing in null as any of the arguments sets the level to its default value, which is:
             <see cref="F:Akka.Event.LogLevel.DebugLevel"/> for <paramref name="onElement"/> and <paramref name="onFinish"/>, and <see cref="F:Akka.Event.LogLevel.ErrorLevel"/> for <paramref name="onError"/>.
            </summary>
             <param name="onElement">TBD</param>
             <param name="onFinish">TBD</param>
             <param name="onError">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.ExtractName(Akka.Streams.Implementation.IModule,System.String)">
            <summary>
            Compute a name by concatenating all Name attributes that the given module
            has, returning the given default value if none are found.
            </summary>
            <param name="module">TBD</param>
            <param name="defaultIfNotFound">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Attributes.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.ActorAttributes">
            <summary>
            Attributes for the <see cref="T:Akka.Streams.ActorMaterializer"/>. Note that more attributes defined in <see cref="T:Akka.Streams.ActorAttributes"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.ActorAttributes.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorAttributes.Dispatcher.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.Dispatcher.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.Dispatcher.Equals(Akka.Streams.ActorAttributes.Dispatcher)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.Dispatcher.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.Dispatcher.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.Dispatcher.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.ActorAttributes.SupervisionStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.ActorAttributes.SupervisionStrategy.Decider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.SupervisionStrategy.#ctor(Akka.Streams.Supervision.Decider)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> class.
            </summary>
            <param name="decider">TBD</param>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.SupervisionStrategy.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)">
            <summary>
            Specifies the name of the dispatcher.
            </summary>
            <param name="dispatcherName">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.CreateSupervisionStrategy(Akka.Streams.Supervision.Decider)">
            <summary>
            Decides how exceptions from user are to be handled
            <para>
            Stages supporting supervision strategies explicitly document that they do so. If a stage does not document
            support for these, it should be assumed it does not support supervision.
            </para>
            </summary>
            <param name="strategy">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.StreamRefAttributes">
            <summary>
            Attributes for stream refs (<see cref="T:Akka.Streams.ISourceRef`1"/> and <see cref="T:Akka.Streams.ISinkRef`1"/>).
            Note that more attributes defined in <see cref="T:Akka.Streams.Attributes"/> and <see cref="T:Akka.Streams.ActorAttributes"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.StreamRefAttributes.IStreamRefAttribute">
            <summary>
            Attributes specific to stream refs.
            </summary>
        </member>
        <member name="M:Akka.Streams.StreamRefAttributes.CreateSubscriptionTimeout(System.TimeSpan)">
            <summary>
            Specifies the subscription timeout within which the remote side MUST subscribe to the handed out stream reference.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.GraphDsl">
            <summary>
            A graph DSL, which defines an API for building complex graphs. Graph definitions 
            are enclosed within a scope of functions defined by user, using a dedicated
            <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> helper to connect specific graph stages with each other.
            </summary>
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``1(System.Func{Akka.Streams.Dsl.GraphDsl.Builder{Akka.NotUsed},``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by passing a <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShape">Type describing shape of the returned graph.</typeparam>
            <param name="buildBlock">A builder function used to construct the graph.</param>
            <returns>A graph with no materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.CreateMaterialized``2(System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by passing a <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShape">Shape of the produced graph.</typeparam>
            <typeparam name="TMat">A type of value, that graph will materialize to after completion.</typeparam>
            <param name="buildBlock">Graph construction function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``3(Akka.Streams.IGraph{``2,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``2,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graph <paramref name="g1"/> 
            and passing its <see cref="T:Akka.Streams.Shape"/> along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShapeOut">A type describing shape of the returned graph.</typeparam>
            <typeparam name="TMat">A type of value, that graph will materialize to after completion.</typeparam>
            <typeparam name="TShape1">A type of shape of the input graph.</typeparam>
            <param name="g1">Graph used as input parameter.</param>
            <param name="buildBlock">Graph construction function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``6(Akka.Streams.IGraph{``4,``2},Akka.Streams.IGraph{``5,``3},System.Func{``2,``3,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``4,``5,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShapeOut">A type describing shape of the returned graph.</typeparam>
            <typeparam name="TMatOut">A type of value, that graph will materialize to after completion.</typeparam>
            <typeparam name="TMat0">A type of materialized value of the first input graph parameter.</typeparam>
            <typeparam name="TMat1">A type of materialized value of the second input graph parameter.</typeparam>
            <typeparam name="TShape0">A type describing the shape of a first input graph parameter.</typeparam>
            <typeparam name="TShape1">A type describing the shape of a second input graph parameter.</typeparam>
            <param name="g0">A first input graph.</param>
            <param name="g1">A second input graph.</param>
            <param name="combineMaterializers">Function used to determine output materialized value based on the materialized values of the passed graphs.</param>
            <param name="buildBlock">A graph constructor function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``8(Akka.Streams.IGraph{``5,``2},Akka.Streams.IGraph{``6,``3},Akka.Streams.IGraph{``7,``4},System.Func{``2,``3,``4,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``5,``6,``7,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShapeOut">A type describing shape of the returned graph.</typeparam>
            <typeparam name="TMatOut">A type of value, that graph will materialize to after completion.</typeparam>
            <typeparam name="TMat0">A type of materialized value of the first input graph parameter.</typeparam>
            <typeparam name="TMat1">A type of materialized value of the second input graph parameter.</typeparam>
            <typeparam name="TMat2">A type of materialized value of the third input graph parameter.</typeparam>
            <typeparam name="TShape0">A type describing the shape of a first input graph parameter.</typeparam>
            <typeparam name="TShape1">A type describing the shape of a second input graph parameter.</typeparam>
            <typeparam name="TShape2">A type describing the shape of a third input graph parameter.</typeparam>
            <param name="g0">A first input graph.</param>
            <param name="g1">A second input graph.</param>
            <param name="g2">A third input graph.</param>
            <param name="combineMaterializers">Function used to determine output materialized value based on the materialized values of the passed graphs.</param>
            <param name="buildBlock">A graph constructor function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``10(Akka.Streams.IGraph{``6,``2},Akka.Streams.IGraph{``7,``3},Akka.Streams.IGraph{``8,``4},Akka.Streams.IGraph{``9,``5},System.Func{``2,``3,``4,``5,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``6,``7,``8,``9,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShapeOut">A type describing shape of the returned graph.</typeparam>
            <typeparam name="TMatOut">A type of value, that graph will materialize to after completion.</typeparam>
            <typeparam name="TMat0">A type of materialized value of the first input graph parameter.</typeparam>
            <typeparam name="TMat1">A type of materialized value of the second input graph parameter.</typeparam>
            <typeparam name="TMat2">A type of materialized value of the third input graph parameter.</typeparam>
            <typeparam name="TMat3">A type of materialized value of the fourth input graph parameter.</typeparam>
            <typeparam name="TShape0">A type describing the shape of a first input graph parameter.</typeparam>
            <typeparam name="TShape1">A type describing the shape of a second input graph parameter.</typeparam>
            <typeparam name="TShape2">A type describing the shape of a third input graph parameter.</typeparam>
            <typeparam name="TShape3">A type describing the shape of a fourth input graph parameter.</typeparam>
            <param name="g0">A first input graph.</param>
            <param name="g1">A second input graph.</param>
            <param name="g2">A third input graph.</param>
            <param name="g3">A fourth input graph.</param>
            <param name="combineMaterializers">Function used to determine output materialized value based on the materialized values of the passed graphs.</param>
            <param name="buildBlock">A graph constructor function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``12(Akka.Streams.IGraph{``7,``2},Akka.Streams.IGraph{``8,``3},Akka.Streams.IGraph{``9,``4},Akka.Streams.IGraph{``10,``5},Akka.Streams.IGraph{``11,``6},System.Func{``2,``3,``4,``5,``6,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``7,``8,``9,``10,``11,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
            <typeparam name="TShapeOut">A type describing shape of the returned graph.</typeparam>
            <typeparam name="TMatOut">A type of value, that graph will materialize to after completion.</typeparam>
            <typeparam name="TMat0">A type of materialized value of the first input graph parameter.</typeparam>
            <typeparam name="TMat1">A type of materialized value of the second input graph parameter.</typeparam>
            <typeparam name="TMat2">A type of materialized value of the third input graph parameter.</typeparam>
            <typeparam name="TMat3">A type of materialized value of the fourth input graph parameter.</typeparam>
            <typeparam name="TMat4">A type of materialized value of the fifth input graph parameter.</typeparam>
            <typeparam name="TShape0">A type describing the shape of a first input graph parameter.</typeparam>
            <typeparam name="TShape1">A type describing the shape of a second input graph parameter.</typeparam>
            <typeparam name="TShape2">A type describing the shape of a third input graph parameter.</typeparam>
            <typeparam name="TShape3">A type describing the shape of a fourth input graph parameter.</typeparam>
            <typeparam name="TShape4">A type describing the shape of a fifth input graph parameter.</typeparam>
            <param name="g0">A first input graph.</param>
            <param name="g1">A second input graph.</param>
            <param name="g2">A third input graph.</param>
            <param name="g3">A fourth input graph.</param>
            <param name="g4">A fifth input graph.</param>
            <param name="combineMaterializers">Function used to determine output materialized value based on the materialized values of the passed graphs.</param>
            <param name="buildBlock">A graph constructor function.</param>
            <returns>A graph with materialized value.</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.GraphDsl.Builder`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.AddEdge``2(Akka.Streams.Outlet{``0},Akka.Streams.Inlet{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``3(Akka.Streams.IGraph{``0,``1},System.Func{``1,``2})">
            <summary>
            INTERNAL API. 
            This is only used by the materialization-importing apply methods of Source,
            Flow, Sink and Graph.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="graph">TBD</param>
            <param name="transform">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``4(Akka.Streams.IGraph{``0},System.Func{``1,``2,``3})">
            <summary>
            INTERNAL API. 
            This is only used by the materialization-importing apply methods of Source,
            Flow, Sink and Graph.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="graph">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Import a graph into this module, performing a deep copy, discarding its
            materialized value and returning the copied Ports that are now to be connected.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.GraphDsl.Builder`1.MaterializedValue">
            <summary>
            Returns an <see cref="T:Akka.Streams.Outlet`1"/> that gives access to the materialized value of this graph. Once the graph is materialized
            this outlet will emit exactly one element which is the materialized value. It is possible to expose this
            outlet as an externally accessible outlet of a <see cref="T:Akka.Streams.Dsl.Source`2"/>, <see cref="T:Akka.Streams.Dsl.Sink`2"/>, 
            <see cref="T:Akka.Streams.Dsl.Flow`3"/> or <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/>.
            
            It is possible to call this method multiple times to get multiple <see cref="T:Akka.Streams.Outlet`1"/> instances if necessary. All of
            the outlets will emit the materialized value.
            
            Be careful to not to feed the result of this outlet to a stage that produces the materialized value itself (for
            example to a <see cref="M:Akka.Streams.Dsl.Sink.Aggregate``2(``1,System.Func{``1,``0,``1})"/> that contributes to the materialized value) since that might lead to an unresolvable
            dependency cycle.
            </summary> 
        </member>
        <member name="P:Akka.Streams.Dsl.GraphDsl.Builder`1.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``1(Akka.Streams.Outlet{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``1(Akka.Streams.SourceShape{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``1(Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},`0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``2(Akka.Streams.FlowShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},`0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``2(Akka.Streams.UniformFanInShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="fanIn">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.From``2(Akka.Streams.UniformFanOutShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="fanOut">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``1(Akka.Streams.Inlet{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``1(Akka.Streams.SinkShape{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``2(Akka.Streams.FlowShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``2(Akka.Streams.UniformFanOutShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="fanOut">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.To``2(Akka.Streams.UniformFanInShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="fanOut">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.GraphDsl.ForwardOps`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Dsl.GraphDsl.ForwardOps`2.Builder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.ForwardOps`2.#ctor(Akka.Streams.Dsl.GraphDsl.Builder{`1},Akka.Streams.Outlet{`0})">
            <summary>
            TBD
            </summary>
            <param name="builder">TBD</param>
            <param name="outlet">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.GraphDsl.ForwardOps`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.GraphDsl.ReverseOps`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Dsl.GraphDsl.ReverseOps`2.Builder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.ReverseOps`2.#ctor(Akka.Streams.Dsl.GraphDsl.Builder{`1},Akka.Streams.Inlet{`0})">
            <summary>
            TBD
            </summary>
            <param name="builder">TBD</param>
            <param name="inlet">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.GraphDsl.ReverseOps`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.FindOut``3(Akka.Streams.Dsl.GraphDsl.Builder{``2},Akka.Streams.UniformFanOutShape{``0,``1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="T">TBD</typeparam>
            <param name="builder">TBD</param>
            <param name="junction">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.FindIn``3(Akka.Streams.Dsl.GraphDsl.Builder{``2},Akka.Streams.UniformFanInShape{``0,``1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="T">TBD</typeparam>
            <param name="builder">TBD</param>
            <param name="junction">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.IUnzipWithCreator`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.IUnzipWithCreator`3.Create(System.Func{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`3.Create(System.Func{`0,System.ValueTuple{`1,`2}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`4">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`4.Create(System.Func{`0,System.ValueTuple{`1,`2,`3}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`5.Create(System.Func{`0,System.ValueTuple{`1,`2,`3,`4}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`6">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`6.Create(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`7">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
            <typeparam name="TOut5">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`7.Create(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5,`6}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWithCreator`8">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
            <typeparam name="TOut5">TBD</typeparam>
            <typeparam name="TOut6">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWithCreator`8.Create(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5,`6,`7}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith">
            <summary>
            TBD
            </summary>
            <summary>
            Transforms each element of input stream into multiple streams using a splitter function.
            <para>
            Emits when all of the outputs stops backpressuring and there is an input element available
            </para>
            Backpressures when any of the outputs backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when any downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``3(System.Func{``0,System.ValueTuple{``1,``2}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``4(System.Func{``0,System.ValueTuple{``1,``2,``3}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2,``3})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``5(System.Func{``0,System.ValueTuple{``1,``2,``3,``4}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2,``3,``4})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``6(System.Func{``0,System.ValueTuple{``1,``2,``3,``4,``5}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2,``3,``4,``5})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``7(System.Func{``0,System.ValueTuple{``1,``2,``3,``4,``5,``6}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
            <typeparam name="TOut5">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith.Apply``8(System.Func{``0,System.ValueTuple{``1,``2,``3,``4,``5,``6,``7}},Akka.Streams.Dsl.UnzipWithCreator{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut0">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut3">TBD</typeparam>
            <typeparam name="TOut4">TBD</typeparam>
            <typeparam name="TOut5">TBD</typeparam>
            <typeparam name="TOut6">TBD</typeparam>
            <param name="unzipper">TBD</param>
            <param name="creator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Dsl.UnzipWith.Instance">
            <summary>
            The singleton instance of <see cref="T:Akka.Streams.Dsl.UnzipWith"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`3.#ctor(System.Func{`0,System.ValueTuple{`1,`2}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`3.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`3.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`3.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`3.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`3.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`4">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`4.#ctor(System.Func{`0,System.ValueTuple{`1,`2,`3}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`4.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`4.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`5.#ctor(System.Func{`0,System.ValueTuple{`1,`2,`3,`4}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`5.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`5.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`6">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`6.#ctor(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`6.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`6.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`7">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`7.#ctor(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5,`6}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`7.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`7.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith`8">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`8.#ctor(System.Func{`0,System.ValueTuple{`1,`2,`3,`4,`5,`6,`7}})">
            <summary>
            TBD
            </summary>
            <param name="unzipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Out6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.UnzipWith`8.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnzipWith`8.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith">
            <summary>
            TBD
            </summary>
            <summary>
            Combine the elements of multiple streams into a stream of combined elements using a combiner function.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``3(System.Func{``0,``1,``2})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`3"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`4"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`5"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`6"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`7"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`8"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`9"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TIn7">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`10"/> specialized for 1 inputs.
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TIn7">TBD</typeparam>
            <typeparam name="TIn8">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">zipping-function from the input values to the output value</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Dsl.ZipWith.Instance">
            <summary>
            The singleton instance of <see cref="T:Akka.Streams.Dsl.ZipWith"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`3.#ctor(System.Func{`0,`1,`2})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`3.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`3.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`4">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`4.#ctor(System.Func{`0,`1,`2,`3})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`4.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`4.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`5.#ctor(System.Func{`0,`1,`2,`3,`4})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`5.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`5.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`6">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`6.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`6.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`7">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`7.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`7.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`7.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`8">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`8.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`8.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`8.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`9">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TIn7">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`9.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.In7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`9.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`9.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith`10">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn0">TBD</typeparam>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TIn3">TBD</typeparam>
            <typeparam name="TIn4">TBD</typeparam>
            <typeparam name="TIn5">TBD</typeparam>
            <typeparam name="TIn6">TBD</typeparam>
            <typeparam name="TIn7">TBD</typeparam>
            <typeparam name="TIn8">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`10.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})">
            <summary>
            TBD
            </summary>
            <param name="zipper">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.In8">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWith`10.Zipper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith`10.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.AccumulateWhileUnchanged`2">
            <summary>
            Accumulates elements of type <typeparamref name="TElement"/> while extracted property of type <typeparamref name="TProperty"/> remains unchanged,
            emits an accumulated sequence when the property changes
            </summary>
            <typeparam name="TElement">type of accumulated elements</typeparam>
            <typeparam name="TProperty">type of the observed property</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.AccumulateWhileUnchanged`2.#ctor(System.Func{`0,`1})">
            <param name="propertyExtractor">a function to extract the observed element property</param>
        </member>
        <member name="T:Akka.Streams.Dsl.BidiFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromGraph``5(Akka.Streams.IGraph{Akka.Streams.BidiShape{``0,``1,``2,``3},``4})">
            <summary>
            A graph with the shape of a flow logically is a flow, this method makes
            it so also in type.
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromFlowsMat``7(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``4},Akka.Streams.IGraph{Akka.Streams.FlowShape{``2,``3},``5},System.Func{``4,``5,``6})">
            <summary>
            Wraps two Flows to create a <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/>. The materialized value of the resulting BidiFlow is determined
            by the combiner function passed in the second argument list.
            <![CDATA[ 
            {{{
                +----------------------------+
                | Resulting BidiFlow         |
                |                            |
                |  +----------------------+  |
            I1 ~~> |        Flow1         | ~~> O1
                |  +----------------------+  |
                |                            |
                |  +----------------------+  |
            O2 \<~~ |        Flow2         | <~~ I2
                |  +----------------------+  |
                +----------------------------+
            }}}
            ]]>
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow1">TBD</param>
            <param name="flow2">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromFlows``6(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``4},Akka.Streams.IGraph{Akka.Streams.FlowShape{``2,``3},``5})">
            <summary>
            Wraps two Flows to create a <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/>. The materialized value of the resulting BidiFlow is NotUsed.
            <![CDATA[ 
            {{{
                +----------------------------+
                | Resulting BidiFlow         |
                |                            |
                |  +----------------------+  |
            I1 ~~> |        Flow1         | ~~> O1
                |  +----------------------+  |
                |                            |
                |  +----------------------+  |
            O2 <~~ |        Flow2         | <~~ I2
                |  +----------------------+  |
                +----------------------------+
            }}}
            ]]>
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow1">TBD</param>
            <param name="flow2">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromFunction``4(System.Func{``0,``1},System.Func{``2,``3})">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/> where the top and bottom flows are just one simple mapping
            stage each, expressed by the two functions.
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="outbound">TBD</param>
            <param name="inbound">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.BidirectionalIdleTimeout``2(System.TimeSpan)">
             <summary>
             If the time between two processed elements ///in any direction/// exceed the provided timeout, the stream is failed
             with a <see cref="T:System.TimeoutException"/>.
            
             There is a difference between this stage and having two idleTimeout Flows assembled into a BidiStage.
             If the timeout is configured to be 1 seconds, then this stage will not fail even though there are elements flowing
             every second in one direction, but no elements are flowing in the other direction. I.e. this stage considers
             the ///joint/// frequencies of the elements in both directions.
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <param name="timeout">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.BidiFlow`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.BidiFlow`5.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.BidiFlow`5.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Named(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Async">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Reversed">
            <summary>
            Turn this BidiFlow around by 180 degrees, logically flipping it upside down in a protocol stack.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Atop``3(Akka.Streams.Dsl.BidiFlow{`1,``0,``1,`2,``2})">
            <summary>
            Add the given BidiFlow as the next step in a bidirectional transformation
            pipeline. By convention protocol stacks are growing to the left: the right most is the bottom
            layer, the closest to the metal.
            <![CDATA[ 
            {{{
                +----------------------------+
                | Resulting BidiFlow         |
                |                            |
                |  +------+        +------+  |
            I1 ~~> |      |  ~O1~> |      | ~~> OO1
                |  | this |        | bidi |  |
            O2 <~~ |      | <~I2~  |      | <~~ II2
                |  +------+        +------+  |
                +----------------------------+
            }}}
            ]]>
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/> will be the materialized
            value of the current flow (ignoring the other BidiFlow’s value), use
            <see cref="M:Akka.Streams.Dsl.BidiFlow`5.AtopMat``4(Akka.Streams.Dsl.BidiFlow{`1,``0,``1,`2,``2},System.Func{`4,``2,``3})"/> if a different strategy is needed.
            </summary>
            <typeparam name="TOut12">TBD</typeparam>
            <typeparam name="TIn21">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="bidi">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.AtopMat``4(Akka.Streams.Dsl.BidiFlow{`1,``0,``1,`2,``2},System.Func{`4,``2,``3})">
            <summary>
            Add the given BidiFlow as the next step in a bidirectional transformation
            pipeline. By convention protocol stacks are growing to the left: the right most is the bottom
            layer, the closest to the metal.
             <![CDATA[ 
            {{{
                +----------------------------+
                | Resulting BidiFlow         |
                |                            |
                |  +------+        +------+  |
            I1 ~~> |      |  ~O1~> |      | ~~> OO1
                |  | this |        | bidi |  |
            O2 <~~ |      | <~I2~  |      | <~~ II2
                |  +------+        +------+  |
                +----------------------------+
            }}}
             ]]>
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting BidiFlow.
            </summary>
            <typeparam name="TOut12">TBD</typeparam>
            <typeparam name="TIn21">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="bidi">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Join``1(Akka.Streams.Dsl.Flow{`1,`2,``0})">
            <summary>
            Add the given Flow as the final step in a bidirectional transformation
            pipeline. By convention protocol stacks are growing to the left: the right most is the bottom
            layer, the closest to the metal.
            <![CDATA[ 
            {{{
                +---------------------------+
                | Resulting Flow            |
                |                           |
                |  +------+        +------+ |
            I1 ~~> |      |  ~O1~> |      | |
                |  | this |        | flow | |
            O2 <~~ |      | <~I2~  |      | |
                |  +------+        +------+ |
                +---------------------------+
            }}}
            ]]>
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other Flow’s value), use
            <see cref="M:Akka.Streams.Dsl.BidiFlow`5.JoinMat``2(Akka.Streams.Dsl.Flow{`1,`2,``0},System.Func{`4,``0,``1})"/> if a different strategy is needed.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.JoinMat``2(Akka.Streams.Dsl.Flow{`1,`2,``0},System.Func{`4,``0,``1})">
            <summary>
            Add the given Flow as the final step in a bidirectional transformation
            pipeline. By convention protocol stacks are growing to the left: the right most is the bottom
            layer, the closest to the metal.
            <![CDATA[ 
            {{{
                +---------------------------+
                | Resulting Flow            |
                |                           |
                |  +------+        +------+ |
            I1 ~~> |      |  ~O1~> |      | |
                |  | this |        | flow | |
            O2 <~~ |      | <~I2~  |      | |
                |  +------+        +------+ |
                +---------------------------+
            }}}
            ]]>
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting <see cref="T:Akka.Streams.Dsl.Flow`3"/>.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.IDelayStrategy`1">
            <summary>
            Allows to manage delay and can be stateful to compute delay for any sequence of elements,
            all elements go through <see cref="M:Akka.Streams.Dsl.IDelayStrategy`1.NextDelay(`0)"/> updating state and returning delay for each element
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.IDelayStrategy`1.NextDelay(`0)">
            <summary>
            Returns delay for ongoing <paramref name="element"/>, <code>TimeSpan.Zero</code> means passing without delay
            </summary>
            <param name="element">element</param>
            <returns></returns>
        </member>
        <member name="T:Akka.Streams.Dsl.FixedDelay`1">
            <summary>
            Fixed delay strategy, always returns constant delay for any element.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.FixedDelay`1.#ctor(System.TimeSpan)">
            <param name="delay">value of the delay</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FixedDelay`1.NextDelay(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Dsl.LinearIncreasingDelay`1">
            <summary>
            Strategy with linear increasing delay.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.LinearIncreasingDelay`1.#ctor(System.TimeSpan,System.Func{`0,System.Boolean},System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates strategy that starts with <paramref name="initialDelay"/> for each element,
            increases by <paramref name="increaseStep"/> every time when <paramref name="needsIncrease"/> returns <code>true</code> up to <paramref name="maxDelay"/>,
            when <paramref name="needsIncrease"/> returns <code>false</code> it resets to <paramref name="initialDelay"/>.
            </summary>
            <param name="increaseStep">step by which delay is increased</param>
            <param name="needsIncrease">if <code>true</code> delay increases, if <code>false</code> delay resets to <paramref name="initialDelay"/></param>
            <param name="initialDelay">initial delay for each of elements</param>
            <param name="maxDelay">limits maximum delay</param>
        </member>
        <member name="M:Akka.Streams.Dsl.LinearIncreasingDelay`1.NextDelay(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Dsl.DelayFlow`1">
            <summary>
            Flow stage for universal delay management, allows to manage delay through <see cref="T:Akka.Streams.Dsl.IDelayStrategy`1"/>.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.DelayFlow`1.#ctor(System.Func{Akka.Streams.Dsl.IDelayStrategy{`0}})">
            <summary>
            Flow stage that determines delay for each ongoing element invoking <code>TimeSpan DelayStrategy.NextDelay(T element)</code>.
            Implementing <see cref="T:Akka.Streams.Dsl.IDelayStrategy`1"/> with your own gives you flexible ability to manage delay value depending on coming elements.
            It is important notice that <see cref="T:Akka.Streams.Dsl.IDelayStrategy`1"/> can be stateful.
            There are also some predefined strategies: <see cref="T:Akka.Streams.Dsl.FixedDelay`1"/> and <see cref="T:Akka.Streams.Dsl.LinearIncreasingDelay`1"/>
            </summary>
            <param name="strategySupplier">creates new <see cref="T:Akka.Streams.Dsl.IDelayStrategy`1"/> object for each materialization</param>
        </member>
        <member name="M:Akka.Streams.Dsl.DelayFlow`1.#ctor(System.TimeSpan)">
            <summary>
            Flow stage with fixed delay for each element.
            </summary>
            <param name="fixedDelay">value of the delay</param>
        </member>
        <member name="T:Akka.Streams.Dsl.FileIO">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FileIO.FromFile(System.IO.FileInfo,System.Int32,System.Int64)">
             <summary>
             Creates a Source from a Files contents.
             Emitted elements are <paramref name="chunkSize"/> sized <see cref="T:Akka.IO.ByteString"/> elements,
             except the final element, which will be up to <paramref name="chunkSize"/> in size.
            
             You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
             set it for a given Source by using <see cref="T:Akka.Streams.ActorAttributes"/>.
            
             It materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> containing the number of bytes read from the source file upon completion,
             and a possible exception if IO operation was not completed successfully.
             </summary>
             <param name="f">the File to read from</param>
             <param name="chunkSize">the size of each read operation, defaults to 8192</param>
             <param name="startPosition">the start position to read from, defaults to 0</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FileIO.ToFile(System.IO.FileInfo,System.Nullable{System.IO.FileMode},System.Int64)">
             <summary>
             Creates a Sink which writes incoming <see cref="T:Akka.IO.ByteString"/> elements to the given file. Overwrites existing files
             by truncating their contents as default.
            
             Materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> that will be completed with the size of the file(in bytes) at the streams completion,
             and a possible exception if IO operation was not completed successfully.
            
             This source is backed by an Actor which will use the dedicated "akka.stream.blocking-io-dispatcher",
             unless configured otherwise by using <see cref="T:Akka.Streams.ActorAttributes"/>.
             </summary>
             <param name="f">the file to write to</param>
             <param name="fileMode">the write file mode, defaults to <see cref="F:System.IO.FileMode.OpenOrCreate"/></param>
             <param name="startPosition">the start position to write to, defaults to 0</param>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Flow`3">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Flow`3"/> is a set of stream processing steps that has one open input and one open output.
            </summary>
            <typeparam name="TIn">Type of the flow input.</typeparam>
            <typeparam name="TOut">Type of the flow output.</typeparam>
            <typeparam name="TMat">Type of value, flow graph may materialize to.</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.Flow`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Flow`3.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#Dsl#IFlow{TOut,TMat}#Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Flow`3"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other flow’s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1},System.Func{`2,``1,``2})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Flow`3"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other flow’s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1},System.Func{`2,``1,``2})"/> if a different strategy is needed.
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#Dsl#IFlow{TOut,TMat}#ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1},System.Func{`2,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1},System.Func{`2,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Flow`3"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#IGraph{Akka#Streams#FlowShape{TIn,TOut},TMat}#WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to the given ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to the given ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#IGraph{Akka#Streams#FlowShape{TIn,TOut},TMat}#AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Flow`3.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Flow`3.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#IGraph{Akka#Streams#FlowShape{TIn,TOut},TMat}#Named(System.String)">
            <summary>
            Add a name attribute to this Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Named(System.String)">
            <summary>
            Add a name attribute to this Flow.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#IGraph{Akka#Streams#FlowShape{TIn,TOut},TMat}#Async">
            <summary>
            Put an asynchronous boundary around this Source.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Async">
            <summary>
            Put an asynchronous boundary around this Source.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Ask``1(Akka.Actor.IActorRef,System.TimeSpan,System.Int32)">
            <summary>
            Use the `ask` pattern to send a request-reply message to the target <paramref name="actorRef"/>.
            If any of the asks times out it will fail the stream with a <see cref="T:Akka.Actor.AskTimeoutException"/>.
            
            Parallelism limits the number of how many asks can be "in flight" at the same time.
            Please note that the elements emitted by this operator are in-order with regards to the asks being issued
            (i.e. same behaviour as <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>).
            
            The operator fails with an <see cref="T:Akka.Streams.WatchedActorTerminatedException"/> if the target actor is terminated,
            or with an <see cref="T:System.TimeoutException"/> in case the ask exceeds the timeout passed in.
            
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            
            '''Emits when''' the futures (in submission order) created by the ask pattern internally are completed. 
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures. 
            '''Completes when''' upstream completes and all futures have been completed and all elements have been emitted. 
            '''Fails when''' the passed in actor terminates, or a timeout is exceeded in any of the asks performed. 
            '''Cancels when''' downstream cancels.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Akka#Streams#Dsl#IFlow{TOut,TMat}#MapMaterializedValue``1(System.Func{`2,``0})">
            <summary>
            Transform the materialized value of this Flow, leaving all other properties as they were.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.MapMaterializedValue``1(System.Func{`2,``0})">
            <summary>
            Transform the materialized value of this Flow, leaving all other properties as they were.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>, concatenating the processing steps of both.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Sink`2"/> will be the materialized
            value of the current flow (ignoring the given Sink’s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0},System.Func{`2,``0,``1})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0},System.Func{`2,``0,``1})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>, concatenating the processing steps of both.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            Sink into the materialized value of the resulting Sink.
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ConcatMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`1},``0},System.Func{`2,``0,``1})">
             <summary>
             Concatenate the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that once this
             Flow’s input is exhausted and all result elements have been generated,
             the Source’s elements will be produced.
            
             Note that the <seealso cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this Flow and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/> gets upstream error - no elements from the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            
             @see <seealso cref="T:Akka.Streams.Dsl.Concat`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="that">TBD</param>
             <param name="materializedFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Join``1(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0})">
            <summary>
            Join this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to another <see cref="T:Akka.Streams.Dsl.Flow`3"/>, by cross connecting the inputs and outputs,
            creating a <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/>.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other Flow’s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.JoinMaterialized``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0},System.Func{`2,``0,``1})"/> if a different strategy is needed.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Join``3(Akka.Streams.IGraph{Akka.Streams.BidiShape{`1,``1,``0,`0},``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="bidi">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.JoinMaterialized``4(Akka.Streams.IGraph{Akka.Streams.BidiShape{`1,``1,``0,`0},``2},System.Func{`2,``2,``3})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMatRes">TBD</typeparam>
            <param name="bidi">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.JoinMaterialized``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0},System.Func{`2,``0,``1})">
            <summary>
            Join this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to another <see cref="T:Akka.Streams.Dsl.Flow`3"/>, by cross connecting the inputs and outputs, creating a <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/>
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            Flow into the materialized value of the resulting Flow.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.RunWith``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``1},Akka.Streams.IMaterializer)">
            <summary>
            Connect the <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/> and then connect it to the <see cref="T:Akka.Streams.Dsl.Sink`2"/> and run it. 
            The returned tuple contains the materialized values of the <paramref name="source"/> and <paramref name="sink"/>, e.g. the <see cref="T:Reactive.Streams.ISubscriber`1"/> 
            of a <see cref="M:Akka.Streams.Dsl.Source.AsSubscriber``1"/> and <see cref="T:Reactive.Streams.IPublisher`1"/> of a <see cref="M:Akka.Streams.Dsl.Sink.Publisher``1"/>.
            </summary>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="sink">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ToProcessor">
            <summary>
            Converts this Flow to a <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> that materializes to a Reactive Streams <see cref="T:Reactive.Streams.IProcessor`2"/>
            which implements the operations encapsulated by this Flow. Every materialization results in a new Processor
            instance, i.e. the returned <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> is reusable.
            </summary>
            <returns>A <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> that materializes to a <see cref="T:Reactive.Streams.IProcessor`2"/> when Run() is called on it.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Flow">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Flow"/> is a set of stream processing steps that has one open input and one open output.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Identity``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Identity``2">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromProcessor``2(System.Func{Reactive.Streams.IProcessor{``0,``1}})">
            <summary>
            Creates flow from the Reactive Streams <see cref="T:Reactive.Streams.IProcessor`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="factory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromProcessorMaterialized``3(System.Func{System.ValueTuple{Reactive.Streams.IProcessor{``0,``1},``2}})">
            <summary>
            Creates a Flow from a Reactive Streams <see cref="T:Reactive.Streams.IProcessor`2"/> and returns a materialized value.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="factory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Create``1">
            <summary>
            Helper to create a <see cref="T:Akka.Streams.Dsl.Flow`3"/> without a <see cref="T:Akka.Streams.Dsl.Source"/> or <see cref="T:Akka.Streams.Dsl.Sink"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Create``2">
            <summary>
            Helper to create a <see cref="T:Akka.Streams.Dsl.Flow`3"/> without a <see cref="T:Akka.Streams.Dsl.Source"/> or <see cref="T:Akka.Streams.Dsl.Sink"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromFunction``2(System.Func{``0,``1})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Flow`3"/> which will use the given function to transform its inputs to outputs. It is equivalent
            to <see cref="T:Akka.Streams.Implementation.Fusing.Select`2"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="function">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromGraph``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``2})">
            <summary>
            A graph with the shape of a flow logically is a flow, this method makes it so also in type.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromSinkAndSource``3(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Flow`3"/> from a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and a <see cref="T:Akka.Streams.Dsl.Source`2"/> where the flow's input
            will be sent to the sink and the flow's output will come from the source.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromSinkAndSource``5(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Flow`3"/> from a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and a <see cref="T:Akka.Streams.Dsl.Source`2"/> where the flow's input
            will be sent to the sink and the flow's output will come from the source.
            
            The <paramref name="combine"/> function is used to compose the materialized values of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> and <see cref="T:Akka.Streams.Dsl.Source`2"/>
            into the materialized value of the resulting <see cref="T:Akka.Streams.Dsl.Flow`3"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="source">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.FlowProcessor`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.#ctor(Reactive.Streams.ISubscriber{`0},Reactive.Streams.IPublisher{`1})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowProcessor`2.Subscribe(Reactive.Streams.ISubscriber{`1})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="T:Akka.Streams.Dsl.IFlow`2">
            <summary>
            Operations offered by Sources and Flows with a free output side: the DSL flows left-to-right only.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.IFlow`2.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be the materialized
            value of the current flow (ignoring the other flow’s value), use
            <see cref="M:Akka.Streams.Dsl.IFlow`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})"/> if a different strategy is needed.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IFlow`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IFlow`2.MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            Transform the materialized value of this Flow, leaving all other properties as they were.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.FlowOperations">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Recover``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``1}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.        
            <para/>
            Throwing an exception inside Recover will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and pf returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception pf can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.RecoverWith``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWith will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception pf can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.RecoverWithRetries``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}},System.Int32)">
            <summary>
            RecoverWithRetries  allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered up to <paramref name="attempts"/> number of times so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized. Note that if you pass in 0, this won't attempt to recover at all. Passing in -1 will behave exactly the same as  <see cref="M:Akka.Streams.Dsl.FlowOperations.RecoverWithRetries``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}},System.Int32)"/>.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWithRetries will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">Receives the failure cause and returns the new Source to be materialized if any</param>
            <param name="attempts">Maximum number of retries or -1 to retry indefinitely</param>
            <exception cref="T:System.ArgumentException">if <paramref name="attempts"/> is a negative number other than -1</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SelectError``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,System.Exception})">
            <summary>
            While similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Recover``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``1}})"/> this stage can be used to transform an error signal to a different one without logging
            it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e => throw e2) since Recover
            would log the e2 error. 
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Similarily to <see cref="M:Akka.Streams.Dsl.FlowOperations.Recover``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``1}})"/> throwing an exception inside SelectError will be logged.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="selector"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception returned by the <paramref name="selector"/>
            </para>
            Cancels when downstream cancels 
            </summary>
            <param name="flow">TBD</param>
            <param name="selector">Receives the failure cause and returns the new cause, return the original exception if no other should be applied</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Select``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Transform this stream by applying the given function <paramref name="mapper"/> to each of the elements
            as they pass through this processing step.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the mapping function <paramref name="mapper"/> returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            Emits when the mapping function <paramref name="mapConcater"/> returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcater">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.StatefulSelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{System.Func{``1,System.Collections.Generic.IEnumerable{``2}}})">
            <summary>
            Transform each input element into an Enumerable of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function <paramref name="mapConcaterFactory"/> a new for every materialization —
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>.
            
            The returned Enumerable MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            Emits when the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcaterFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SelectAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task`1"/> and the
            value of that task will be emitted downstream. The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})"/>.
            These tasks may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when the task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream
            backpressures or the first task is not completed
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that task will be emitted downstream. The number of tasks that shall run in parallel is given as
            the first argument to <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})"/>. Each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when any of the tasks returned by the provided function complete
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.SelectAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Where``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Only pass on those elements that satisfy the given <paramref name="predicate"/>.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.WhereNot``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Only pass on those elements that NOT satisfy the given <paramref name="predicate"/>.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1},System.Boolean)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after <paramref name="predicate"/>
            returns false for the first time, including the first failed element iff inclusive is true
            Due to input buffering some elements may have been requested from upstream publishers
            that will then not be processed downstream of this step.
            
            The stream will be completed without producing any elements if <paramref name="predicate"/> is false for
            the first stream element.
            <para>
            Emits when the <paramref name="predicate"/> is true
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when <paramref name="predicate"/> returned false (or 1 after predicate returns false if <paramref name="inclusive"/>) or upstream completes
            </para>
            <para>
            Cancels when <paramref name="predicate"/> returned false or downstream cancels
            </para>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Limit``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/> <seealso cref="M:Akka.Streams.Dsl.FlowOperations.LimitWeighted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64,System.Func{``1,System.Int64})"/> 
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <param name="inclusive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SkipWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Discard elements at the beginning of the stream while <paramref name="predicate"/> is true.
            All elements will be taken after <paramref name="predicate"/> returns false first time.
            <para>
            Emits when <paramref name="predicate"/> returned false and for all following stream elements
            </para>
            Backpressures when <paramref name="predicate"/> returned false and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Collect``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Transform this stream by applying the given function <paramref name="collector"/> to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            Emits when the provided function <paramref name="collector"/> is defined for the element
            </para>
            Backpressures when the function <paramref name="collector"/> is defined for the element and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="collector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Grouped``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the specified number of elements has been accumulated or upstream completed
            </para>
            Backpressures when a group has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Limit``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1},System.Boolean)"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.LimitWeighted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64,System.Func{``1,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1},System.Boolean)"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Sliding``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            Emits when enough elements have been collected within the window or upstream completed
            </para>
            Backpressures when a window has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="step">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Scan``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Aggregate``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the function scanning the element returns a new element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ScanAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Scan``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but with a asynchronous function,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>
            emitting a <see cref="T:System.Threading.Tasks.Task`1"/> that resolves to the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> current value starts at the previous
            current value, or zero when it doesn't have one, and the stream will continue.
            <para>
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            Emits the <see cref="T:System.Threading.Tasks.Task`1"/> returned by <paramref name="scan"/> completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes upstream completes and the last task returned by <paramref name="scan"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Aggregate``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Scan``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but only emits its result when the upstream completes,
            after which it also completes. Applies the given function <paramref name="fold"/> towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AggregateAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Aggregate``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but with an asynchronous function.
            Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> returns a failure and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Aggregate``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Sum``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Aggregate``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but uses first element as zero element.
            Applies the given function <paramref name="reduce"/> towards its current and next value,
            yielding the next current value. 
            
            If the stream is empty (i.e. completes before signaling any elements),
            the sum stage will fail its downstream with a <see cref="T:Akka.Streams.NoSuchElementException"/>,
            which is semantically in-line with that standard library collections do in such situations.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="reduce">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Intersperse``3(Akka.Streams.Dsl.Flow{``0,``1,``2},``1,``1,``1)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="T:Akka.Streams.Dsl.Concat`2"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="start"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="start">TBD</param>
            <param name="inject">TBD</param>
            <param name="end">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Intersperse``3(Akka.Streams.Dsl.Flow{``0,``1,``2},``1)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="T:Akka.Streams.Dsl.Concat`2"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="inject"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="inject">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.GroupedWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the configured time elapses since the last group has been emitted
            </para>
            Backpressures when the configured time elapses since the last group has been emitted
            <para>
            Completes when upstream completes (emits last group)
            </para>
            Cancels when downstream completes
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="timeout">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Delay``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            Emits when there is a pending element in the buffer and configured time for this element elapsed
             <para/> * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            Backpressures when depending on OverflowStrategy
             <para/> * Backpressure - backpressures when buffer is full
             <para/> * DropHead, DropTail, DropBuffer - never backpressures
             <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Skip``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            Emits when the specified number of elements has been dropped already
            </para>
            Backpressures when the specified number of elements has been dropped and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SkipWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            Emits when the specified time elapsed and a new upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            Emits when an upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or timer fires
            </para>
            Cancels when downstream cancels or timer fires
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.FlowOperations.Conflate``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TSeed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Conflate``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Batch``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,``2},System.Func{``2,``1,``2})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
             <para>
             Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
             </para>
             <para>
             Emits when downstream stops backpressuring and there is an aggregated element available
             </para>
             <para>
             Backpressures when there are <paramref name="max"/> batched elements and 1 pending element and downstream backpressures
             </para>
             <para>
             Completes when upstream completes and there is no batched/pending element waiting
             </para>
             <para>
             Cancels when downstream cancels
             </para>
             See also <seealso cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>, <seealso cref="M:Akka.Streams.Dsl.FlowOperations.BatchWeighted``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,System.Int64},System.Func{``1,``2},System.Func{``2,``1,``2})"/>
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.BatchWeighted``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,System.Int64},System.Func{``1,``2},System.Func{``2,``1,``2})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate <see cref="T:Akka.IO.ByteString"/>
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the <paramref name="seed"/> function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             Emits when downstream stops backpressuring and there is a batched element available
            
             Backpressures when there are <paramref name="max"/> weighted batched elements + 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>, <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Batch``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,``2},System.Func{``2,``1,``2})"/>
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Expand``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerator{``2}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="extrapolate"/> function will complete the stream with failure.
            <para>
            Emits when downstream stops backpressuring
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Buffer``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            Emits when downstream stops backpressuring and there is a pending element in the buffer
            </para>
            Backpressures when downstream backpressures or depending on OverflowStrategy:
            <para/> * Backpressure - backpressures when buffer is full
            <para/> * DropHead, DropTail, DropBuffer - never backpressures
            <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Transform``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Stage.IStage{``1,``2}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="stageFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.PrefixAndTail``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            Emits when the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            Backpressures when downstream backpressures or substream backpressures
            <para>
            Completes when prefix elements has been consumed and substream has been consumed
            </para>
            Cancels when downstream cancels or substream cancels
            </summary> 
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.GroupBy``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.Func{``1,``3})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            
            Function <paramref name="groupingFunc"/>  MUST NOT return null. This will throw exception and trigger supervision decision mechanism.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            Backpressures when there is an element pending for a group whose substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and all substreams cancel
            </summary> 
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="maxSubstreams">TBD</param>
            <param name="groupingFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the * first * element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal <see cref="T:Akka.Streams.Dsl.Source`2"/> or <see cref="T:Akka.Streams.Dsl.Flow`3"/>,
            it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>)
            or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and 
            <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
            on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})"/>
            operator itself—and thereby all substreams—once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            Emits when an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            Backpressures when there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})"/> 
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It * ends * the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal <see cref="T:Akka.Streams.Dsl.Source"/> or <see cref="T:Akka.Streams.Dsl.Flow"/>,
             it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
             are applied to all encountered substreams in the same fashion. Substream mode
             is exited either by closing the substream (i.e.connecting it to a <see cref="T:Akka.Streams.Dsl.Sink"/>)
             or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
             on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})"/>
             operator itself—and thereby all substreams—once all internal or
             explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             Emits when an element passes through.When the provided predicate is true it emits the element
             and opens a new substream for subsequent element
             </para>
             Backpressures when there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             Completes when upstream completes
             </para>
             Cancels when downstream cancels and substreams cancel
             </summary>
             <seealso cref="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})"/> 
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="substreamCancelStrategy">TBD</param>
             <param name="predicate">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams. It *ends* the current substream when the
            predicate is true.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ConcatMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ZipWithIndex``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
            <summary>
            Combine the elements of current flow into a stream of tuples consisting
            of all elements paired with their index. Indices start at 0.
            
            <para/>
            Emits when upstream emits an element and is paired with their index
            <para/>
            Backpressures when downstream backpressures
            <para/>
            Completes when upstream completes
            <para/>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InitialTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before first element arrives
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.CompletionTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.IdleTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>. 
            The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between two emitted elements
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.BackpressureTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
            the stream is failed with a <see cref="T:System.TimeoutException"/>. The timeout is checked periodically,
            so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between element emission and downstream demand.
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.KeepAlive``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.TimeSpan,System.Func{``2})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            Emits when upstream emits an element or if the upstream was idle for the configured period
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TInjected">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <param name="injectElement">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Throttle``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="elements"/>/<paramref name="per"/>. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="elements">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="mode">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Throttle``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,System.Func{``1,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be spared for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="cost">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="calculateCost">TBD</param>
            <param name="mode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AlsoToMaterialized``5(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.FlowOperations.AlsoTo``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``1},``2})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="materializerFunction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AlsoTo``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``1},``2})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             Emits when element is available and demand exists both from the Sink and the downstream.
            
             Backpressures when downstream or Sink backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.WatchTermination``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``2,System.Threading.Tasks.Task,``3})">
            <summary>
             Materializes to <see cref="T:System.Threading.Tasks.Task`1"/> that completes on getting termination message.
             The task completes with success when received complete message from upstream or cancel
             from downstream. It fails with the same error when received error message from
             downstream.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="materializerFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Monitor``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``2,Akka.Streams.IFlowMonitor,``3})">
            <summary>
            Materializes to <see cref="T:Akka.Streams.IFlowMonitor"/> that allows monitoring of the the current flow. All events are propagated
            by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
            event, and may therefor affect performance.
            The <paramref name="combine"/> function is used to combine the <see cref="T:Akka.Streams.IFlowMonitor"/> with this flow's materialized value.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Detach``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             Emits when upstream emits an element
            
             Backpressures when downstream backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InitialDelay``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            Emits when upstream emits an element if the initial delay is already elapsed
            </para>
            Backpressures when downstream backpressures or initial delay is not yet elapsed
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="delay">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Log``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.String,System.Func{``1,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            <para>
            Emits when the mapping function returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="name">TBD</param>
            <param name="extract">TBD</param>
            <param name="log">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Zip``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})">
            <summary>
            Combine the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/> into a stream of tuples.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ZipWith``5(Akka.Streams.Dsl.Flow{``0,``1,``4},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Func{``1,``2,``3})">
            <summary>
            Put together the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/>
            into a stream of combined elements using a combiner function.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Interleave``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.Flow`3"/>.
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="other"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            Emits when element is available from the currently consumed upstream
            </para>
            Backpressures when downstream backpressures. Signal to current
            upstream, switch to next upstream when received <paramref name="segmentSize"/> elements
            <para>
            Completes when the <see cref="T:Akka.Streams.Dsl.Flow`3"/> and given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="segmentSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InterleaveMaterialized``6(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Int32,System.Func{``3,``4,``5})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/> source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="T1">TBD</typeparam>
             <typeparam name="T2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="graph">TBD</param>
             <param name="segmentSize">TBD</param>
             <param name="combine">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Merge``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="eagerComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeMaterialized``6(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Func{``3,``4,``5})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.FlowOperations.Merge``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3},System.Boolean)"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Func{``1,``1,System.Int32})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="orderFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Collections.Generic.IComparer{``1})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Concat``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Concatenate the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that once this
            Flow’s input is exhausted and all result elements have been generated,
            the Source’s elements will be produced.
            
            Note that the <see cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this <see cref="T:Akka.Streams.Dsl.Flow`3"/> and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this <see cref="T:Akka.Streams.Dsl.Flow`3"/> gets upstream error - no elements from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            <para>
            Emits when element is available from current stream or from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> when current is completed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Prepend``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})">
             <summary>
             Prepend the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that before elements
             are generated from this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <see cref="T:Akka.Streams.Dsl.Source`2"/> gets upstream error - no elements from this <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be pulled.
            
             Emits when element is available from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> or from current stream when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is completed
            
             Backpressures when downstream backpressures
            
             Completes when this <see cref="T:Akka.Streams.Dsl.Flow`3"/> completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut1">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.OrElse``2(Akka.Streams.Dsl.Flow{``0,``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
             <summary>
             Provides a secondary source that will be consumed if this stream completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             Note that this Flow will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes or it gets
             cancelled.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                              is available from the second stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                                by from this stream.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.OrElseMaterialized``4(Akka.Streams.Dsl.Flow{``0,``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``2},System.Func{``1,``2,``3})">
             <summary>
             Provides a secondary source that will be consumed if this source completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             
             <seealso cref="M:Akka.Streams.Dsl.FlowOperations.OrElse``2(Akka.Streams.Dsl.Flow{``0,``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/>
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <param name="materializedFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Watch``2(Akka.Streams.Dsl.Flow{``0,``0,``1},Akka.Actor.IActorRef)">
            <summary>
            The operator fails with an <see cref="T:Akka.Streams.WatchedActorTerminatedException"/> if the target actor is terminated.
            
            '''Emits when''' upstream emits 
            '''Backpressures when''' downstream backpressures 
            '''Completes when''' upstream completes 
            '''Fails when''' the watched actor terminates 
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AsFlowWithContext``6(Akka.Streams.Dsl.Flow{``5,``3,``4},System.Func{``1,``0,``5},System.Func{``3,``2})">
            <summary>
            Turns a Flow into a FlowWithContext which manages a context per element along a stream.
            </summary>
            <param name="flow">Flow to convert</param>
            <param name="collapseContext">Turn each incoming pair of element and context value into an element of passed Flow</param>
            <param name="extractContext">Turn each outgoing element of passed Flow into an outgoing context value</param>
            <typeparam name="TIn">New flow incoming elements type</typeparam>
            <typeparam name="TCtxIn">New flow incoming elements context</typeparam>
            <typeparam name="TOut">Out elements type</typeparam>
            <typeparam name="TCtxOut">Resulting context type</typeparam>
            <typeparam name="TMat">Materialized value type</typeparam>
            <typeparam name="TIn2">Type of passed flow elements</typeparam>
        </member>
        <member name="T:Akka.Streams.Dsl.FlowWithContext`5">
            <summary>
             A flow that provides operations which automatically propagate the context of an element.
             Only a subset of common operations from Flow is supported. As an escape hatch you can
             use [[FlowWithContextOps.via]] to manually provide the context propagation for otherwise unsupported
             operations.
             
             An "empty" flow can be created by calling <see cref="M:Akka.Streams.Dsl.FlowWithContext.Create``2"/>.
             
             API MAY CHANGE
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContext`5.Via``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{`3,`2},System.ValueTuple{``1,``0}},``2})">
            <summary>
             Transform this flow by the regular flow. The given flow must support manual context propagation by
             taking and producing tuples of (data, context).
             
             This can be used as an escape hatch for operations that are not (yet) provided with automatic
             context propagation here.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContext`5.ViaMaterialized``4(Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{`3,`2},System.ValueTuple{``1,``0}},``2},System.Func{`4,``2,``3})">
            <summary>
             Transform this flow by the regular flow. The given flow must support manual context propagation by
             taking and producing tuples of (data, context).
             
             This can be used as an escape hatch for operations that are not (yet) provided with automatic
             context propagation here.
             
             The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
             flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContext.Create``2">
            <summary>
            Creates an "empty" <see cref="T:Akka.Streams.Dsl.FlowWithContext`5"/> that passes elements through with their context unchanged.
            </summary>
            <typeparam name="TCtx"></typeparam>
            <typeparam name="TIn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContext.From``5(Akka.Streams.Dsl.Flow{System.ValueTuple{``1,``0},System.ValueTuple{``3,``2},``4})">
            <summary>
            Creates a FlowWithContext from a regular flow that operates on a pair of `(data, context)` elements.
            </summary>
            <param name="flow"></param>
            <typeparam name="TCtxIn"></typeparam>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TCtxOut"></typeparam>
            <typeparam name="TOut"></typeparam>
            <typeparam name="TMat"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.Select``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``4},System.Func{``2,``3})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Select``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.SelectAsync``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``4},System.Int32,System.Func{``2,System.Threading.Tasks.Task{``3}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.Collect``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``4},System.Func{``2,``3})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Collect``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.Where``4(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3},System.Func{``2,System.Boolean})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Where``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.WhereNot``4(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3},System.Func{``2,System.Boolean})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Grouped``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.Grouped``4(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3},System.Int32)">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Grouped``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)"/>
            Each output group will be associated with a `Seq` of corresponding context elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.Sliding``4(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3},System.Int32,System.Int32)">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.Sliding``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.Int32)"/>
            Each output group will be associated with a `Seq` of corresponding context elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.SelectConcat``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``4},System.Func{``2,System.Collections.Generic.IEnumerable{``3}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.SelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>.
            The context of the input element will be associated with each of the output elements calculated from
            this input element.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.StatefulSelectConcat``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``4},System.Func{System.Func{``2,System.Collections.Generic.IEnumerable{``3}}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.FlowOperations.StatefulSelectMany``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{System.Func{``1,System.Collections.Generic.IEnumerable{``2}}})"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowWithContextOperations.SelectContext``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``3,``4},System.Func{``0,``2})">
            <summary>
            Apply the given function to each context element (leaving the data elements unchanged).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.Select``4(Akka.Streams.Dsl.SourceWithContext{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Select``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.SelectAsync``4(Akka.Streams.Dsl.SourceWithContext{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.Collect``4(Akka.Streams.Dsl.SourceWithContext{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Collect``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.Where``3(Akka.Streams.Dsl.SourceWithContext{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Where``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.WhereNot``3(Akka.Streams.Dsl.SourceWithContext{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Grouped``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.Grouped``3(Akka.Streams.Dsl.SourceWithContext{``0,``1,``2},System.Int32)">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Grouped``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)"/>
            Each output group will be associated with a `Seq` of corresponding context elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.Sliding``3(Akka.Streams.Dsl.SourceWithContext{``0,``1,``2},System.Int32,System.Int32)">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.Sliding``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.Int32)"/>
            Each output group will be associated with a `Seq` of corresponding context elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.SelectConcat``4(Akka.Streams.Dsl.SourceWithContext{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>.
            The context of the input element will be associated with each of the output elements calculated from
            this input element.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.StatefulSelectConcat``4(Akka.Streams.Dsl.SourceWithContext{``0,``1,``3},System.Func{System.Func{``1,System.Collections.Generic.IEnumerable{``2}}})">
            <summary>
            Context-preserving variant of <see cref="M:Akka.Streams.Dsl.SourceOperations.StatefulSelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContextOperations.SelectContext``4(Akka.Streams.Dsl.SourceWithContext{``0,``2,``3},System.Func{``0,``1})">
            <summary>
            Apply the given function to each context element (leaving the data elements unchanged).
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Framing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.Delimiter(Akka.IO.ByteString,System.Int32,System.Boolean)">
            <summary>
            Creates a Flow that handles decoding a stream of unstructured byte chunks into a stream of frames where the
            incoming chunk stream uses a specific byte-sequence to mark frame boundaries.
            
            The decoded frames will not include the separator sequence.
            
            If there are buffered bytes (an incomplete frame) when the input stream finishes and <paramref name="allowTruncation"/> is set to
            false then this Flow will fail the stream reporting a truncated frame.
            </summary>
            <param name="delimiter">The byte sequence to be treated as the end of the frame.</param>
            <param name="maximumFrameLength">The maximum length of allowed frames while decoding. If the maximum length is exceeded this Flow will fail the stream.</param>
            <param name="allowTruncation">If false, then when the last frame being decoded contains no valid delimiter this Flow fails the stream instead of returning a truncated frame.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.LengthField(System.Int32,System.Int32,System.Int32,Akka.IO.ByteOrder)">
            <summary>
            Creates a Flow that decodes an incoming stream of unstructured byte chunks into a stream of frames, assuming that
            incoming frames have a field that encodes their length.
            
            If the input stream finishes before the last frame has been fully decoded this Flow will fail the stream reporting
            a truncated frame.
            </summary>
            <param name="fieldLength">The length of the "Count" field in bytes</param>
            <param name="maximumFramelength">The maximum length of allowed frames while decoding. If the maximum length is exceeded this Flow will fail the stream. This length *includes* the header (i.e the offset and the length of the size field)</param>
            <param name="fieldOffset">The offset of the field from the beginning of the frame in bytes</param>
            <param name="byteOrder">The <see cref="T:Akka.IO.ByteOrder"/> to be used when decoding the field</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="fieldLength"/> is not equal to either 1, 2, 3 or 4.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocol(System.Int32)">
            <summary>
            Returns a BidiFlow that implements a simple framing protocol. This is a convenience wrapper over <see cref="M:Akka.Streams.Dsl.Framing.LengthField(System.Int32,System.Int32,System.Int32,Akka.IO.ByteOrder)"/>
            and simply attaches a length field header of four bytes (using big endian encoding) to outgoing messages, and decodes
            such messages in the inbound direction. The decoded messages do not contain the header.
            
            This BidiFlow is useful if a simple message framing protocol is needed (for example when TCP is used to send
            individual messages) but no compatibility with existing protocols is necessary.
            
            The encoded frames have the layout
            {{{
                [4 bytes length field, Big Endian][User Payload]
            }}}
            The length field encodes the length of the user payload excluding the header itself.
            </summary>
            <param name="maximumMessageLength">Maximum length of allowed messages. If sent or received messages exceed the configured limit this BidiFlow will fail the stream. The header attached by this BidiFlow are not included in this limit.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocolDecoder(System.Int32)">
            <summary>
            Protocol decoder that is used by <see cref="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocol(System.Int32)"/>
            </summary>
            <param name="maximumMessageLength">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocolEncoder(System.Int32)">
            <summary>
            Protocol encoder that is used by <see cref="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocol(System.Int32)"/>
            </summary>
            <param name="maximumMessageLength">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Framing.FramingException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.FramingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Framing.FramingException" /> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.LengthFieldFramingStage.Logic.PushFrame">
            <summary>
            push, and reset frameSize and buffer
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.LengthFieldFramingStage.Logic.TryPushFrame">
            <summary>
            try to push downstream, if failed then try to pull upstream
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Merge`2">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking randomly when several have elements ready).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Merge`2.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Merge`2"/> class.
            </summary>
            <param name="inputPorts">TBD</param>
            <param name="eagerComplete">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="inputPorts"/> is less than one.
            </exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Merge`2.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Merge`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Merge`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Merge`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Merge`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Merge`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Merge`1">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking randomly when several have elements ready).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Merge`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Merge`1"/> class.
            </summary>
            <param name="inputPorts">TBD</param>
            <param name="eagerComplete">TBD</param>
        </member>
        <member name="T:Akka.Streams.Dsl.MergePreferred`1">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking from preferred when several have elements ready).
            
            A <see cref="T:Akka.Streams.Dsl.MergePreferred`1"/> has one <see cref="P:Akka.Streams.Dsl.MergePreferred`1.Out"/> port, one <see cref="P:Akka.Streams.Dsl.MergePreferred`1.Preferred"/> input port and 0 or more secondary <see cref="M:Akka.Streams.Dsl.MergePreferred`1.In(System.Int32)"/> ports.
            <para>
            Emits when one of the inputs has an element available, preferring
            a specified input if multiple have elements available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Dsl.MergePreferred`1.MergePreferredShape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.MergePreferredShape.#ctor(System.Int32,Akka.Streams.FanInShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="secondaryPorts">TBD</param>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.MergePreferredShape.#ctor(System.Int32,System.String)">
            <summary>
            TBD
            </summary>
            <param name="secondaryPorts">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.MergePreferredShape.Construct(Akka.Streams.FanInShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.MergePreferred`1.MergePreferredShape.Preferred">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.MergePreferred`1.Logic.MaxEmitting">
            <summary>
            This determines the unfairness of the merge:
            - at 1 the preferred will grab 40% of the bandwidth against three equally fast secondaries
            - at 2 the preferred will grab almost all bandwidth against three equally fast secondaries
            (measured with eventLimit=1 in the GraphInterpreter, so may not be accurate)
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.MergePreferred`1"/> class.
            </summary>
            <param name="secondaryPorts">TBD</param>
            <param name="eagerClose">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="secondaryPorts"/> is less than one.
            </exception>
        </member>
        <member name="P:Akka.Streams.Dsl.MergePreferred`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.MergePreferred`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.MergePreferred`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.MergePreferred`1.Preferred">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePreferred`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.MergePrioritized`1">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking from prioritized once when several have elements ready).
            A <see cref="T:Akka.Streams.Dsl.MergePrioritized`1" /> has one <see cref="P:Akka.Streams.Dsl.MergePrioritized`1.Out" /> port, one or more input port with their priorities.
            <para>
            Emits when one of the inputs has an element available, preferring
            a input based on its priority if multiple have elements available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is `false`
            </para>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergePrioritized`1.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.MergePrioritized`1" /> with specified number of input ports.
            </summary>
            <param name="priorities">Priorities of the input ports</param>
            <param name="eagerComplete">If true, the merge will complete as soon as one of its inputs completes</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="priorities"/> is less or equal zero.
            </exception>
        </member>
        <member name="T:Akka.Streams.Dsl.Interleave">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Interleave.Create``1(System.Int32,System.Int32,System.Boolean)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inputPorts">TBD</param>
            <param name="segmentSize">TBD</param>
            <param name="eagerClose">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Interleave`2">
            <summary>
            Interleave represents deterministic merge which takes N elements per input stream,
            in-order of inputs, emits them downstream and then cycles/"wraps-around" the inputs.
            <para>
            Emits when element is available from current input (depending on phase)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Interleave`2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="inputPorts">TBD</param>
            <param name="segmentSize">TBD</param>
            <param name="eagerClose">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="inputPorts"/> is less than or equal to one
            or the specified <paramref name="segmentSize"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Streams.Dsl.Interleave`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Interleave`2.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Interleave`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Interleave`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Interleave`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.MergeSorted`1">
            <summary>
            Merge two pre-sorted streams such that the resulting stream is sorted.
            <para>
            Emits when both inputs have an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeSorted`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.MergeSorted`1"/> class.
            </summary>
            <param name="compare">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.MergeSorted`1.Left">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.MergeSorted`1.Right">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.MergeSorted`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.MergeSorted`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeSorted`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Broadcast`1">
            <summary>
            Fan-out the stream to several streams emitting each incoming upstream element to all downstream consumers.
            It will not shut down until the subscriptions for at least two downstream subscribers have been established.
            <para>
            Emits when all of the outputs stops backpressuring and there is an input element available
            </para>
            Backpressures when any of the outputs backpressure
            <para>
            Completes when upstream completes
            </para>
            Cancels when If eagerCancel is enabled: when any downstream cancels; otherwise: when all downstreams cancel
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Broadcast`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Broadcast`1"/> class.
            </summary>
            <param name="outputPorts">TBD</param>
            <param name="eagerCancel">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="outputPorts"/> is less than one.
            </exception>
        </member>
        <member name="F:Akka.Streams.Dsl.Broadcast`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Broadcast`1.Out(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Broadcast`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Broadcast`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Broadcast`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Broadcast`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Partition`1">
            <summary>
            Fan-out the stream to several streams. emitting an incoming upstream element to one downstream consumer according
            to the partitioner function applied to the element
            <para>
            Emits when an element is available from the input and the chosen output has demand
            </para>
            Backpressures when the currently chosen output back-pressures
            <para>
            Completes when upstream completes and no output is pending
            </para>
            Cancels when when all downstreams cancel
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Partition`1.#ctor(System.Int32,System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Partition`1"/> class.
            </summary>
            <param name="outputPorts">TBD</param>
            <param name="partitioner">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.Partition`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Partition`1.Out(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Partition`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Partition`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Partition`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.PartitionOutOfBoundsException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionOutOfBoundsException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.PartitionOutOfBoundsException" /> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="T:Akka.Streams.Dsl.Balance`1">
            <summary>
            Fan-out the stream to several streams. Each upstream element is emitted to the first available downstream consumer.
            It will not shut down until the subscriptions
            for at least two downstream subscribers have been established.
            
            A <see cref="T:Akka.Streams.Dsl.Balance`1"/> has one <see cref="P:Akka.Streams.Dsl.Balance`1.In"/> port and 2 or more <see cref="M:Akka.Streams.Dsl.Balance`1.Out(System.Int32)"/> ports.
            <para>
            Emits when any of the outputs stops backpressuring; emits the element to the first available output
            </para>
            Backpressures when all of the outputs backpressure
            <para>
            Completes when upstream completes
            </para>
            Cancels when all downstreams cancel
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Balance`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Balance`1"/> class.
            </summary>
            <param name="outputPorts">TBD</param>
            <param name="waitForAllDownstreams">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="outputPorts"/> is less than one.
            </exception>
        </member>
        <member name="P:Akka.Streams.Dsl.Balance`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Balance`1.Out(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Balance`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Balance`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Balance`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Balance`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Zip`2">
            <summary>
            Combine the elements of 2 streams into a stream of tuples.
            
            A <see cref="T:Akka.Streams.Dsl.Zip`2"/> has a left and a right input port and one out port
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Zip`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Zip`2"/> class.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Zip`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnZip`2">
            <summary>
            Takes a stream of pair elements and splits each pair to two output streams.
            
            An <see cref="T:Akka.Streams.Dsl.UnZip`2"/> has one in port and one left and one right output port.
            <para>
            Emits when all of the outputs stops backpressuring and there is an input element available
            </para>
            Backpressures when any of the outputs backpressure
            <para>
            Completes when upstream completes
            </para>
            Cancels when any downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.UnZip`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.UnZip`2"/> class.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnZip`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipN">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipN.Create``1(System.Int32)">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipN`1"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipN`1">
            <summary>
            Combine the elements of multiple streams into a stream of sequences.
            A <see cref="T:Akka.Streams.Dsl.ZipN`1"/> has a n input ports and one out port
            
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipN`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.ZipN`1"/> class.
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipN`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipN`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWithN">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWithN.Create``2(System.Func{System.Collections.Immutable.IImmutableList{``0},``1},System.Int32)">
            <summary>
            Creates a new <see cref="T:Akka.Streams.Dsl.ZipWithN`2"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zipper">TBD</param>
            <param name="n">TBD</param>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWithN`2">
            <summary>
            Combine the elements of multiple streams into a stream of sequences using a combiner function.
            A <see cref="T:Akka.Streams.Dsl.ZipWithN`2"/> has a n input ports and one out port
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWithN`2.#ctor(System.Func{System.Collections.Immutable.IImmutableList{`0},`1},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.ZipWithN`2"/> class.
            </summary>
            <param name="zipper">TBD</param>
            <param name="n">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWithN`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWithN`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWithN`2.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWithN`2.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="i">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.ZipWithN`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWithN`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWithN`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Concat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Concat.Create``1(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inputPorts">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Concat`2">
            <summary>
            Takes two streams and outputs one stream formed from the two input streams
            by first emitting all of the elements from the first stream and then emitting
            all of the elements from the second stream.
            
            A <see cref="T:Akka.Streams.Dsl.Concat`2"/> has one multiple <see cref="M:Akka.Streams.Dsl.Concat`2.In(System.Int32)"/> ports and one <see cref="P:Akka.Streams.Dsl.Concat`2.Out"/> port.
            <para>
            Emits when the current stream has an element available; if the current input completes, it tries the next one
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Concat`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Concat`2"/> class.
            </summary>
            <param name="inputPorts">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="inputPorts"/> is less than or equal to one.
            </exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Concat`2.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Dsl.Concat`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Concat`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Concat`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Concat`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.OrElse">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.OrElse.Create``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.OrElse`1">
             <summary>
             Takes two streams and passes the first through, the secondary stream is only passed
             through if the primary stream completes without passing any elements through. When
             the first element is passed through from the primary the secondary is cancelled.
             Both incoming streams are materialized when the stage is materialized.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from primary stream or the primary stream closed without emitting any elements and an element
                              is available from the secondary stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels
             </summary>
             <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.OrElse`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.OrElse`1"/> class.
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.OrElse`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.OrElse`1.Primary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.OrElse`1.Secondary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.OrElse`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.OrElse`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.OrElse`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.OrElse`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ForwardOps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``3(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``2},Akka.Streams.Inlet{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``3(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``2},Akka.Streams.SinkShape{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``3(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``2},Akka.Streams.FlowShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``3})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.UniformFanInShape{``0,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.To``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.UniformFanOutShape{``0,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.Via``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.FlowShape{``0,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.Via``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``2},Akka.NotUsed})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.Via``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.UniformFanInShape{``0,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ForwardOps.Via``4(Akka.Streams.Dsl.GraphDsl.ForwardOps{``1,``3},Akka.Streams.UniformFanOutShape{``0,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.ReverseOps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.Outlet{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.SourceShape{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.FlowShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.UniformFanInShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.From``4(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``3},Akka.Streams.UniformFanOutShape{``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.Via``4(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``3},Akka.Streams.FlowShape{``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.Via``4(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``3},Akka.Streams.IGraph{Akka.Streams.FlowShape{``1,``2},``3})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.Via``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.UniformFanInShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.ReverseOps.Via``3(Akka.Streams.Dsl.GraphDsl.ReverseOps{``0,``2},Akka.Streams.UniformFanOutShape{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="ops">TBD</param>
            <param name="junction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.MergeHub">
            <summary>
            A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of
            producers. It consists of two parts, a <see cref="T:Akka.Streams.Dsl.Source`2"/> and a <see cref="T:Akka.Streams.Dsl.Sink`2"/>. The <see cref="T:Akka.Streams.Dsl.Source`2"/> streams the element to a consumer from
            its merged inputs. Once the consumer has been materialized, the <see cref="T:Akka.Streams.Dsl.Source`2"/> returns a materialized value which is
            the corresponding <see cref="T:Akka.Streams.Dsl.Sink`2"/>. This <see cref="T:Akka.Streams.Dsl.Sink`2"/> can then be materialized arbitrary many times, where each of the new
            materializations will feed its consumed elements to the original <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.MergeHub.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub.Source``1(System.Int32)">
             <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that emits elements merged from a dynamic set of producers. After the <see cref="T:Akka.Streams.Dsl.Source`2"/> returned
             by this method is materialized, it returns a <see cref="T:Akka.Streams.Dsl.Sink`2"/> as a materialized value. This <see cref="T:Akka.Streams.Dsl.Sink`2"/> can be materialized
             arbitrary many times and each of the materializations will feed the elements into the original <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            
             Every new materialization of the <see cref="T:Akka.Streams.Dsl.Source`2"/> results in a new, independent hub, which materializes to its own
             <see cref="T:Akka.Streams.Dsl.Sink`2"/> for feeding that materialization.
            
             If one of the inputs fails the <see cref="T:Akka.Streams.Dsl.Sink`2"/>, the <see cref="T:Akka.Streams.Dsl.Source`2"/> is failed in turn (possibly jumping over already buffered
             elements). Completed <see cref="T:Akka.Streams.Dsl.Sink`2"/>s are simply removed. Once the <see cref="T:Akka.Streams.Dsl.Source`2"/> is cancelled, the Hub is considered closed
             and any new producers using the <see cref="T:Akka.Streams.Dsl.Sink`2"/> will be cancelled.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <param name="perProducerBufferSize">Buffer space used per producer. Default value is 16.</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub.Source``1">
            <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that emits elements merged from a dynamic set of producers. After the <see cref="T:Akka.Streams.Dsl.Source`2"/> returned
             by this method is materialized, it returns a <see cref="T:Akka.Streams.Dsl.Sink`2"/> as a materialized value. This <see cref="T:Akka.Streams.Dsl.Sink`2"/> can be materialized
             arbitrary many times and each of the materializations will feed the elements into the original <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            
             Every new materialization of the <see cref="T:Akka.Streams.Dsl.Source`2"/> results in a new, independent hub, which materializes to its own
             <see cref="T:Akka.Streams.Dsl.Sink`2"/> for feeding that materialization.
            
             If one of the inputs fails the <see cref="T:Akka.Streams.Dsl.Sink`2"/>, the <see cref="T:Akka.Streams.Dsl.Source`2"/> is failed in turn (possibly jumping over already buffered
             elements). Completed <see cref="T:Akka.Streams.Dsl.Sink`2"/>s are simply removed. Once the <see cref="T:Akka.Streams.Dsl.Source`2"/> is cancelled, the Hub is considered closed
             and any new producers using the <see cref="T:Akka.Streams.Dsl.Sink`2"/> will be cancelled.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.MergeHub.ProducerFailed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub.ProducerFailed.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.MergeHub.ProducerFailed"/> class.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.Dsl.MergeHub`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Dsl.MergeHub`1.HubLogic._queue">
            <summary>
            Basically all merged messages are shared in this queue. Individual buffer sizes are enforced by tracking
            demand per producer in the 'demands' Map. One twist here is that the same queue contains control messages,
            too. Since the queue is read only if the output port has been pulled, downstream backpressure can delay
            processing of control messages. This causes no issues though, see the explanation in 'tryProcessNext'.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub`1.HubLogic.Enqueue(Akka.Streams.Dsl.MergeHub{`0}.IEvent)">
            <summary>
            External API
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="perProducerBufferSize">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="perProducerBufferSize"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Streams.Dsl.MergeHub`1.DemandThreshold">
            <summary>
            Half of buffer size, rounded up
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.MergeHub`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.MergeHub`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.MergeHub`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.BroadcastHub">
            <summary>
            A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers.
            It consists of two parts, a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and a <see cref="T:Akka.Streams.Dsl.Source`2"/>. The <see cref="T:Akka.Streams.Dsl.Sink`2"/> broadcasts elements from a producer to the
            actually live consumers it has. Once the producer has been materialized, the <see cref="T:Akka.Streams.Dsl.Sink`2"/> it feeds into returns a
            materialized value which is the corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>. This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized arbitrary many times,
            where each of the new materializations will receive their elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub.Sink``1(System.Int32)">
             <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that receives elements from its upstream producer and broadcasts them to a dynamic set
             of consumers. After the <see cref="T:Akka.Streams.Dsl.Sink`2"/> returned by this method is materialized, it returns a <see cref="T:Akka.Streams.Dsl.Source`2"/> as materialized
             value. This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized arbitrary many times and each materialization will receive the
             broadcast elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
             Every new materialization of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> results in a new, independent hub, which materializes to its own
             <see cref="T:Akka.Streams.Dsl.Source`2"/> for consuming the <see cref="T:Akka.Streams.Dsl.Sink`2"/> of that materialization.
            
             If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is failed, then the failure is immediately propagated to all of its materialized
             <see cref="T:Akka.Streams.Dsl.Source`2"/>s (possibly jumping over already buffered elements). If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is completed, then
             all corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>s are completed. Both failure and normal completion is "remembered" and later
             materializations of the <see cref="T:Akka.Streams.Dsl.Source`2"/> will see the same (failure or completion) state. <see cref="T:Akka.Streams.Dsl.Source`2"/>s that are
             cancelled are simply removed from the dynamic set of consumers.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <param name="bufferSize">
             Buffer size used by the producer. Gives an upper bound on how "far" from each other two
             concurrent consumers can be in terms of element. If this buffer is full, the producer
             is backpressured. Must be a power of two and less than 4096.
             </param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub.Sink``1">
             <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that receives elements from its upstream producer and broadcasts them to a dynamic set
             of consumers. After the <see cref="T:Akka.Streams.Dsl.Sink`2"/> returned by this method is materialized, it returns a <see cref="T:Akka.Streams.Dsl.Source`2"/> as materialized
             value. This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized arbitrary many times and each materialization will receive the
             broadcast elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
             Every new materialization of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> results in a new, independent hub, which materializes to its own
             <see cref="T:Akka.Streams.Dsl.Source`2"/> for consuming the <see cref="T:Akka.Streams.Dsl.Sink`2"/> of that materialization.
            
             If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is failed, then the failure is immediately propagated to all of its materialized
             <see cref="T:Akka.Streams.Dsl.Source`2"/>s (possibly jumping over already buffered elements). If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is completed, then
             all corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>s are completed. Both failure and normal completion is "remembered" and later
             materializations of the <see cref="T:Akka.Streams.Dsl.Source`2"/> will see the same (failure or completion) state. <see cref="T:Akka.Streams.Dsl.Source`2"/>s that are
             cancelled are simply removed from the dynamic set of consumers.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.BroadcastHub`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.HubLogic.FindAndRemoveConsumer(System.Int64,System.Int32)">
            <summary>
            This method removes a consumer with a given ID from the known offset and returns it.
            NB: You cannot remove a consumer without knowing its last offset! Consumers on the Source side always must
            track this so this can be a fast operation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.HubLogic.CheckUnblock(System.Int32)">
            <summary>
            After removing a Consumer from a wheel slot (because it cancelled, or we moved it because it advanced)
            we need to check if it was blocking us from advancing (being the slowest)
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.HubLogic.WakeupIndex(System.Int32)">
            <summary>
            Send a wakeup signal to all the Consumers at a certain wheel index. Note, this needs the actual index,
            which is offset modulo (bufferSize + 1).
            </summary>
            <param name="index">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.HubLogic.Poll(System.Int32)">
            <summary>
            Consumer API
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="bufferSize">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="bufferSize"/>
            is less than or equal to zero, is greater than 4095, or is not a power of two.
            </exception>
        </member>
        <member name="P:Akka.Streams.Dsl.BroadcastHub`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BroadcastHub`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.PartitionHub">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.PartitionHub"/> is a special streaming hub that is able to route streamed elements to a dynamic set of consumers.
            It consists of two parts, a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and a <see cref="T:Akka.Streams.Dsl.Source`2"/>. The <see cref="T:Akka.Streams.Dsl.Sink`2"/> e elements from a producer to the
            actually live consumers it has.The selection of consumer is done with a function. Each element can be routed to
            only one consumer.Once the producer has been materialized, the <see cref="T:Akka.Streams.Dsl.Sink`2"/> it feeds into returns a
            materialized value which is the corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>. This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized an arbitrary number
            of times, where each of the new materializations will receive their elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionHub.StatefulSink``1(System.Func{System.Func{Akka.Streams.Dsl.PartitionHub.IConsumerInfo,``0,System.Int64}},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that receives elements from its upstream producer and routes them to a dynamic set
            of consumers.After the <see cref="T:Akka.Streams.Dsl.Sink`2"/> returned by this method is materialized, it returns a 
            <see cref="T:Akka.Streams.Dsl.Source`2"/> as materialized  value.
            This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized an arbitrary number of times and each materialization will receive the
            elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            <para/>
            Every new materialization of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> results in a new, independent hub, which materializes to its own
            <see cref="T:Akka.Streams.Dsl.Source`2"/> for consuming the <see cref="T:Akka.Streams.Dsl.Sink`2"/> of that materialization.
            <para/>
            If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is failed, then the failure is immediately propagated to all of its materialized
            <see cref="T:Akka.Streams.Dsl.Source`2"/>s (possibly jumping over already buffered elements). If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is completed, then
            all corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>s are completed.Both failure and normal completion is "remembered" and later
            materializations of the <see cref="T:Akka.Streams.Dsl.Source`2"/> will see the same (failure or completion) state. <see cref="T:Akka.Streams.Dsl.Source`2"/>s that are
            cancelled are simply removed from the dynamic set of consumers.
            <para/>
            This <see cref="M:Akka.Streams.Dsl.PartitionHub.StatefulSink``1(System.Func{System.Func{Akka.Streams.Dsl.PartitionHub.IConsumerInfo,``0,System.Int64}},System.Int32,System.Int32)"/> should be used when there is a need to keep mutable state in the partition function,
            e.g. for implemening round-robin or sticky session kind of routing. If state is not needed the <see cref="M:Akka.Streams.Dsl.PartitionHub.Sink``1(System.Func{System.Int32,``0,System.Int32},System.Int32,System.Int32)"/> can
            be more convenient to use.
            </summary>
            <param name="partitioner">
            Function that decides where to route an element.It is a factory of a function to
            to be able to hold stateful variables that are unique for each materialization.The function
            takes two parameters; the first is information about active consumers, including an array of consumer
            identifiers and the second is the stream element.The function should return the selected consumer
            identifier for the given element.The function will never be called when there are no active consumers,
            i.e.there is always at least one element in the array of identifiers.
            </param>
            <param name="startAfterNrOfConsumers">
            Elements are buffered until this number of consumers have been connected.
            This is only used initially when the stage is starting up, i.e.it is not honored when consumers have been removed (canceled).
            </param>
            <param name="bufferSize">Total number of elements that can be buffered. If this buffer is full, the producer is backpressured.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionHub.Sink``1(System.Func{System.Int32,``0,System.Int32},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that receives elements from its upstream producer and routes them to a dynamic set
            of consumers.After the <see cref="T:Akka.Streams.Dsl.Sink`2"/> returned by this method is materialized, it returns a 
            <see cref="T:Akka.Streams.Dsl.Source`2"/> as materialized  value.
            This <see cref="T:Akka.Streams.Dsl.Source`2"/> can be materialized an arbitrary number of times and each materialization will receive the
            elements from the original <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            <para/>
            Every new materialization of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> results in a new, independent hub, which materializes to its own
            <see cref="T:Akka.Streams.Dsl.Source`2"/> for consuming the <see cref="T:Akka.Streams.Dsl.Sink`2"/> of that materialization.
            <para/>
            If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is failed, then the failure is immediately propagated to all of its materialized
            <see cref="T:Akka.Streams.Dsl.Source`2"/>s (possibly jumping over already buffered elements). If the original <see cref="T:Akka.Streams.Dsl.Sink`2"/> is completed, then
            all corresponding <see cref="T:Akka.Streams.Dsl.Source`2"/>s are completed.Both failure and normal completion is "remembered" and later
            materializations of the <see cref="T:Akka.Streams.Dsl.Source`2"/> will see the same (failure or completion) state. <see cref="T:Akka.Streams.Dsl.Source`2"/>s that are
            cancelled are simply removed from the dynamic set of consumers.
            <para/>
            This <see cref="M:Akka.Streams.Dsl.PartitionHub.Sink``1(System.Func{System.Int32,``0,System.Int32},System.Int32,System.Int32)"/> should be used when the routing function is stateless, e.g. based on a hashed value of the
            elements. Otherwise the <see cref="M:Akka.Streams.Dsl.PartitionHub.StatefulSink``1(System.Func{System.Func{Akka.Streams.Dsl.PartitionHub.IConsumerInfo,``0,System.Int64}},System.Int32,System.Int32)"/> can be used to implement more advanced routing logic.
            </summary>
            <param name="partitioner">
            Function that decides where to route an element. The function takes two parameters;
            the first is the number of active consumers and the second is the stream element. The function should
            return the index of the selected consumer for the given element, i.e. int greater than or equal to 0
            and less than number of consumers. E.g. `(size, elem) => math.abs(elem.hashCode) % size`.
            </param>
            <param name="startAfterNrOfConsumers">
            Elements are buffered until this number of consumers have been connected.
            This is only used initially when the stage is starting up, i.e.it is not honored when consumers have been removed (canceled).
            </param>
            <param name="bufferSize">Total number of elements that can be buffered. If this buffer is full, the producer is backpressured.</param>
        </member>
        <member name="T:Akka.Streams.Dsl.PartitionHub.IConsumerInfo">
            <summary>
            DO NOT INHERIT
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.PartitionHub.IConsumerInfo.ConsumerIds">
            <summary>
            Sequence of all identifiers of current consumers.
            
            Use this method only if you need to enumerate consumer existing ids.
            When selecting a specific consumerId by its index, prefer using the dedicated <see cref="M:Akka.Streams.Dsl.PartitionHub.IConsumerInfo.ConsumerByIndex(System.Int32)"/> method instead,
            which is optimised for this use case.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionHub.IConsumerInfo.ConsumerByIndex(System.Int32)">
            <summary>
            Obtain consumer identifier by index 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionHub.IConsumerInfo.QueueSize(System.Int64)">
            <summary>
            Approximate number of buffered elements for a consumer.
            Larger value than other consumers could be an indication of that the consumer is slow.
            <para/>
            Note that this is a moving target since the elements are consumed concurrently.
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.PartitionHub.IConsumerInfo.Size">
            <summary>
            Number of attached consumers.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.PartitionHub`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.GraphImpl`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.#ctor(`0,Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.Internal.GraphImpl`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Internal.GraphImpl`2.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.Named(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.Async">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.GraphImpl`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.ModuleExtractor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.ModuleExtractor.Unapply``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.InternalFlowOperations">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Identity``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AndThen``3(Akka.Streams.Dsl.IFlow{``1,``2},Akka.Streams.Implementation.Stages.SymbolicStage{``1,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="op">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Recover``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para/>
            Throwing an exception inside Recover will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="partialFunc"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception pf can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.RecoverWith``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWith will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.RecoverWithRetries``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}},System.Int32)">
            <summary>
            RecoverWithRetries allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered up to <paramref name="attempts"/> number of times so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized. Note that if you pass in 0, this won't attempt to recover at all. Passing in -1 will behave exactly the same as  <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.RecoverWith``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})"/>.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWithRetries will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">Receives the failure cause and returns the new Source to be materialized if any</param>
            <param name="attempts">Maximum number of retries or -1 to retry indefinitely</param>
            <exception cref="T:System.ArgumentException">if <paramref name="attempts"/> is a negative number other than -1</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectError``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,System.Exception})">
            <summary>
            While similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Recover``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})"/> this stage can be used to transform an error signal to a different one without logging
            it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e => throw e2) since Recover
            would log the e2 error. 
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Similarily to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Recover``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})"/> throwing an exception inside SelectError will be logged.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="selector"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception returned by the <paramref name="selector"/>
            </para>
            Cancels when downstream cancels 
            </summary>
            <param name="flow">TBD</param>
            <param name="selector">Receives the failure cause and returns the new cause, return the original exception if no other should be applied</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Select``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given <paramref name="mapper"/> function to each of the elements
            as they pass through this processing step.
            <para>
            Emits when the mapping function <paramref name="mapper"/> returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            Emits when the mapping function <paramref name="mapConcater"/> returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcater">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.StatefulSelectMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Transform each input element into an Enumerable of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function <paramref name="mapConcaterFactory"/> a new for every materialization —
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>.
            
            The returned Enumerable MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            Emits when the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcaterFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task`1"/> and the
            value of that task will be emitted downstream. The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>.
            These tasks may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when the task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream
            backpressures or the first task is not completed
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectAsyncUnordered``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectAsyncUnordered``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that task will be emitted downstreams. As many tasks as requested elements by
            downstream may run in parallel and each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when any of the tasks returned by the provided function complete
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SelectAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Where``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.WhereNot``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that NOT satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0},System.Boolean)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after <paramref name="predicate"/>
            returns false for the first time, including the first failed element iff inclusive is true
            Due to input buffering some elements may have been requested from upstream publishers
            that will then not be processed downstream of this step.
            
            The stream will be completed without producing any elements if <paramref name="predicate"/> is false for
            the first stream element.
            <para>
            Emits when the <paramref name="predicate"/> is true
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when <paramref name="predicate"/> returned false (or 1 after predicate returns false if <paramref name="inclusive"/>) or upstream completes
            </para>
            <para>
            Cancels when <paramref name="predicate"/> returned false or downstream cancels
            </para>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Limit``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.LimitWeighted``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64,System.Func{``0,System.Int64})"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <param name="inclusive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SkipWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Discard elements at the beginning of the stream while <paramref name="predicate"/> is true.
            All elements will be taken after <paramref name="predicate"/> returns false first time.
            <para>
            Emits when <paramref name="predicate"/> returned false and for all following stream elements
            </para>
            Backpressures when <paramref name="predicate"/> returned false and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Collect``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given function <paramref name="collector"/> to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            Emits when the provided function <paramref name="collector"/> is defined for the element
            </para>
            Backpressures when the function <paramref name="collector"/> is defined for the element and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="collector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Grouped``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the specified number of elements has been accumulated or upstream completed
            </para>
            Backpressures when a group has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Limit``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.LimitWeighted``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64,System.Func{``0,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Sliding``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            Emits when enough elements have been collected within the window or upstream completed
            </para>
            Backpressures when a window has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="step">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Scan``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Aggregate``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when the function scanning the element returns a new element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ScanAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Scan``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but with a asynchronous function,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>
            emitting a <see cref="T:System.Threading.Tasks.Task`1"/> that resolves to the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> current value starts at the previous
            current value, or zero when it doesn't have one, and the stream will continue.
            <para>
            Emits the <see cref="T:System.Threading.Tasks.Task`1"/> returned by <paramref name="scan"/> completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes upstream completes and the last task returned by <paramref name="scan"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Aggregate``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Scan``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but only emits its result when the upstream completes,
            after which it also completes. Applies the given function <paramref name="fold"/> towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AggregateAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Aggregate``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but with an asynchronous function.
            Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> returns a failure and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Aggregate``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Sum``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Aggregate``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but uses first element as zero element.
            Applies the given function <paramref name="reduce"/> towards its current and next value,
            yielding the next current value. 
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="reduce">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Intersperse``2(Akka.Streams.Dsl.IFlow{``0,``1},``0,``0,``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="start"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="start">TBD</param>
            <param name="inject">TBD</param>
            <param name="end">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Intersperse``2(Akka.Streams.Dsl.IFlow{``0,``1},``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="inject"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is undefined.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupedWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the configured time elapses since the last group has been emitted
            </para>
            Backpressures when the configured time elapses since the last group has been emitted
            <para>
            Completes when upstream completes (emits last group)
            </para>
            Cancels when downstream completes
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="timeout">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Delay``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            Emits when there is a pending element in the buffer and configured time for this element elapsed
             <para/> * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            Backpressures when depending on OverflowStrategy
             <para/> * Backpressure - backpressures when buffer is full
             <para/> * DropHead, DropTail, DropBuffer - never backpressures
             <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Skip``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            Emits when the specified number of elements has been dropped already
            </para>
            Backpressures when the specified number of elements has been dropped and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SkipWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            Emits when the specified time elapsed and a new upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            Emits when an upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or timer fires
            </para>
            Cancels when downstream cancels or timer fires
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Conflate``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TSeed">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Conflate``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Batch``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Emits when downstream stops backpressuring and there is an aggregated element available
            
             Backpressures when there are <paramref name="max"/> batched elements and 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.BatchWeighted``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.BatchWeighted``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate <see cref="T:Akka.IO.ByteString"/>
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the <paramref name="seed"/> function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             Emits when downstream stops backpressuring and there is a batched element available
            
             Backpressures when there are <paramref name="max"/> weighted batched elements + 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Batch``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Expand``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerator{``1}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="extrapolate"/> function will complete the stream with failure.
            <para>
            Emits when downstream stops backpressuring
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Buffer``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            Emits when downstream stops backpressuring and there is a pending element in the buffer
            </para>
            Backpressures when depending on OverflowStrategy
            <para/> * Backpressure - backpressures when buffer is full
            <para/> * DropHead, DropTail, DropBuffer - never backpressures
            <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Transform``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{Akka.Streams.Stage.IStage{``0,``1}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="stageFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.PrefixAndTail``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            Emits when the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            Backpressures when downstream backpressures or substream backpressures
            <para>
            Completes when prefix elements has been consumed and substream has been consumed
            </para>
            Cancels when downstream cancels or substream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupBy``4(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.Func{``0,``2},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``3})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            
            Function <paramref name="groupingFunc"/>  MUST NOT return null. This will throw exception and trigger supervision decision mechanism.
            <para>
            Emits when an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            Backpressures when there is an element pending for a group whose substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and all substreams cancel
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="maxSubstreams">TBD</param>
            <param name="groupingFunc">TBD</param>
            <param name="toFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupByMergeBack`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupByMergeBack`3.#ctor(Akka.Streams.Dsl.IFlow{`0,`1},System.Int32,System.Func{`0,`2})">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="maxSubstreams">TBD</param>
            <param name="groupingFunc">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupByMergeBack`3.Apply``1(Akka.Streams.Dsl.Flow{`0,``0,`1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhen``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the * first * element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal <see cref="T:Akka.Streams.Dsl.Source`2"/> or <see cref="T:Akka.Streams.Dsl.Flow`3"/>,
            it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>)
            or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and 
            <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
            on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhen``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})"/>
            operator itself—and thereby all substreams—once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            Emits when an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            Backpressures when there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfter``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
            <param name="predicate">TBD</param>
            <param name="toFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhenMergeBack`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhenMergeBack`2.#ctor(Akka.Streams.Dsl.IFlow{`0,`1},System.Func{`0,System.Boolean},Akka.Streams.SubstreamCancelStrategy)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="predicate">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhenMergeBack`2.Apply``1(Akka.Streams.Dsl.Flow{`0,``0,`1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfter``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It * ends * the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal [[Source]] or[[Flow]],
             it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion.Substream mode
             is exited either by closing the substream(i.e.connecting it to a [[Sink]])
             or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
             on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfter``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})"/>
             operator itself—and thereby all substreams—once all internal or
             explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             Emits when an element passes through.When the provided predicate is true it emitts the element
             and opens a new substream for subsequent element
             </para>
             Backpressures when there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             Completes when upstream completes
             </para>
             Cancels when downstream cancels and substreams cancel
             </summary>
             <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhen``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Threading.Tasks.Task},``2})"/>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="substreamCancelStrategy">TBD</param>
             <param name="predicate">TBD</param>
             <param name="toFunc">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfterMergeBack`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfterMergeBack`2.#ctor(Akka.Streams.Dsl.IFlow{`0,`1},System.Func{`0,System.Boolean},Akka.Streams.SubstreamCancelStrategy)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="predicate">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfterMergeBack`2.Apply``1(Akka.Streams.Dsl.Flow{`0,``0,`1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConcatMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeMany``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InitialTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before first element arrives
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.CompletionTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.IdleTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>. 
            The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between two emitted elements
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.BackpressureTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
            the stream is failed with a <see cref="T:System.TimeoutException"/>. The timeout is checked periodically,
            so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between element emission and downstream demand.
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.KeepAlive``3(Akka.Streams.Dsl.IFlow{``0,``2},System.TimeSpan,System.Func{``1})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            Emits when upstream emits an element or if the upstream was idle for the configured period
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <param name="injectElement">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Throttle``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="elements"/>/<paramref name="per"/>. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="elements">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="mode">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when one of the following conditions is met.
            <ul>
            <li>The specified <paramref name="elements"/> is less than or equal to zero</li>
            <li>The specified <paramref name="per"/> timeout is equal to <see cref="F:System.TimeSpan.Zero"/>.</li>
            <li>The specified <paramref name="maximumBurst"/> is less than or equal zero in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</li>
            <li>The <see cref="P:System.TimeSpan.Ticks"/> in the specified <paramref name="per"/> is less than the specified <paramref name="elements"/>.</li>
            </ul>
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Throttle``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan,System.Int32,System.Func{``0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be spared for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="cost">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="calculateCost">TBD</param>
            <param name="mode">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when one of the following conditions is met.
            <ul>
            <li>The specified <paramref name="cost"/> is less than or equal to zero</li>
            <li>The specified <paramref name="per"/> timeout is equal to <see cref="F:System.TimeSpan.Zero"/>.</li>
            <li>The specified <paramref name="maximumBurst"/> is less than or equal zero in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</li>
            <li>The <see cref="P:System.TimeSpan.Ticks"/> in the specified <paramref name="per"/> is less than the specified <paramref name="cost"/>.</li>
            </ul>
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Detach``2(Akka.Streams.Dsl.IFlow{``0,``1})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             Emits when upstream emits an element
            
             Backpressures when downstream backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InitialDelay``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            Emits when upstream emits an element if the initial delay is already elapsed
            </para>
            Backpressures when downstream backpressures or initial delay is not yet elapsed
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="delay">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Log``2(Akka.Streams.Dsl.IFlow{``0,``1},System.String,System.Func{``0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            Emits when the mapping function returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="name">TBD</param>
            <param name="extract">TBD</param>
            <param name="log">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Zip``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Combine the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/> into a stream of tuples.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ZipWith``4(Akka.Streams.Dsl.IFlow{``0,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``0,``1,``2})">
            <summary>
            Put together the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/>
            into a stream of combined elements using a combiner function.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ZipWithIndex``2(Akka.Streams.Dsl.IFlow{``0,``1})">
            <summary>
            Combine the elements of current flow into a stream of tuples consisting
            of all elements paired with their index. Indices start at 0.
            
            <para/>
            Emits when upstream emits an element and is paired with their index
            <para/>
            Backpressures when downstream backpressures
            <para/>
            Completes when upstream completes
            <para/>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Interleave``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            Emits when element is available from the currently consumed upstream
            </para>
            Backpressures when downstream backpressures. Signal to current
            upstream, switch to next upstream when received <paramref name="segmentSize"/> elements
            <para>
            Completes when the <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="graph">TBD</param>
            <param name="segmentSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InterleaveMaterialized``5(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Int32,System.Func{``2,``3,``4})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/> source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="T1">TBD</typeparam>
             <typeparam name="T2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="graph">TBD</param>
             <param name="segmentSize">TBD</param>
             <param name="combine">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Merge``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="eagerComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeMaterialized``5(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Merge``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="combine">TBD</param>
            <param name="eagerComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Func{``0,``0,System.Int32})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="orderFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Concatenate the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that once this
            Flow’s input is exhausted and all result elements have been generated,
            the Source’s elements will be produced.
            
            Note that the <see cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> gets upstream error - no elements from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            <para>
            Emits when element is available from current stream or from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> when current is completed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConcatGraph``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Prepend``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
             <summary>
             Prepend the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that before elements
             are generated from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <see cref="T:Akka.Streams.Dsl.Source`2"/> gets upstream error - no elements from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be pulled.
            
             Emits when element is available from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> or from current stream when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is completed
            
             Backpressures when downstream backpressures
            
             Completes when this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.OrElse``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
             <summary>
             Provides a secondary source that will be consumed if this stream completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             Note that this Flow will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes or it gets
             cancelled.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                              is available from the second stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                                by from this stream.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.OrElseMaterialized``4(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``2},System.Func{``1,``2,``3})">
             <summary>
             Provides a secondary source that will be consumed if this stream completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             Note that this Flow will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes or it gets
             cancelled.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                              is available from the second stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                                by from this stream.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <param name="materializedFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoToMaterialized``4(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},System.Func{``1,``2,``3})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoTo``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoTo``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             Emits when element is available and demand exists both from the Sink and the downstream.
            
             Backpressures when downstream or Sink backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.WatchTermination``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``1,System.Threading.Tasks.Task,``2})">
            <summary>
             Materializes to <see cref="T:System.Threading.Tasks.Task`1"/> that completes on getting termination message.
             The task completes with success when received complete message from upstream or cancel
             from downstream. It fails with the same error when received error message from
             downstream.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="materializerFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Monitor``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``1,Akka.Streams.IFlowMonitor,``2})">
            <summary>
            Materializes to <see cref="T:Akka.Streams.IFlowMonitor"/> that allows monitoring of the the current flow. All events are propagated
            by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
            event, and may therefor affect performance.
            The <paramref name="combine"/> function is used to combine the <see cref="T:Akka.Streams.IFlowMonitor"/> with this flow's materialized value.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Watch``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Actor.IActorRef)">
            <summary>
            The operator fails with an <see cref="T:Akka.Streams.WatchedActorTerminatedException"/> if the target actor is terminated.
            
            '''Emits when''' upstream emits 
            '''Backpressures when''' downstream backpressures 
            '''Completes when''' upstream completes 
            '''Fails when''' the watched actor terminates 
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IntervalBasedRateLimiter.Create``1(System.TimeSpan,System.Int32)">
            <summary>
            Specialized type of rate limiter which emits batches of elements (with size limited by the <paramref name="maxBatchSize"/> parameter)
            with a minimum time interval of <paramref name="minInterval"/>.
            <para />
            Because the next emit is scheduled after we downstream the current batch, the effective throughput,
            depending on the minimal interval length, may never reach the maximum allowed one.
            You can minimize these delays by sending bigger batches less often.
            </summary>
            <typeparam name="T">type of element</typeparam>
            <param name="minInterval">minimal pause to be kept before downstream the next batch. Should be >= 10 milliseconds.</param>
            <param name="maxBatchSize">maximum number of elements to send in the single batch</param>
            <returns></returns>
        </member>
        <member name="T:Akka.Streams.Dsl.JsonFraming">
            <summary>
            Provides JSON framing stages that can separate valid JSON objects from incoming <see cref="T:Akka.IO.ByteString"/> objects.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.JsonFraming.ObjectScanner(System.Int32)">
            <summary>
            Returns a Flow that implements a "brace counting" based framing stage for emitting valid JSON chunks.
            It scans the incoming data stream for valid JSON objects and returns chunks of ByteStrings containing only those valid chunks.
            
            Typical examples of data that one may want to frame using this stage include:
            
            <para>
            **Very large arrays**:
            {{{
                [{"id": 1}, {"id": 2}, [...], {"id": 999}]
            }}}
            </para>
             
            <para>
            **Multiple concatenated JSON objects** (with, or without commas between them):
            {{{
                {"id": 1}, {"id": 2}, [...], {"id": 999}
            }}}
            </para>
            
            The framing works independently of formatting, i.e. it will still emit valid JSON elements even if two
            elements are separated by multiple newlines or other whitespace characters. And of course is insensitive
            (and does not impact the emitting frame) to the JSON object's internal formatting.
            
            </summary>
            <param name="maximumObjectLength">The maximum length of allowed frames while decoding. If the maximum length is exceeded this Flow will fail the stream.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.JsonFraming.Scanner.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maximumObjectLength">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.JsonFraming.Scanner.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.JsonFraming.Scanner.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Keep">
            <summary>
            Convenience functions for often-encountered purposes like keeping only the
            left (first) or only the right (second) of two input values.
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TLeft">TBD</typeparam>
            <typeparam name="TRight">TBD</typeparam>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TLeft">TBD</typeparam>
            <typeparam name="TRight">TBD</typeparam>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.Both``2(``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TLeft">TBD</typeparam>
            <typeparam name="TRight">TBD</typeparam>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.None``2(``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TLeft">TBD</typeparam>
            <typeparam name="TRight">TBD</typeparam>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.IsRight``3(System.Func{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="fn">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Keep.IsLeft``3(System.Func{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="fn">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.KeepAliveConcat`1">
            <summary>
            Sends elements from buffer if upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream using elements from upstream.
            <para/>
            If upstream emits new elements until the accumulated elements in the buffer exceed the specified minimum size
            used as the keep alive elements, then the base rate is no longer maintained until we reach another period without
            elements form upstream.
            <para/>
            The keep alive period is the keep alive failover size times the interval.
            <para>
            Emits when upstream emits an element or if the upstream was idle for the configured period
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="T:Akka.Streams.Dsl.LastElement`1">
            <summary>
            This stage materializes to the last element pushed before upstream completion, if any, thereby recovering from any
            failure. Pushed elements are just passed along.
            </summary>
            <typeparam name="T">input and output type</typeparam>
        </member>
        <member name="T:Akka.Streams.Dsl.One2OneBidiFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.One2OneBidiFlow.Apply``2(System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="maxPending">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.UnexpectedOutputException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.UnexpectedOutputException.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Dsl.OutputTruncationException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.One2OneBidi`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.One2OneBidi`2.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maxPending">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.One2OneBidi`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.One2OneBidi`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.One2OneBidi`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.One2OneBidi`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.PagedSource.Page`2">
            <summary>
            Page for <see cref="T:Akka.Streams.Dsl.PagedSource"/>.
            </summary>
            <typeparam name="T">type of page items</typeparam>
            <typeparam name="TKey">type of page keys</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.PagedSource.Create``2(``1,System.Func{``1,System.Threading.Tasks.Task{Akka.Streams.Dsl.PagedSource.Page{``0,``1}}})">
            <summary>
            Defines a factory for "paged source".
            <para>
            "Paged source" is a Source streaming items from a paged API.
            The paged API is accessed with a page key and returns data.
            This data contain items and optional information about the key of the next page.
            </para>
            </summary>
            <typeparam name="T">type of page items</typeparam>
            <typeparam name="TKey">type of page keys</typeparam>
            <param name="firstKey">key of first page</param>
            <param name="pageFactory">maps page key to Task of page data</param>
        </member>
        <member name="T:Akka.Streams.Dsl.PartitionWith`3">
            <summary>
            This stage partitions input to 2 different outlets,
            applying different transformations on the elements,
            according to the partition function.
            </summary>
            <typeparam name="TIn">input type</typeparam>
            <typeparam name="TOut0">left output type</typeparam>
            <typeparam name="TOut1">right output type</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.PartitionWith`3.#ctor(System.Func{`0,Akka.Util.Either{`1,`2}})">
            <param name="partitionWith">partition function</param>
        </member>
        <member name="T:Akka.Streams.Dsl.Pulse`1">
            <summary>
            Pulse stage signals demand only once every "pulse" interval and then back-pressures.
            Requested element is emitted downstream if there is demand.
            It can be used to implement simple time-window processing
            where data is aggregated for predefined amount of time and the computed aggregate is emitted once per this time.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Pulse`1.#ctor(System.TimeSpan,System.Boolean)">
            Creates Pulse stage
            <param name="interval">"pulse" period</param>
            <param name="initiallyOpen">if <code>true</code> - emits the first available element before "pulsing"</param>
        </member>
        <member name="T:Akka.Streams.Dsl.RestartSource">
            <summary>
            A RestartSource wraps a <see cref="T:Akka.Streams.Dsl.Source"/> that gets restarted when it completes or fails.
            They are useful for graphs that need to run for longer than the <see cref="T:Akka.Streams.Dsl.Source"/> can necessarily guarantee it will, for
            example, for <see cref="T:Akka.Streams.Dsl.Source"/> streams that depend on a remote server that may crash or become partitioned. The
            RestartSource ensures that the graph can continue running while the <see cref="T:Akka.Streams.Dsl.Source"/> restarts.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSource.WithBackoff``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Source"/> with a <see cref="T:Akka.Streams.Dsl.Source"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Source"/> will never emit a complete or failure, since the completion or failure of the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>
            is always handled by restarting it. The wrapped <see cref="T:Akka.Streams.Dsl.Source"/> can however be cancelled by cancelling this <see cref="T:Akka.Streams.Dsl.Source"/>.
            When that happens, the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>, if currently running will be cancelled, and it will not be restarted.
            This can be triggered simply by the downstream cancelling, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right
            after this <see cref="T:Akka.Streams.Dsl.Source"/> in the graph.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sourceFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Source"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSource.WithBackoff``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double,System.Int32)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Source"/> with a <see cref="T:Akka.Streams.Dsl.Source"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Source"/> will never emit a complete or failure, since the completion or failure of the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>
            is always handled by restarting it. The wrapped <see cref="T:Akka.Streams.Dsl.Source"/> can however be cancelled by cancelling this <see cref="T:Akka.Streams.Dsl.Source"/>.
            When that happens, the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>, if currently running will be cancelled, and it will not be restarted.
            This can be triggered simply by the downstream cancelling, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right
            after this <see cref="T:Akka.Streams.Dsl.Source"/> in the graph.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sourceFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Source"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="maxRestarts">The amount of restarts is capped to this amount within a time frame of minBackoff. Passing `0` will cause no restarts and a negative number will not cap the amount of restarts.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSource.OnFailuresWithBackoff``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Source"/> with a <see cref="T:Akka.Streams.Dsl.Source"/> that will restart it when it fails using an exponential backoff.
            This <see cref="T:Akka.Streams.Dsl.Source"/> will never emit a failure, since the failure of the wrapped <see cref="T:Akka.Streams.Dsl.Source"/> is always handled by
            restarting. The wrapped <see cref="T:Akka.Streams.Dsl.Source"/> can be cancelled by cancelling this <see cref="T:Akka.Streams.Dsl.Source"/>.
            When that happens, the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>, if currently running will be cancelled, and it will not be restarted.
            This can be triggered simply by the downstream cancelling, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right
            after this <see cref="T:Akka.Streams.Dsl.Source"/> in the graph.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sourceFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Source"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSource.OnFailuresWithBackoff``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double,System.Int32)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Source"/> with a <see cref="T:Akka.Streams.Dsl.Source"/> that will restart it when it fails using an exponential backoff.
            This <see cref="T:Akka.Streams.Dsl.Source"/> will never emit a failure, since the failure of the wrapped <see cref="T:Akka.Streams.Dsl.Source"/> is always handled by
            restarting. The wrapped <see cref="T:Akka.Streams.Dsl.Source"/> can be cancelled by cancelling this <see cref="T:Akka.Streams.Dsl.Source"/>.
            When that happens, the wrapped <see cref="T:Akka.Streams.Dsl.Source"/>, if currently running will be cancelled, and it will not be restarted.
            This can be triggered simply by the downstream cancelling, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right
            after this <see cref="T:Akka.Streams.Dsl.Source"/> in the graph.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sourceFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Source"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="maxRestarts">The amount of restarts is capped to this amount within a time frame of minBackoff. Passing `0` will cause no restarts and a negative number will not cap the amount of restarts.</param>
        </member>
        <member name="T:Akka.Streams.Dsl.RestartSink">
            <summary>
            A RestartSink wraps a <see cref="T:Akka.Streams.Dsl.Sink"/> that gets restarted when it completes or fails.
            They are useful for graphs that need to run for longer than the <see cref="T:Akka.Streams.Dsl.Sink"/> can necessarily guarantee it will, for
            example, for <see cref="T:Akka.Streams.Dsl.Sink"/> streams that depend on a remote server that may crash or become partitioned. The
            RestartSink ensures that the graph can continue running while the <see cref="T:Akka.Streams.Dsl.Sink"/> restarts.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSink.WithBackoff``2(System.Func{Akka.Streams.Dsl.Sink{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Sink"/> with a <see cref="T:Akka.Streams.Dsl.Sink"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Sink"/> will never cancel, since cancellation by the wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> is always handled by restarting it.
            The wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> can however be completed by feeding a completion or error into this <see cref="T:Akka.Streams.Dsl.Sink"/>. When that
            happens, the <see cref="T:Akka.Streams.Dsl.Sink"/>, if currently running, will terminate and will not be restarted. This can be triggered
            simply by the upstream completing, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right before this <see cref="T:Akka.Streams.Dsl.Sink"/> in the
            graph.
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. When the wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> does cancel, this <see cref="T:Akka.Streams.Dsl.Sink"/> will backpressure, however any elements already
            sent may have been lost.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sinkFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Sink"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartSink.WithBackoff``2(System.Func{Akka.Streams.Dsl.Sink{``0,``1}},System.TimeSpan,System.TimeSpan,System.Double,System.Int32)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Sink"/> with a <see cref="T:Akka.Streams.Dsl.Sink"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Sink"/> will never cancel, since cancellation by the wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> is always handled by restarting it.
            The wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> can however be completed by feeding a completion or error into this <see cref="T:Akka.Streams.Dsl.Sink"/>. When that
            happens, the <see cref="T:Akka.Streams.Dsl.Sink"/>, if currently running, will terminate and will not be restarted. This can be triggered
            simply by the upstream completing, or externally by introducing a <see cref="T:Akka.Streams.IKillSwitch"/> right before this <see cref="T:Akka.Streams.Dsl.Sink"/> in the
            graph.
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. When the wrapped <see cref="T:Akka.Streams.Dsl.Sink"/> does cancel, this <see cref="T:Akka.Streams.Dsl.Sink"/> will backpressure, however any elements already
            sent may have been lost.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="sinkFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Sink"/> to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="maxRestarts">The amount of restarts is capped to this amount within a time frame of minBackoff. Passing `0` will cause no restarts and a negative number will not cap the amount of restarts.</param>
        </member>
        <member name="T:Akka.Streams.Dsl.RestartFlow">
            <summary>
            A RestartFlow wraps a <see cref="T:Akka.Streams.Dsl.Flow"/> that gets restarted when it completes or fails.
            They are useful for graphs that need to run for longer than the <see cref="T:Akka.Streams.Dsl.Flow"/> can necessarily guarantee it will, for
            example, for <see cref="T:Akka.Streams.Dsl.Flow"/> streams that depend on a remote server that may crash or become partitioned. The
            RestartFlow ensures that the graph can continue running while the <see cref="T:Akka.Streams.Dsl.Flow"/> restarts.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartFlow.WithBackoff``3(System.Func{Akka.Streams.Dsl.Flow{``0,``1,``2}},System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Flow"/> with a <see cref="T:Akka.Streams.Dsl.Flow"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Flow"/> will not cancel, complete or emit a failure, until the opposite end of it has been cancelled or
            completed.Any termination by the <see cref="T:Akka.Streams.Dsl.Flow"/> before that time will be handled by restarting it. Any termination
            signals sent to this <see cref="T:Akka.Streams.Dsl.Flow"/> however will terminate the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/>, if it's running, and then the <see cref="T:Akka.Streams.Dsl.Flow"/>
            will be allowed to terminate without being restarted.
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. A termination signal from either end of the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will cause the other end to be terminated,
            and any in transit messages will be lost. During backoff, this <see cref="T:Akka.Streams.Dsl.Flow"/> will backpressure.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="flowFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Flow"/>] to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartFlow.WithBackoff``3(System.Func{Akka.Streams.Dsl.Flow{``0,``1,``2}},System.TimeSpan,System.TimeSpan,System.Double,System.Int32)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Flow"/> with a <see cref="T:Akka.Streams.Dsl.Flow"/> that will restart it when it fails or complete using an exponential
            backoff.
            This <see cref="T:Akka.Streams.Dsl.Flow"/> will not cancel, complete or emit a failure, until the opposite end of it has been cancelled or
            completed.Any termination by the <see cref="T:Akka.Streams.Dsl.Flow"/> before that time will be handled by restarting it. Any termination
            signals sent to this <see cref="T:Akka.Streams.Dsl.Flow"/> however will terminate the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/>, if it's running, and then the <see cref="T:Akka.Streams.Dsl.Flow"/>
            will be allowed to terminate without being restarted.
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. A termination signal from either end of the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will cause the other end to be terminated,
            and any in transit messages will be lost. During backoff, this <see cref="T:Akka.Streams.Dsl.Flow"/> will backpressure.
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="flowFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Flow"/>] to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="maxRestarts">The amount of restarts is capped to this amount within a time frame of minBackoff. Passing `0` will cause no restarts and a negative number will not cap the amount of restarts.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartFlow.OnFailuresWithBackoff``3(System.Func{Akka.Streams.Dsl.Flow{``0,``1,``2}},System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Flow"/> with a <see cref="T:Akka.Streams.Dsl.Flow"/> that will restart it when it fails using an exponential
            backoff. Notice that this <see cref="T:Akka.Streams.Dsl.Flow"/> will not restart on completion of the wrapped flow. 
            This <see cref="T:Akka.Streams.Dsl.Flow"/> will not emit any failure
            The failures by the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will be handled by
            restarting the wrapping <see cref="T:Akka.Streams.Dsl.Flow"/> as long as maxRestarts is not reached.
            Any termination signals sent to this <see cref="T:Akka.Streams.Dsl.Flow"/> however will terminate the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/>, if it's
            running, and then the <see cref="T:Akka.Streams.Dsl.Flow"/> will be allowed to terminate without being restarted. 
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. A termination signal from either end of the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will cause the other end to be terminated,
            nd any in transit messages will be lost. During backoff, this <see cref="T:Akka.Streams.Dsl.Flow"/> will backpressure. 
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="flowFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Flow"/>] to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.RestartFlow.OnFailuresWithBackoff``3(System.Func{Akka.Streams.Dsl.Flow{``0,``1,``2}},System.TimeSpan,System.TimeSpan,System.Double,System.Int32)">
            <summary>
            Wrap the given <see cref="T:Akka.Streams.Dsl.Flow"/> with a <see cref="T:Akka.Streams.Dsl.Flow"/> that will restart it when it fails using an exponential
            backoff. Notice that this <see cref="T:Akka.Streams.Dsl.Flow"/> will not restart on completion of the wrapped flow. 
            This <see cref="T:Akka.Streams.Dsl.Flow"/> will not emit any failure
            The failures by the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will be handled by
            restarting the wrapping <see cref="T:Akka.Streams.Dsl.Flow"/> as long as maxRestarts is not reached.
            Any termination signals sent to this <see cref="T:Akka.Streams.Dsl.Flow"/> however will terminate the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/>, if it's
            running, and then the <see cref="T:Akka.Streams.Dsl.Flow"/> will be allowed to terminate without being restarted. 
            The restart process is inherently lossy, since there is no coordination between cancelling and the sending of
            messages. A termination signal from either end of the wrapped <see cref="T:Akka.Streams.Dsl.Flow"/> will cause the other end to be terminated,
            nd any in transit messages will be lost. During backoff, this <see cref="T:Akka.Streams.Dsl.Flow"/> will backpressure. 
            This uses the same exponential backoff algorithm as <see cref="T:Akka.Pattern.Backoff"/>.
            </summary>
            <param name="flowFactory">A factory for producing the <see cref="T:Akka.Streams.Dsl.Flow"/>] to wrap.</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="maxRestarts">The amount of restarts is capped to this amount within a time frame of minBackoff. Passing `0` will cause no restarts and a negative number will not cap the amount of restarts.</param>
        </member>
        <member name="T:Akka.Streams.Dsl.RestartWithBackoffLogic`3">
            <summary>
            Shared logic for all restart with backoff logics.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Retry.Create``4(Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{``0,``1},System.ValueTuple{Akka.Util.Result{``2},``1}},``3},System.Func{``1,Akka.Util.Option{System.ValueTuple{``0,``1}}})">
            <summary>
            EXPERIMENTAL API
            <para>
            Retry flow factory. given a flow that produces <see cref="T:Akka.Util.Result`1"/>s, this wrapping flow may be used to try
            and pass failed elements through the flow again. More accurately, the given flow consumes a tuple
            of `input` and `state`, and produces a tuple of <see cref="T:Akka.Util.Result`1"/> of `output` and `state`.
            If the flow emits a failed element (i.e. <see cref="F:Akka.Util.Result`1.IsSuccess"/> is false), the <paramref name="retryWith"/>
            function is fed with the `state` of the failed element, and may produce a new input-state tuple to pass through
            the original flow. The function may also yield `Option.None` instead of `(input, state)`, which means not to retry a failed element.
            </para>
            <para>
            IMPORTANT CAVEAT:
            The given flow must not change the number of elements passing through it (i.e. it should output
            exactly one element for every received element). Ignoring this, will have an unpredicted result,
            and may result in a deadlock.
            </para> 
            </summary>
            <param name="flow">the flow to retry</param>
            <param name="retryWith">if output was failure, we can optionaly recover from it,
            and retry with a new pair of input and new state we get from this function.</param>
            <typeparam name="TIn">input elements type</typeparam>
            <typeparam name="TState">state to create a new `(I,S)` to retry with</typeparam>
            <typeparam name="TOut">output elements type</typeparam>
            <typeparam name="TMat">materialized value type</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Retry.Concat``4(System.Int64,Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{``0,``1},System.ValueTuple{Akka.Util.Result{``2},``1}},``3},System.Func{``1,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}}})">
            <summary>
            EXPERIMENTAL API
            <para>
            Factory for multiple retries flow. similar to the simple retry, but this will allow to
            break down a "heavy" element which failed into multiple "thin" elements, that may succeed individually.
            Since it's easy to inflate elements in retry cycle, there's also a limit parameter, that will limit the
            amount of generated elements by the `retryWith` function, and will fail the stage if that limit is exceeded.
            </para>
            <para>
            Passing `null` is valid, and will result in filtering out the failure quietly, without
            emitting a failed <see cref="T:Akka.Util.Result`1"/> element.
            </para>
            <para>
            IMPORTANT CAVEAT:
            The given flow must not change the number of elements passing through it (i.e. it should output
                exactly one element for every received element). Ignoring this, will have an unpredicted result,
            and may result in a deadlock.
            </para>
            </summary>
            <param name="limit">since every retry can generate more elements, the inner queue can get too big.
            if the limit is reached, the stage will fail.</param>
            <param name="flow">the flow to retry</param>
            <param name="retryWith">if output was failure, we can optionaly recover from it, and retry with
            a sequence of input and new state pairs we get from this function.</param>
            <typeparam name="TIn">input elements type</typeparam>
            <typeparam name="TState">state to create a new `(I,S)` to retry with</typeparam>
            <typeparam name="TOut">output elements type</typeparam>
            <typeparam name="TMat">materialized value type</typeparam>
        </member>
        <member name="T:Akka.Streams.Dsl.IRunnableGraph`1">
            <summary>
            Flow with attached input and output, can be executed.
            </summary>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.MapMaterializedValue``1(System.Func{`0,``0})">
            <summary>
            Transform only the materialized value of this RunnableGraph, leaving all other properties as they were.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="func">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.Run(Akka.Streams.IMaterializer)">
            <summary>
            Run this flow and return the materialized instance from the flow.
            </summary>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.IGraph`1"/> to the given ones
            and seal the list of attributes. This means that further calls will not be able
            to remove these attributes, but instead add new ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.IRunnableGraph`1.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.Named(System.String)">
            <summary>
            Add a name attribute to this Graph.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.RunnableGraph`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.RunnableGraph`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.RunnableGraph`1.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.Named(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.Async">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.MapMaterializedValue``1(System.Func{`0,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="func">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph`1.Run(Akka.Streams.IMaterializer)">
            <summary>
            TBD
            </summary>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.RunnableGraph">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph.FromGraph``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            A graph with a closed shape is logically a runnable graph, this method makes
            it so also in type.
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="g">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Sample`1">
            <summary>
            Supports sampling on stream
            </summary>
            <typeparam name="T">input and output type</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Sample`1.Random(System.Int32)">
            <summary>
            Randomly sampling on a stream
            </summary>
            <param name="maxStep">must > 0, default 1000, the randomly step will be between 1 (inclusive) and <paramref name="maxStep"/> (inclusive)</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Sample`1.#ctor(System.Int32)">
            <summary>
            Returns every <paramref name="nth"/> element
            </summary>
            <param name="nth"><paramref name="nth"/> element. <paramref name="nth"/> must > 0</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Sample`1.#ctor(System.Func{System.Int32})">
            <param name="next">a lambda returns next sample position</param>
        </member>
        <member name="T:Akka.Streams.Dsl.Sink`2">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> is a set of stream processing steps that has one open input.
            Can be used as a <see cref="T:Reactive.Streams.ISubscriber`1"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.Sink`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Sink`2.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.ContraMap``1(System.Func{``0,`0})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Sink"/> by applying a function to each *incoming* upstream element before
            it is passed to the <see cref="T:Akka.Streams.Dsl.Sink"/>
            
            Backpressures when original <see cref="T:Akka.Streams.Dsl.Sink"/> backpressures
            
            Cancels when original <see cref="T:Akka.Streams.Dsl.Sink"/> backpressures
            </summary>
            <typeparam name="TIn2">TBD</typeparam>
            <param name="function">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Sink`2"/> to a <see cref="T:Akka.Streams.Dsl.Source`2"/> and run it. The returned value is the materialized value
            of the <see cref="T:Akka.Streams.Dsl.Source`2"/>, e.g. the <see cref="T:Reactive.Streams.ISubscriber`1"/>.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            Transform only the materialized value of this Sink, leaving all other properties as they were.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="fn">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.PreMaterialize(Akka.Streams.IMaterializer)">
            <summary>
            Materializes this Sink immediately.
            
            Useful for when you need a materialized value of a Sink when handing it out to someone to materialize it for you.
            </summary>
            <param name="materializer">The materializer.</param>
            <returns>A tuple containing the (1) materialized value and (2) a new <see cref="T:Akka.Streams.Dsl.Sink"/>
             that can be used to consume elements from the newly materialized <see cref="T:Akka.Streams.Dsl.Sink"/>.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Akka#Streams#IGraph{Akka#Streams#SinkShape{TIn},TMat}#WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.IGraph`1"/> to the given ones
            and seal the list of attributes. This means that further calls will not be able
            to remove these attributes, but instead add new ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Sink`2"/> to the given ones
            and seal the list of attributes. This means that further calls will not be able
            to remove these attributes, but instead add new ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Akka#Streams#IGraph{Akka#Streams#SinkShape{TIn},TMat}#AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Sink`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Sink`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Akka#Streams#IGraph{Akka#Streams#SinkShape{TIn},TMat}#Named(System.String)">
            <summary>
            Add a name attribute to this Sink.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Named(System.String)">
            <summary>
            Add a name attribute to this Sink.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Akka#Streams#IGraph{Akka#Streams#SinkShape{TIn},TMat}#Async">
            <summary>
            Put an asynchronous boundary around this Sink.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.Async">
            <summary>
            Put an asynchronous boundary around this Sink.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Sink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Shape``1(System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Wrap``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
            <summary>
            A graph with the shape of a sink logically is a sink, this method makes
            it so also in type.
            </summary> 
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Create``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Sink`2"/> from <see cref="T:Reactive.Streams.ISubscriber`1"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.First``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the first value received.
            If the stream completes before signaling at least a single element, the Task will be failed with a <see cref="T:Akka.Streams.NoSuchElementException"/>.
            If the stream signals an error before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FirstOrDefault``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the first value received.
            If the stream completes before signaling at least a single element, the Task will return default value.
            If the stream signals an error errors before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Last``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the last value received.
            If the stream completes before signaling at least a single element, the Task will be failed with a <see cref="T:Akka.Streams.NoSuchElementException"/>.
            If the stream signals an error, the Task will be failed with the stream's exception.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.LastOrDefault``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the last value received.
            If the stream completes before signaling at least a single element, the Task will be return a default value.
            If the stream signals an error, the Task will be failed with the stream's exception.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Seq``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that keeps on collecting incoming elements until upstream terminates.
            As upstream may be unbounded, `Flow.Create{T}().Take` or the stricter `Flow.Create{T}().Limit` (and their variants)
            may be used to ensure boundedness.
            Materializes into a <see cref="T:System.Threading.Tasks.Task"/> of <see cref="M:Akka.Streams.Dsl.Sink.Seq``1"/> containing all the collected elements.
            `Seq` is limited to <see cref="F:System.Int32.MaxValue"/> elements, this Sink will cancel the stream
            after having received that many elements.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Publisher``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:Reactive.Streams.IPublisher`1"/>.
            that can handle one <see cref="T:Reactive.Streams.ISubscriber`1"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FanoutPublisher``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into <see cref="T:Reactive.Streams.IPublisher`1"/>
            that can handle more than one <see cref="T:Reactive.Streams.ISubscriber`1"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Ignore``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will consume the stream and discard the elements.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ForEach``1(System.Action{``0})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="action"/> for each received element. 
            The sink is materialized into a <see cref="T:System.Threading.Tasks.Task"/> will be completed with success when reaching the
            normal end of the stream, or completed with a failure if there is a failure signaled in
            the stream..
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Combine``3(System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanOutShape{``0,``1},``2}},Akka.Streams.Dsl.Sink{``1,Akka.NotUsed},Akka.Streams.Dsl.Sink{``1,Akka.NotUsed},Akka.Streams.Dsl.Sink{``1,Akka.NotUsed}[])">
            <summary>
            Combine several sinks with fan-out strategy like <see cref="T:Akka.Streams.Dsl.Broadcast`1"/> or <see cref="T:Akka.Streams.Dsl.Balance`1"/> and returns <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="strategy">TBD</param>
            <param name="first">TBD</param>
            <param name="second">TBD</param>
            <param name="rest">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ForEachParallel``1(System.Int32,System.Action{``0})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="action"/> 
            to each of the elements as they pass in. The sink is materialized into a <see cref="T:System.Threading.Tasks.Task"/>.
            
            If the action throws an exception and the supervision decision is
            <see cref="F:Akka.Actor.Directive.Stop"/> the <see cref="T:System.Threading.Tasks.Task"/> will be completed with failure.
            
            If the action throws an exception and the supervision decision is
            <see cref="F:Akka.Actor.Directive.Resume"/> or <see cref="F:Akka.Actor.Directive.Restart"/> the
            element is dropped and the stream continues. 
            
             <para/>
            See also <seealso cref="T:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2"/> 
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="parallelism">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Aggregate``2(``1,System.Func{``1,``0,``1})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="aggregate"/> function for every received element, 
            giving it its previous output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with the streams exception
            if there is a failure signaled in the stream.
            <seealso cref="M:Akka.Streams.Dsl.Sink.AggregateAsync``2(``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.AggregateAsync``2(``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given asynchronous function for every received element,
            giving it its previous output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with "Failure"
            if there is a failure signaled in the stream.
            
            <seealso cref="M:Akka.Streams.Dsl.Sink.Aggregate``2(``1,System.Func{``1,``0,``1})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Sum``1(System.Func{``0,``0,``0})">
            <summary>
            <para>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="reduce"/> for every received element, giving it its previous
            output (from the second element) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with `Failure`
            if there is a failure signaled in the stream. 
            </para>
            <para>
            If the stream is empty (i.e. completes before signaling any elements),
            the sum stage will fail its downstream with a <see cref="T:Akka.Streams.NoSuchElementException"/>,
            which is semantically in-line with that standard library collections do in such situations.
            </para>
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="reduce">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.OnComplete``1(System.Action,System.Action{System.Exception})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that when the flow is completed, either through a failure or normal
            completion, apply the provided function with <paramref name="success"/> or <paramref name="failure"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="success">TBD</param>
            <param name="failure">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorRef``1(Akka.Actor.IActorRef,System.Object)">
            <summary>
             Sends the elements of the stream to the given <see cref="T:Akka.Actor.IActorRef"/>.
             If the target actor terminates the stream will be canceled.
             When the stream is completed successfully the given <paramref name="onCompleteMessage"/>
             will be sent to the destination actor.
             When the stream is completed with failure a <see cref="T:Akka.Actor.Status.Failure"/>
             message will be sent to the destination actor.
            
             It will request at most <see cref="F:Akka.Streams.ActorMaterializerSettings.MaxInputBufferSize"/> number of elements from
             upstream, but there is no back-pressure signal from the destination actor,
             i.e. if the actor is not consuming the messages fast enough the mailbox
             of the actor will grow. For potentially slow consumer actors it is recommended
             to use a bounded mailbox with zero <see cref="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.PushTimeOut"/> or use a rate
             limiting stage in front of this <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
             <typeparam name="TIn">TBD</typeparam>
             <param name="actorRef">TBD</param>
             <param name="onCompleteMessage">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorRefWithAck``1(Akka.Actor.IActorRef,System.Object,System.Object,System.Object,System.Func{System.Exception,System.Object})">
             <summary>
             Sends the elements of the stream to the given <see cref="T:Akka.Actor.IActorRef"/> that sends back back-pressure signal.
             First element is always <paramref name="onInitMessage"/>, then stream is waiting for acknowledgement message
             <paramref name="ackMessage"/> from the given actor which means that it is ready to process
             elements.It also requires <paramref name="ackMessage"/> message after each stream element
             to make backpressure work.
            
             If the target actor terminates the stream will be canceled.
             When the stream is completed successfully the given <paramref name="onCompleteMessage"/>
             will be sent to the destination actor.
             When the stream is completed with failure - result of <paramref name="onFailureMessage"/>
             function will be sent to the destination actor.
             </summary>
             <typeparam name="TIn">TBD</typeparam>
             <param name="actorRef">TBD</param>
             <param name="onInitMessage">TBD</param>
             <param name="ackMessage">TBD</param>
             <param name="onCompleteMessage">TBD</param>
             <param name="onFailureMessage">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorSubscriber``1(Akka.Actor.Props)">
            <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that is materialized to an <see cref="T:Akka.Actor.IActorRef"/> which points to an Actor
             created according to the passed in <see cref="T:Akka.Actor.Props"/>. Actor created by the <paramref name="props"/> should
             be <see cref="T:Akka.Streams.Implementation.ActorSubscriberSink`1"/>.
            </summary>
             <typeparam name="TIn">TBD</typeparam>
             <param name="props">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Queue``1">
            <summary>
             <para>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that is materialized as an <see cref="T:Akka.Streams.ISinkQueue`1"/>.
             <see cref="M:Akka.Streams.ISinkQueue`1.PullAsync"/> method is pulling element from the stream and returns <see cref="T:System.Threading.Tasks.Task`1"/>.
             <see cref="T:System.Threading.Tasks.Task"/> completes when element is available.
             </para>
             <para>
             Before calling the pull method a second time you need to wait until previous future completes.
             Pull returns failed future with <see cref="T:Akka.Pattern.IllegalStateException"/> if previous future has not yet completed.
             </para>
             <para>
             <see cref="T:Akka.Streams.Dsl.Sink`2"/> will request at most number of elements equal to size of inputBuffer from
             upstream and then stop back pressure. You can configure size of input by using WithAttributes method.
             </para>
             <para>
             For stream completion you need to pull all elements from <see cref="T:Akka.Streams.ISinkQueue`1"/> including last None
             as completion marker.
             </para>
            </summary>
             <typeparam name="TIn">TBD</typeparam>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.LazySink``2(System.Func{``0,System.Threading.Tasks.Task{Akka.Streams.Dsl.Sink{``0,``1}}},System.Func{``1})">
            <summary>
            <para>
            Creates a real <see cref="T:Akka.Streams.Dsl.Sink`2"/> upon receiving the first element. Internal <see cref="T:Akka.Streams.Dsl.Sink`2"/> will not be created if there are no elements,
            because of completion or error.
            </para>
            <para>
            If <paramref name="sinkFactory"/> throws an exception and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> 
            the <see cref="T:System.Threading.Tasks.Task"/> will be completed with failure. For all other supervision options it will try to create sink with next element.
            </para>
            <paramref name="fallback"/> will be executed when there was no elements and completed is received from upstream.
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="sinkFactory">TBD</param>
            <param name="fallback">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FromGraph``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
            <summary>
            A graph with the shape of a sink logically is a sink, this method makes
            it so also in type.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FromSubscriber``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Sink`2"/> from <see cref="T:Reactive.Streams.ISubscriber`1"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Cancelled``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that immediately cancels its upstream after materialization.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.AsPublisher``1(System.Boolean)">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:Reactive.Streams.IPublisher`1"/>.
            If <paramref name="fanout"/> is true, the materialized <see cref="T:Reactive.Streams.IPublisher`1"/> will support multiple <see cref="T:Reactive.Streams.ISubscriber`1"/>`s and
            the size of the <see cref="F:Akka.Streams.ActorMaterializerSettings.MaxInputBufferSize"/> configured for this stage becomes the maximum number of elements that
            the fastest <see cref="T:Reactive.Streams.ISubscriber`1"/> can be ahead of the slowest one before slowing
            the processing down due to back pressure.
            
            If <paramref name="fanout"/> is false then the materialized <see cref="T:Reactive.Streams.IPublisher`1"/> will only support a single <see cref="T:Reactive.Streams.ISubscriber`1"/> and
            reject any additional <see cref="T:Reactive.Streams.ISubscriber`1"/>`s.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <param name="fanout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.AsObservable``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.IObservable`1"/>. It supports multiple subscribers.
            Since observables have no notion of backpressure, it will push incoming elements as fast as possible, potentially risking
            process overrun.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Source`2">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Source`2"/> is a set of stream processing steps that has one open output. It can comprise
            any number of internal sources and transformations that are wired together, or it can be
            an "atomic" source, e.g. from a collection or a file. Materialization turns a Source into
            a Reactive Streams <see cref="T:Reactive.Streams.IPublisher`1"/> (at least conceptually).
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="P:Akka.Streams.Dsl.Source`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.Source`2.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>,
            concatenating the processing steps of both.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},System.Func{`1,``0,``1})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>,
            concatenating the processing steps of both.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ConcatMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},System.Func{`1,``0,``1})">
             <summary>
             Concatenate the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that once this
             Flow’s input is exhausted and all result elements have been generated,
             the Source’s elements will be produced.
            
             Note that the <see cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this Flow and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If this <see cref="T:Akka.Streams.Dsl.Flow`3"/> gets upstream error - no elements from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            
             @see <see cref="T:Akka.Streams.Dsl.Concat`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="that">TBD</param>
             <param name="materializedFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#IGraph{Akka#Streams#SourceShape{TOut},TMat}#WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Nests the current Source and returns a Source with the given Attributes
            </summary>
            <param name="attributes">The attributes to add</param>
            <returns>A new Source with the added attributes</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Nests the current Source and returns a Source with the given Attributes
            </summary>
            <param name="attributes">The attributes to add</param>
            <returns>A new Source with the added attributes</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#IGraph{Akka#Streams#SourceShape{TOut},TMat}#AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Source`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            Further calls to <see cref="M:Akka.Streams.Dsl.Source`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#IGraph{Akka#Streams#SourceShape{TOut},TMat}#Named(System.String)">
            <summary>
            Add a name attribute to this Source.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Named(System.String)">
            <summary>
            Add a name attribute to this Source.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#IGraph{Akka#Streams#SourceShape{TOut},TMat}#Async">
            <summary>
            Put an asynchronous boundary around this Source.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Async">
            <summary>
            Put an asynchronous boundary around this Source.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Ask``1(Akka.Actor.IActorRef,System.TimeSpan,System.Int32)">
            <summary>
            Use the `ask` pattern to send a request-reply message to the target <paramref name="actorRef"/>.
            If any of the asks times out it will fail the stream with a <see cref="T:Akka.Actor.AskTimeoutException"/>.
            
            Parallelism limits the number of how many asks can be "in flight" at the same time.
            Please note that the elements emitted by this operator are in-order with regards to the asks being issued
            (i.e. same behaviour as <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>).
            
            The operator fails with an <see cref="T:Akka.Streams.WatchedActorTerminatedException"/> if the target actor is terminated,
            or with an <see cref="T:System.TimeoutException"/> in case the ask exceeds the timeout passed in.
            
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            
            '''Emits when''' the futures (in submission order) created by the ask pattern internally are completed. 
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures. 
            '''Completes when''' upstream completes and all futures have been completed and all elements have been emitted. 
            '''Fails when''' the passed in actor terminates, or a timeout is exceeded in any of the asks performed. 
            '''Cancels when''' downstream cancels.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#Dsl#IFlow{TOut,TMat}#ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Source`2"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#Dsl#IFlow{TOut,TMat}#Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be the materialized
            value of the current flow (ignoring the other flow’s value), use
            <see cref="M:Akka.Streams.Dsl.Source`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Source`2"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Source`2"/> will be the materialized
            value of the current flow (ignoring the other flow’s value), use
            <see cref="M:Akka.Streams.Dsl.Source`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})"/> if a different strategy is needed.
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Akka#Streams#Dsl#IFlow{TOut,TMat}#MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            Transform only the materialized value of this Source, leaving all other properties as they were.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            Transform only the materialized value of this Source, leaving all other properties as they were.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.PreMaterialize(Akka.Streams.IMaterializer)">
            <summary>
             Materializes this Source immediately.
            </summary>
            <param name="materializer">The materializer.</param>
            <returns>A tuple containing the (1) materialized value and (2) a new <see cref="T:Akka.Streams.Dsl.Source"/>
             that can be used to consume elements from the newly materialized <see cref="T:Akka.Streams.Dsl.Source"/>.</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and run it. The returned value is the materialized value
            of the <see cref="T:Akka.Streams.Dsl.Sink`2"/> , e.g. the <see cref="T:Reactive.Streams.IPublisher`1"/> of a <see cref="M:Akka.Streams.Dsl.Sink.Publisher``1"/>.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunAggregate``1(``0,System.Func{``0,`0,``0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this <see cref="T:Akka.Streams.Dsl.Source`2"/> with a fold function.
            The given function is invoked for every received element, giving it its previous
            output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with Failure
            if there is a failure signaled in the stream.
            </summary>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunAggregateAsync``1(``0,System.Func{``0,`0,System.Threading.Tasks.Task{``0}},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this <see cref="T:Akka.Streams.Dsl.Source`2"/> with a async <paramref name="aggregate"/> function.
            The given function is invoked for every received element, giving it its previous
            output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with Failure
            if there is a failure signaled in the stream.
            </summary>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunSum(System.Func{`0,`0,`0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this <see cref="T:Akka.Streams.Dsl.Source`2"/> with a reduce function.
            The given function is invoked for every received element, giving it its previous
            output (from the second element) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with Failure
            if there is a failure signaled in the stream.
            </summary>
            <param name="reduce">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunForeach(System.Action{`0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this <see cref="T:Akka.Streams.Dsl.Source`2"/> with a foreach procedure. The given procedure is invoked
            for each received element.
            The returned <see cref="T:System.Threading.Tasks.Task"/> will be completed with Success when reaching the
            normal end of the stream, or completed with Failure if there is a failure signaled in
            the stream.
            </summary>
            <param name="action">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Combine``2(Akka.Streams.Dsl.Source{``0,Akka.NotUsed},Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},Akka.NotUsed}},Akka.Streams.Dsl.Source{``0,Akka.NotUsed}[])">
            <summary>
            Combines several sources with fun-in strategy like <see cref="T:Akka.Streams.Dsl.Merge`2"/> or <see cref="T:Akka.Streams.Dsl.Concat`2"/> and returns <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="first">TBD</param>
            <param name="second">TBD</param>
            <param name="strategy">TBD</param>
            <param name="rest">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ZipN``1(System.Collections.Generic.IEnumerable{Akka.Streams.Dsl.Source{``0,Akka.NotUsed}})">
            <summary>
            Combine the elements of multiple streams into a stream of lists.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="sources">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ZipWithN``2(System.Func{System.Collections.Immutable.IImmutableList{``0},``1},System.Collections.Generic.IEnumerable{Akka.Streams.Dsl.Source{``0,Akka.NotUsed}})">
            <summary>
            Combine the elements of multiple streams into a stream of sequences using a combiner function.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="zipper">TBD</param>
            <param name="sources">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Source">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Shape``1(System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromPublisher``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from <see cref="T:Reactive.Streams.IPublisher`1"/>.
            
            Construct a transformation starting with given publisher. The transformation steps
            are executed by a series of <see cref="T:Reactive.Streams.IProcessor`2"/> instances
            that mediate the flow of elements downstream and the propagation of
            back-pressure upstream.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="publisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromEnumerator``1(System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            Example usage: Source.FromEnumerator(() => Enumerable.Range(1, 10))
            
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from the given function that produces an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            The produced stream of elements will continue until the enumerator runs empty
            or fails during evaluation of the <see cref="M:System.Collections.IEnumerator.MoveNext">IEnumerator&lt;T&gt;.MoveNext</see> method.
            Elements are pulled out of the enumerator in accordance with the demand coming
            from the downstream transformation steps.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="enumeratorFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Cycle``1(System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
            Create <see cref="T:Akka.Streams.Dsl.Source`2"/> that will continually produce given elements in specified order.
            Start a new cycled <see cref="T:Akka.Streams.Dsl.Source`2"/> from the given elements. The producer stream of elements
            will continue infinitely by repeating the sequence of elements provided by function parameter.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="enumeratorFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Example usage: Source.From(Enumerable.Range(1, 10))
            
            Starts a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This is like starting from an
            Enumerator, but every Subscriber directly attached to the Publisher of this
            stream will see an individual flow of elements (always starting from the
            beginning) regardless of when they subscribed.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="enumerable">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Single``1(``0)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> with one element.
            Every connected <see cref="T:Akka.Streams.Dsl.Sink`2"/> of this stream will see an individual stream consisting of one element.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromGraph``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            A graph with the shape of a source logically is a source, this method makes
            it so also in type.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="source">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from the given <see cref="T:System.Threading.Tasks.Task`1"/>. The stream will consist of
            one element when the <see cref="T:System.Threading.Tasks.Task`1"/> is completed with a successful value, which
            may happen before or after materializing the <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            The stream terminates with a failure if the task is completed with a failure.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Tick``1(System.TimeSpan,System.TimeSpan,``0)">
            <summary>
            Elements are emitted periodically with the specified interval.
            The tick element will be delivered to downstream consumers that has requested any elements.
            If a consumer has not requested any elements at the point in time when the tick
            element is produced it will not receive that tick element later. It will
            receive new tick elements as soon as it has requested more elements.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="tick">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Repeat``1(``0)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that will continually emit the given element.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,Akka.Util.Option{System.ValueTuple{``0,``1}}})">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that will unfold a value of type <typeparamref name="TState"/> into
            a pair of the next state <typeparamref name="TState"/> and output elements of type <typeparamref name="TElem"/>.
            </summary>
            <example>
            For example, all the Fibonacci numbers under 10M:
            <code>
              Source.unfold(0 → 1) {
               case (a, _) if a > 10000000 ⇒ None
               case (a, b) ⇒ Some((b → (a + b)) → a)
              }
            </code>
            </example>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElem">TBD</typeparam>
            <param name="state">TBD</param>
            <param name="unfold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldAsync``2(``0,System.Func{``0,System.Threading.Tasks.Task{Akka.Util.Option{System.ValueTuple{``0,``1}}}})">
            <summary>
            Same as <see cref="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,Akka.Util.Option{System.ValueTuple{``0,``1}}})"/>, but uses an async function to generate the next state-element tuple.
            </summary>
            <example>
            For example, all the Fibonacci numbers under 10M:
            <code>
            Source.unfoldAsync(0 → 1) {
             case (a, _) if a > 10000000 ⇒ Future.successful(None)
             case (a, b) ⇒ Future{
               Thread.sleep(1000)
               Some((b → (a + b)) → a)
             }
            }
            </code>
            </example>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElem">TBD</typeparam>
            <param name="state">TBD</param>
            <param name="unfoldAsync">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldInfinite``2(``0,System.Func{``0,System.ValueTuple{``0,``1}})">
            <summary>
            Simpler <see cref="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,Akka.Util.Option{System.ValueTuple{``0,``1}}})"/>, for infinite sequences. 
            </summary>
            <example>
            <code>
            {{{
              Source.unfoldInf(0 → 1) {
               case (a, b) ⇒ (b → (a + b)) → a
              }
            }}}
            </code>
            </example>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElem">TBD</typeparam>
            <param name="state">TBD</param>
            <param name="unfold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Empty``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Source`2"/> with no elements, i.e. an empty stream that is completed immediately for every connected <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary> 
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Maybe``1">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> which materializes a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> which controls what element
            will be emitted by the Source.
            If the materialized promise is completed with a Some, that value will be produced downstream,
            followed by completion.
            If the materialized promise is completed with a None, no value will be produced downstream and completion will
            be signaled immediately.
            If the materialized promise is completed with a failure, then the returned source will terminate with that error.
            If the downstream of this source cancels before the promise has been completed, then the promise will be completed
            with None.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Failed``1(System.Exception)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that immediately ends the stream with the <paramref name="cause"/> error to every connected <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Lazily``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is not materialized until there is downstream demand, when the source gets materialized
            the materialized task is completed with its value, if downstream cancels or fails without any demand the
            <paramref name="create"/> factory is never called and the materialized <see cref="T:System.Threading.Tasks.Task`1"/> is failed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.AsSubscriber``1">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as a <see cref="T:Reactive.Streams.ISubscriber`1"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ActorPublisher``1(Akka.Actor.Props)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized to an <see cref="T:Akka.Actor.IActorRef"/> which points to an Actor
            created according to the passed in <see cref="T:Akka.Actor.Props"/>. Actor created by the <see cref="T:Akka.Actor.Props"/> must
            be <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="props">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified actor <paramref name="props"/> is not of type <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ActorRef``1(System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as an <see cref="T:Akka.Actor.IActorRef"/>.
            Messages sent to this actor will be emitted to the stream if there is demand from downstream,
            otherwise they will be buffered until request for demand is received.
            
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements if
            there is no space available in the buffer.
            
            The strategy <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/> is not supported, and an
            IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
            
            The buffer can be disabled by using <paramref name="bufferSize"/> of 0 and then received messages are dropped
            if there is no demand from downstream. When <paramref name="bufferSize"/> is 0 the <paramref name="overflowStrategy"/> does
            not matter. An async boundary is added after this Source; as such, it is never safe to assume the downstream will always generate demand.
            
            The stream can be completed successfully by sending the actor reference a <see cref="T:Akka.Actor.Status.Success"/>
            message (whose content will be ignored) in which case already buffered elements will be signaled before signaling completion,
            or by sending <see cref="T:Akka.Actor.PoisonPill"/> in which case completion will be signaled immediately.
            
            The stream can be completed with failure by sending a <see cref="T:Akka.Actor.Status.Failure"/> to the
            actor reference. In case the Actor is still draining its internal buffer (after having received
            a <see cref="T:Akka.Actor.Status.Success"/>) before signaling completion and it receives a <see cref="T:Akka.Actor.Status.Failure"/>,
            the failure will be signaled downstream immediately (instead of the completion signal).
            
            The actor will be stopped when the stream is completed, failed or canceled from downstream,
            i.e. you can watch it to get notified when that happens.
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Source.Queue``1(System.Int32,Akka.Streams.OverflowStrategy)"/>
            <typeparam name="T">TBD</typeparam>
            <param name="bufferSize">The size of the buffer in element count</param>
            <param name="overflowStrategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="bufferSize"/> is less than zero.
            </exception>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown when the specified <paramref name="overflowStrategy"/> is of type <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Combine``2(Akka.Streams.Dsl.Source{``0,Akka.NotUsed},Akka.Streams.Dsl.Source{``0,Akka.NotUsed},System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},Akka.NotUsed}},Akka.Streams.Dsl.Source{``0,Akka.NotUsed}[])">
            <summary>
            Combines several sources with fun-in strategy like <see cref="T:Akka.Streams.Dsl.Merge`2"/> or <see cref="T:Akka.Streams.Dsl.Concat`2"/> and returns <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="first">TBD</param>
            <param name="second">TBD</param>
            <param name="strategy">TBD</param>
            <param name="rest">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.CombineMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``0,``3},System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},Akka.NotUsed}},System.Func{``2,``3,``4})">
            <summary>
            Combines two sources with fan-in strategy like <see cref="T:Akka.Streams.Dsl.Merge`2"/> or <see cref="T:Akka.Streams.Dsl.Concat`2"/> and returns <see cref="T:Akka.Streams.Dsl.Source`2"/> with a materialized value.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMatOut">TBD</typeparam>
            <param name="first">TBD</param>
            <param name="second">TBD</param>
            <param name="strategy">TBD</param>
            <param name="combineMaterializers">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ZipN``1(System.Collections.Generic.IEnumerable{Akka.Streams.Dsl.Source{``0,Akka.NotUsed}})">
            <summary>
            Combines the elements of multiple streams into a stream of lists.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="sources">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ZipWithN``2(System.Func{System.Collections.Immutable.IImmutableList{``0},``1},System.Collections.Generic.IEnumerable{Akka.Streams.Dsl.Source{``0,Akka.NotUsed}})">
            <summary>
            Combines the elements of multiple streams into a stream of sequences using a combiner function.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="zipper">TBD</param>
            <param name="sources">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Queue``1(System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as an <see cref="T:Akka.Streams.ISourceQueueWithComplete`1"/>.
            You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
            otherwise they will be buffered until request for demand is received.
            
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements if
            there is no space available in the buffer.
            
            Acknowledgement mechanism is available.
            <see cref="M:Akka.Streams.ISourceQueue`1.OfferAsync(`0)">ISourceQueueWithComplete&lt;T&gt;.OfferAsync</see> returns <see cref="T:System.Threading.Tasks.Task"/>
            which completes with <see cref="T:Akka.Streams.QueueOfferResult.Enqueued"/> if element was added to buffer or sent downstream.
            It completes with <see cref="T:Akka.Streams.QueueOfferResult.Dropped"/> if element was dropped.
            Can also complete with <see cref="T:Akka.Streams.QueueOfferResult.Failure"/> - when stream failed
            or <see cref="T:Akka.Streams.QueueOfferResult.QueueClosed"/> when downstream is completed.
            
            The strategy <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/> will not complete <see cref="M:Akka.Streams.ISourceQueue`1.OfferAsync(`0)">ISourceQueueWithComplete&lt;T&gt;.OfferAsync</see> when buffer is full.
            
            The buffer can be disabled by using <paramref name="bufferSize"/> of 0 and then received messages will wait
            for downstream demand unless there is another message waiting for downstream demand, in that case
            offer result will be completed according to the <paramref name="overflowStrategy"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="bufferSize">The size of the buffer in element count</param>
            <param name="overflowStrategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="bufferSize"/> is less than zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldResource``2(System.Func{``1},System.Func{``1,Akka.Util.Option{``0}},System.Action{``1})">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from some resource which can be opened, read and closed.
            Interaction with resource happens in a blocking way.
            <para>
            Example:
            {{{
            Source.unfoldResource(
              () => new BufferedReader(new FileReader("...")),
              reader => Option(reader.readLine()),
              reader => reader.close())
            }}}
            </para>
            <para>
            You can use the supervision strategy to handle exceptions for <paramref name="read"/> function. All exceptions thrown by <paramref name="create"/>
            or <paramref name="close"/> will fail the stream.
            </para>
            <para>
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> supervision strategy will close and create blocking IO again. Default strategy is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> which means
            that stream will be terminated on error in `read` function by default.
            </para>
            <para>
            You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>.
            </para>
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TSource">TBD</typeparam>
            <param name="create">function that is called on stream start and creates/opens resource.</param>
            <param name="read">function that reads data from opened resource. It is called each time backpressure signal
            is received. Stream calls close and completes when <paramref name="read"/> returns <see cref="F:Akka.Util.Option`1.None"/>.</param>
            <param name="close">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldResourceAsync``2(System.Func{System.Threading.Tasks.Task{``1}},System.Func{``1,System.Threading.Tasks.Task{Akka.Util.Option{``0}}},System.Func{``1,System.Threading.Tasks.Task})">
            <summary>
            <para>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from some resource which can be opened, read and closed.
            It's similar to <see cref="M:Akka.Streams.Dsl.Source.UnfoldResource``2(System.Func{``1},System.Func{``1,Akka.Util.Option{``0}},System.Action{``1})"/> but takes functions that return <see cref="T:System.Threading.Tasks.Task"/>s instead of plain values.
            </para>
            <para>
            You can use the supervision strategy to handle exceptions for <paramref name="read"/> function or failures of produced <see cref="T:System.Threading.Tasks.Task"/>s.
            All exceptions thrown by <paramref name="create"/> or <paramref name="close"/> as well as fails of returned futures will fail the stream.
            </para>
            <para>
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> supervision strategy will close and create resource .Default strategy is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> which means
            that stream will be terminated on error in <paramref name="read"/> function (or task) by default.
            </para>
            <para>
            You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>.
            </para>
            <para>
            Adheres to the <see cref="T:Akka.Streams.ActorAttributes.SupervisionStrategy"/> attribute.
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TSource">TBD</typeparam>
            <param name="create">function that is called on stream start and creates/opens resource.</param>
            <param name="read">function that reads data from opened resource. It is called each time backpressure signal
            is received. Stream calls close and completes when <see cref="T:System.Threading.Tasks.Task"/> from read function returns None.</param>
            <param name="close">function that closes resource</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromEvent``2(System.Func{System.Action{``1},``0},System.Action{``0},System.Action{``0},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> attached to a .NET event. In case when event will be triggered faster, than a downstream is able 
            to consume incoming events, a buffering will occur. It can be configured via optional <paramref name="maxBufferCapacity"/> and 
            <paramref name="overflowStrategy"/> parameters.
            </summary>
            <typeparam name="TDelegate">Delegate type used to attach current source.</typeparam>
            <typeparam name="T">Type of the event args produced as source events.</typeparam>
            <param name="conversion">A function used to convert provided event handler into a delegate compatible with an underlying .NET event type.</param>
            <param name="addHandler">Action used to attach the given event handler to the underlying .NET event.</param>
            <param name="removeHandler">Action used to detach the given event handler to the underlying .NET event.</param>
            <param name="maxBufferCapacity">Maximum size of the buffer, used in situation when amount of emitted events is higher than current processing capabilities of the downstream.</param>
            <param name="overflowStrategy">Overflow strategy used, when buffer (size specified by <paramref name="maxBufferCapacity"/>) has been overflown.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromEvent``1(System.Action{System.EventHandler{``0}},System.Action{System.EventHandler{``0}},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> attached to a .NET event. In case when event will be triggered faster, than a downstream is able 
            to consume incoming events, a buffering will occur. It can be configured via optional <paramref name="maxBufferCapacity"/> and 
            <paramref name="overflowStrategy"/> parameters.
            </summary>
            <typeparam name="T">Type of the event args produced as source events.</typeparam>
            <param name="addHandler">Action used to attach the given event handler to the underlying .NET event.</param>
            <param name="removeHandler">Action used to detach the given event handler to the underlying .NET event.</param>
            <param name="maxBufferCapacity">Maximum size of the buffer, used in situation when amount of emitted events is higher than current processing capabilities of the downstream.</param>
            <param name="overflowStrategy">Overflow strategy used, when buffer (size specified by <paramref name="maxBufferCapacity"/>) has been overflown.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromObservable``1(System.IObservable{``0},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> attached to an existing <see cref="T:System.IObservable`1"/>. In case when upstream (an <paramref name="observable"/>)
            is producing events in a faster pace, than downstream is able to consume them, a buffering will occur. It can be configured via optional 
            <paramref name="maxBufferCapacity"/> and <paramref name="overflowStrategy"/> parameters.
            </summary>
            <typeparam name="T">Type of the event args produced as source events.</typeparam>
            <param name="observable">An <see cref="T:System.IObservable`1"/> to which current source will be subscribed.</param>
            <param name="maxBufferCapacity">Maximum size of the buffer, used in situation when amount of emitted events is higher than current processing capabilities of the downstream.</param>
            <param name="overflowStrategy">Overflow strategy used, when buffer (size specified by <paramref name="maxBufferCapacity"/>) has been overflown.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceGen.UnfoldFlow``3(``0,Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,System.ValueTuple{``0,``1}},``2},System.TimeSpan)">
            <summary>
            EXPERIMENTAL API
            <para>
            Create a source that will unfold a value of type <typeparamref name="TState"/> by
            passing it through a flow. The flow should emit a
            pair of the next state <typeparamref name="TState"/> and output elements of type <typeparamref name="TOut"/>.
            Source completes when the flow completes.
            </para>
            <para>
            The <paramref name="timeout"/> parameter specifies waiting time after inner
            flow provided by the user for unfold flow API cancels
            upstream, to get also the downstream cancelation (as
            graceful completion or failure which is propagated).
            If inner flow fails to complete/fail downstream, stage is failed.                
            </para>
            <para>
            IMPORTANT CAVEAT:
            The given flow must not change the number of elements passing through it(i.e.it should output
            exactly one element for every received element). Ignoring this, will have an unpredicted result,
            and may result in a deadlock.
            </para>
            </summary>
            <typeparam name="TState">state type</typeparam>
            <typeparam name="TOut">output elements type</typeparam>
            <typeparam name="TMat">materialized value type</typeparam>
            <param name="seed">intial state</param>
            <param name="flow">flow, through which value is passed</param>
            <param name="timeout">timeout</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceGen.UnfoldFlowWith``4(``1,Akka.Streams.IGraph{Akka.Streams.FlowShape{``1,``2},``3},System.Func{``2,Akka.Util.Option{System.ValueTuple{``1,``0}}},System.TimeSpan)">
            <summary>
            EXPERIMENTAL API
            <para>
            Create a source that will unfold a value of type <typeparamref name="TState"/> by
            passing it through a flow. The flow should emit an output
            value of type <typeparamref name="TFlowOut"/>, that when fed to the unfolding function,
            generates a pair of the next state <typeparamref name="TState"/> and output elements of type <typeparamref name="TOut"/>.
            </para>
            <para>
            The <paramref name="timeout"/> parameter specifies waiting time after inner
            flow provided by the user for unfold flow API cancels
            upstream, to get also the downstream cancelation(as
            graceful completion or failure which is propagated).
            If inner flow fails to complete/fail downstream, stage is failed.
            </para>
            <para>
            IMPORTANT CAVEAT:
            The given flow must not change the number of elements passing through it(i.e.it should output
            exactly one element for every received element). Ignoring this, will have an unpredicted result,
            and may result in a deadlock.
            </para>
            </summary>
            <typeparam name="TOut">output elements type</typeparam>
            <typeparam name="TState">state type</typeparam>
            <typeparam name="TFlowOut">flow output value type</typeparam>
            <typeparam name="TMat">materialized value type</typeparam>
            <param name="seed">intial state</param>
            <param name="flow">flow through which value is passed</param>
            <param name="unfoldWith">unfolding function</param>
            <param name="timeout">timeout</param>
        </member>
        <member name="T:Akka.Streams.Dsl.SourceOperations">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Recover``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para/>
            Throwing an exception inside Recover will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="partialFunc"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception pf can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.RecoverWith``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWith will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.RecoverWithRetries``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}},System.Int32)">
            <summary>
            RecoverWithRetries  allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered up to <paramref name="attempts"/> number of times so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized. Note that if you pass in 0, this won't attempt to recover at all. Passing in -1 will behave exactly the same as  <see cref="M:Akka.Streams.Dsl.SourceOperations.RecoverWithRetries``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}},System.Int32)"/>.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWithRetries will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            /// <param name="partialFunc">Receives the failure cause and returns the new Source to be materialized if any</param>
            <param name="attempts">Maximum number of retries or -1 to retry indefinitely</param>
            <exception cref="T:System.ArgumentException">if <paramref name="attempts"/> is a negative number other than -1</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SelectError``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,System.Exception})">
            <summary>
            While similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Recover``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})"/> this stage can be used to transform an error signal to a different one without logging
            it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e => throw e2) since Recover
            would log the e2 error. 
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Similarily to <see cref="M:Akka.Streams.Dsl.SourceOperations.Recover``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Util.Option{``0}})"/> throwing an exception inside SelectError will be logged.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="selector"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception returned by the <paramref name="selector"/>
            </para>
            Cancels when downstream cancels 
            </summary>
            <param name="flow">TBD</param>
            <param name="selector">Receives the failure cause and returns the new cause, return the original exception if no other should be applied</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Select``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given <paramref name="mapper"/> function to each of the elements
            as they pass through this processing step.
            <para>
            Emits when the mapping function <paramref name="mapper"/> returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            Emits when the mapping function <paramref name="mapConcater"/> returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcater">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.StatefulSelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Transform each input element into an Enumerable of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function <paramref name="mapConcaterFactory"/> a new for every materialization —
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>.
            
            The returned Enumerable MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            Emits when the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcaterFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task`1"/> and the
            value of that task will be emitted downstream. The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>.
            These tasks may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when the task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream
            backpressures or the first task is not completed
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsyncUnordered``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SelectAsyncUnordered``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that task will be emitted downstream. The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsyncUnordered``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>. 
            Each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when any of the tasks returned by the provided function complete
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.SelectAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Where``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.WhereNot``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that NOT satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0},System.Boolean)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after <paramref name="predicate"/>
            returns false for the first time, including the first failed element iff inclusive is true
            Due to input buffering some elements may have been requested from upstream publishers
            that will then not be processed downstream of this step.
            
            The stream will be completed without producing any elements if <paramref name="predicate"/> is false for
            the first stream element.
            <para>
            Emits when the <paramref name="predicate"/> is true
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when <paramref name="predicate"/> returned false (or 1 after predicate returns false if <paramref name="inclusive"/>) or upstream completes
            </para>
            <para>
            Cancels when <paramref name="predicate"/> returned false or downstream cancels
            </para>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Limit``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/> <seealso cref="M:Akka.Streams.Dsl.SourceOperations.LimitWeighted``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64,System.Func{``0,System.Int64})"/>
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <param name="inclusive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SkipWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Discard elements at the beginning of the stream while <paramref name="predicate"/> is true.
            All elements will be taken after <paramref name="predicate"/> returns false first time.
            <para>
            Emits when <paramref name="predicate"/> returned false and for all following stream elements
            </para>
            Backpressures when <paramref name="predicate"/> returned false and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Collect``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given function <paramref name="collector"/> to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            Emits when the provided function <paramref name="collector"/> is defined for the element
            </para>
            Backpressures when the function <paramref name="collector"/> is defined for the element and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="collector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Grouped``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the specified number of elements has been accumulated or upstream completed
            </para>
            Backpressures when a group has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Limit``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.LimitWeighted``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64,System.Func{``0,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Sliding``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            Emits when enough elements have been collected within the window or upstream completed
            </para>
            Backpressures when a window has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="step">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Scan``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Aggregate``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when the function scanning the element returns a new element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ScanAsync``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Scan``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but with a asynchronous function,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>
            emitting a <see cref="T:System.Threading.Tasks.Task`1"/> that resolves to the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> current value starts at the previous
            current value, or zero when it doesn't have one, and the stream will continue.
            <para>
            Emits the <see cref="T:System.Threading.Tasks.Task`1"/> returned by <paramref name="scan"/> completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes upstream completes and the last task returned by <paramref name="scan"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Aggregate``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Scan``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but only emits its result when the upstream completes,
            after which it also completes. Applies the given function <paramref name="fold"/> towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AggregateAsync``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Aggregate``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but with an asynchronous function.
            Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> returns a failure and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Aggregate``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/>
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Sum``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Aggregate``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but uses first element as zero element.
            Applies the given function <paramref name="reduce"/> towards its current and next value,
            yielding the next current value. 
            
            If the stream is empty (i.e. completes before signaling any elements),
            the sum stage will fail its downstream with a <see cref="T:Akka.Streams.NoSuchElementException"/>,
            which is semantically in-line with that standard library collections do in such situations.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="reduce">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Intersperse``2(Akka.Streams.Dsl.Source{``0,``1},``0,``0,``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="start"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="start">TBD</param>
            <param name="inject">TBD</param>
            <param name="end">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Intersperse``2(Akka.Streams.Dsl.Source{``0,``1},``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="inject"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="inject">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.GroupedWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the configured time elapses since the last group has been emitted
            </para>
            Backpressures when the configured time elapses since the last group has been emitted
            <para>
            Completes when upstream completes (emits last group)
            </para>
            Cancels when downstream completes
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="timeout">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Delay``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            Emits when there is a pending element in the buffer and configured time for this element elapsed
             <para/> * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            Backpressures when depending on OverflowStrategy
             <para/> * Backpressure - backpressures when buffer is full
             <para/> * DropHead, DropTail, DropBuffer - never backpressures
             <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Skip``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            Emits when the specified number of elements has been dropped already
            </para>
            Backpressures when the specified number of elements has been dropped and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SkipWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            Emits when the specified time elapsed and a new upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            Emits when an upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or timer fires
            </para>
            Cancels when downstream cancels or timer fires
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.SourceOperations.Conflate``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TSeed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Conflate``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Batch``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Emits when downstream stops backpressuring and there is an aggregated element available
            
             Backpressures when there are <paramref name="max"/> batched elements and 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SourceOperations.BatchWeighted``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.BatchWeighted``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate <see cref="T:Akka.IO.ByteString"/>
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the <paramref name="seed"/> function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             Emits when downstream stops backpressuring and there is a batched element available
            
             Backpressures when there are <paramref name="max"/> weighted batched elements + 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Batch``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Expand``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerator{``1}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="extrapolate"/> function will complete the stream with failure.
            <para>
            Emits when downstream stops backpressuring
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Buffer``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            Emits when downstream stops backpressuring and there is a pending element in the buffer
            </para>
            Backpressures when downstream backpressures or depending on OverflowStrategy:
            <para/> * Backpressure - backpressures when buffer is full
            <para/> * DropHead, DropTail, DropBuffer - never backpressures
            <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Transform``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Stage.IStage{``0,``1}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="stageFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.PrefixAndTail``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            Emits when the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            Backpressures when downstream backpressures or substream backpressures
            <para>
            Completes when prefix elements has been consumed and substream has been consumed
            </para>
            Cancels when downstream cancels or substream cancels
            </summary> 
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.GroupBy``3(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.Func{``0,``2})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            Emits when an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            Backpressures when there is an element pending for a group whose substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and all substreams cancel
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="maxSubstreams">TBD</param>
            <param name="groupingFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the * first * element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal <see cref="T:Akka.Streams.Dsl.Source`2"/> or <see cref="T:Akka.Streams.Dsl.Flow`3"/>,
            it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>)
            or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and 
            <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
            on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})"/>
                operator itself—and thereby all substreams—once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            Emits when an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            Backpressures when there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})"/> 
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It * ends * the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal [[Source]] or[[Flow]],
             it is a <see cref="T:Akka.Streams.Dsl.SubFlow`3"/>. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion.Substream mode
             is exited either by closing the substream(i.e.connecting it to a [[Sink]])
             or by merging the substreams back together; see the <see cref="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})"/> and <see cref="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams"/> methods
             on <see cref="T:Akka.Streams.Dsl.SubFlow`3"/> for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the <see cref="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})"/> 
             operator itself—and thereby all substreams—once all internal or explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             Emits when an element passes through.When the provided predicate is true it emits the element
             and opens a new substream for subsequent element
             </para>
             Backpressures when there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             Completes when upstream completes
             </para>
             Cancels when downstream cancels and substreams cancel
             </summary>
             <seealso cref="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})"/>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="substreamCancelStrategy">TBD</param>
             <param name="predicate">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams. It *ends* the current substream when the
            predicate is true.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ConcatMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeMany``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ZipWithIndex``2(Akka.Streams.Dsl.Source{``0,``1})">
            <summary>
            Combine the elements of current flow into a stream of tuples consisting
            of all elements paired with their index. Indices start at 0.
            
            <para/>
            Emits when upstream emits an element and is paired with their index
            <para/>
            Backpressures when downstream backpressures
            <para/>
            Completes when upstream completes
            <para/>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InitialTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before first element arrives
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.CompletionTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.IdleTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>. 
            The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between two emitted elements
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.BackpressureTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
            the stream is failed with a <see cref="T:System.TimeoutException"/>. The timeout is checked periodically,
            so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between element emission and downstream demand.
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.KeepAlive``3(Akka.Streams.Dsl.Source{``0,``2},System.TimeSpan,System.Func{``1})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            Emits when upstream emits an element or if the upstream was idle for the configured period
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TInjected">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <param name="injectElement">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Throttle``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="elements"/>/<paramref name="per"/>. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="elements">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="mode">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Throttle``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan,System.Int32,System.Func{``0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be spared for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="cost">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="calculateCost">TBD</param>
            <param name="mode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AlsoToMaterialized``4(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},System.Func{``1,``2,``3})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.SourceOperations.AlsoTo``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="materializerFunction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AlsoTo``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             Emits when element is available and demand exists both from the Sink and the downstream.
            
             Backpressures when downstream or Sink backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.WatchTermination``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``1,System.Threading.Tasks.Task,``2})">
            <summary>
             Materializes to <see cref="T:System.Threading.Tasks.Task`1"/> that completes on getting termination message.
             The task completes with success when received complete message from upstream or cancel
             from downstream. It fails with the same error when received error message from
             downstream.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="materializerFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Monitor``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``1,Akka.Streams.IFlowMonitor,``2})">
            <summary>
            Materializes to <see cref="T:Akka.Streams.IFlowMonitor"/> that allows monitoring of the the current flow. All events are propagated
            by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
            event, and may therefor affect performance.
            The <paramref name="combine"/> function is used to combine the <see cref="T:Akka.Streams.IFlowMonitor"/> with this flow's materialized value.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Detach``2(Akka.Streams.Dsl.Source{``0,``1})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             Emits when upstream emits an element
            
             Backpressures when downstream backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InitialDelay``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            Emits when upstream emits an element if the initial delay is already elapsed
            </para>
            Backpressures when downstream backpressures or initial delay is not yet elapsed
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="delay">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Log``2(Akka.Streams.Dsl.Source{``0,``1},System.String,System.Func{``0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            Emits when the mapping function returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="name">TBD</param>
            <param name="extract">TBD</param>
            <param name="log">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Zip``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Combine the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/> into a stream of tuples.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ZipWith``4(Akka.Streams.Dsl.Source{``0,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``0,``1,``2})">
            <summary>
            Put together the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/>
            into a stream of combined elements using a combiner function.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Interleave``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="other"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            Emits when element is available from the currently consumed upstream
            </para>
            Backpressures when downstream backpressures. Signal to current
            upstream, switch to next upstream when received <paramref name="segmentSize"/> elements
            <para>
            Completes when the <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="segmentSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InterleaveMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Int32,System.Func{``2,``3,``4})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/> source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="T1">TBD</typeparam>
             <typeparam name="T2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="graph">TBD</param>
             <param name="segmentSize">TBD</param>
             <param name="combine">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Merge``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="eagerComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.SourceOperations.Merge``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Func{``0,``0,System.Int32})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="orderFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Concatenate the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that once this
            Flow’s input is exhausted and all result elements have been generated,
            the Source’s elements will be produced.
            
            Note that the <see cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> gets upstream error - no elements from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            <para>
            Emits when element is available from current stream or from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> when current is completed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.CombineMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``0,``3},System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},Akka.NotUsed}},System.Func{``2,``3,``4})">
            <summary>
            Combines the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Source`2"/> with fan-in strategy like <see cref="T:Akka.Streams.Dsl.Merge`2"/> or <see cref="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> and returns <see cref="T:Akka.Streams.Dsl.Source`2"/> with a materialized value.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat1">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMatOut">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="strategy">TBD</param>
            <param name="combineMaterializers">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Prepend``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
             <summary>
             Prepend the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that before elements
             are generated from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <see cref="T:Akka.Streams.Dsl.Source`2"/> gets upstream error - no elements from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be pulled.
            
             Emits when element is available from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> or from current stream when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is completed
            
             Backpressures when downstream backpressures
            
             Completes when this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut1">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.OrElse``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
             <summary>
             Provides a secondary source that will be consumed if this stream completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             Note that this Flow will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes or it gets
             cancelled.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                              is available from the second stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                                by from this stream.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.OrElseMaterialized``4(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``2},System.Func{``1,``2,``3})">
             <summary>
             Provides a secondary source that will be consumed if this source completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             
             <seealso cref="M:Akka.Streams.Dsl.SourceOperations.OrElse``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/>
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <param name="materializedFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AsSourceWithContext``3(Akka.Streams.Dsl.Source{``1,``2},System.Func{``1,``0})">
            <summary>
            Starts a new kind of a source, that is able to keep a context object and propagate it across
            stages. Can be finished with <see cref="M:Akka.Streams.Dsl.SourceWithContext`3.AsSource"/>.
            </summary>
            <param name="flow"></param>
            <param name="fn">Function used to extract context object out of the incoming events.</param>
            <typeparam name="TCtx">Type of a context.</typeparam>
            <typeparam name="TOut">Type of produced events.</typeparam>
            <typeparam name="TMat">Type of materialized value.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Watch``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Actor.IActorRef)">
            <summary>
            The operator fails with an <see cref="T:Akka.Streams.WatchedActorTerminatedException"/> if the target actor is terminated.
            
            '''Emits when''' upstream emits 
            '''Backpressures when''' downstream backpressures 
            '''Completes when''' upstream completes 
            '''Fails when''' the watched actor terminates 
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.SourceWithContext`3">
            <summary>
            A source that provides operations which automatically propagate the context of an element.
            Only a subset of common operations from [[FlowOps]] is supported. As an escape hatch you can
            use [[FlowWithContextOps.via]] to manually provide the context propagation for otherwise unsupported
            operations.
            
            Can be created by calling <see cref="!:Source&lt;TOut,TMat&gt;.StartContextPropagation"/>
            
            API MAY CHANGE
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContext`3.Via``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{`1,`0},System.ValueTuple{``1,``0}},``2})">
            <summary>
             Transform this flow by the regular flow. The given flow must support manual context propagation by
             taking and producing tuples of (data, context).
             
             This can be used as an escape hatch for operations that are not (yet) provided with automatic
             context propagation here.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContext`3.ViaMaterialized``4(Akka.Streams.IGraph{Akka.Streams.FlowShape{System.ValueTuple{`1,`0},System.ValueTuple{``1,``0}},``2},System.Func{`2,``2,``3})">
            <summary>
             Transform this flow by the regular flow. The given flow must support manual context propagation by
             taking and producing tuples of (data, context).
             
             This can be used as an escape hatch for operations that are not (yet) provided with automatic
             context propagation here.
             
             The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
             flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceWithContext`3.AsSource">
            <summary>
            Stops automatic context propagation from here and converts this to a regular
            stream of a pair of (data, context).
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.StreamConverters">
            <summary>
            Converters for interacting with the IO streams APIs
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.FromInputStream(System.Func{System.IO.Stream},System.Int32)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> from an <see cref="T:System.IO.Stream"/> created by the given function.
            Emitted elements are <paramref name="chunkSize"/> sized <see cref="T:Akka.IO.ByteString"/> elements.
            The actual size of emitted elements depends how much data the underlying
            <see cref="T:System.IO.Stream"/> returns on each read invocation. Such chunks will
            never be larger than chunkSize though.
            <para>
            You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>.
            </para>
            <para>
            It materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> containing the number of bytes read from the source file upon completion,
            and a possible exception if IO operation was not completed successfully.
            </para>
            The created <see cref="T:System.IO.Stream"/> will be closed when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is cancelled.
            </summary>
            <param name="createInputStream">A function which creates the <see cref="T:System.IO.Stream"/> to read from</param>
            <param name="chunkSize">The size of each read operation, defaults to 8192</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.AsOutputStream(System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> which when materialized will return an <see cref="T:System.IO.Stream"/> which it is possible
            to write the ByteStrings to the stream this Source is attached to.
            
            This Source is intended for inter-operation with legacy APIs since it is inherently blocking.
            
            You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>.
            
            The created <see cref="T:System.IO.Stream"/> will be closed when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is cancelled, and closing the <see cref="T:System.IO.Stream"/>
            will complete this <see cref="T:Akka.Streams.Dsl.Source`2"/>.
            </summary>
            <param name="writeTimeout">The max time the write operation on the materialized OutputStream should block, defaults to 5 seconds</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.FromOutputStream(System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a Sink which writes incoming <see cref="T:Akka.IO.ByteString"/>s to an <see cref="T:System.IO.Stream"/> created by the given function.
            
            Materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> that will be completed with the size of the file (in bytes) at the streams completion,
            and a possible exception if IO operation was not completed successfully.
            
            You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>. 
            If <paramref name="autoFlush"/> is true the OutputStream will be flushed whenever a byte array is written, defaults to false.
            
            The <see cref="T:System.IO.Stream"/> will be closed when the stream flowing into this <see cref="T:Akka.Streams.Dsl.Sink`2"/> is completed. The <see cref="T:Akka.Streams.Dsl.Sink`2"/>
            will cancel the stream when the <see cref="T:System.IO.Stream"/> is no longer writable.
            </summary>
            <param name="createOutputStream">A function which creates the <see cref="T:System.IO.Stream"/> to write to</param>
            <param name="autoFlush">If set to true the <see cref="T:System.IO.Stream"/> will be flushed whenever a byte array is written, default is false</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.AsInputStream(System.Nullable{System.TimeSpan})">
            <summary>
            Creates a Sink which when materialized will return an <see cref="T:System.IO.Stream"/> which it is possible
            to read the values produced by the stream this Sink is attached to.
            
            This Sink is intended for inter-operation with legacy APIs since it is inherently blocking.
            
            You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
            set it for a given Source by using <see cref="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)"/>.
            
            The <see cref="T:System.IO.Stream"/> will be closed when the stream flowing into this <see cref="T:Akka.Streams.Dsl.Sink`2"/> completes, and
            closing the <see cref="T:System.IO.Stream"/> will cancel this <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
            <param name="readTimeout">The max time the read operation on the materialized stream should block</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.StreamRefs">
            <summary> 
            API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value
            will eventually be able to remove the Task wrapping the stream references. For this reason the API is now marked
            as API may change. See ticket https://github.com/akka/akka/issues/24372 for more details.
            
            Factories for creating stream refs.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamRefs.SourceRef``1">
            <summary>
            A local <see cref="T:Akka.Streams.Dsl.Sink`2"/> which materializes a <see cref="M:Akka.Streams.Dsl.StreamRefs.SourceRef``1"/> which can be used by other streams (including remote ones),
            to consume data from this local stream, as if they were attached in the spot of the local Sink directly.
            
            Adheres to <see cref="T:Akka.Streams.StreamRefAttributes"/>.
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.StreamRefs.SourceRef``1"/>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamRefs.SinkRef``1">
            <summary>
            A local <see cref="T:Akka.Streams.Dsl.Sink`2"/> which materializes a <see cref="M:Akka.Streams.Dsl.StreamRefs.SinkRef``1"/> which can be used by other streams (including remote ones),
            to consume data from this local stream, as if they were attached in the spot of the local Sink directly.
            
            Adheres to <see cref="T:Akka.Streams.StreamRefAttributes"/>.
            
            See more detailed documentation on [[SinkRef]].
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.StreamRefs.SinkRef``1"/>
        </member>
        <member name="T:Akka.Streams.Dsl.StreamRefSettings">
            <summary>
            INTERNAL API.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.SubFlow`3">
            <summary>
            A "stream of streams" sub-flow of data elements, e.g. produced by <see cref="T:Akka.Streams.Implementation.Fusing.GroupBy`2"/>.
            SubFlows cannot contribute to the super-flowâ€™s materialized value since they
            are materialized later, during the runtime of the flow graph processing.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/> and run it. The returned value is the materialized value
            of the <see cref="T:Akka.Streams.Dsl.Sink`2"/>, e.g. the <see cref="T:Reactive.Streams.IPublisher`1"/> of a <see cref="M:Akka.Streams.Dsl.Sink.Publisher``1"/>.
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})">
            <summary>
            Attach a <see cref="T:Akka.Streams.Dsl.Sink"/> to each sub-flow, closing the overall Graph that is being
            constructed.
            </summary>
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams">
            <summary>
            Flatten the sub-flows back into the super-flow by performing a merge
            without parallelism limit (i.e. having an unbounded number of sub-flows
            active concurrently).
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreamsWithParallelism(System.Int32)">
            <summary>
            Flatten the sub-flows back into the super-flow by performing a merge
            with the given parallelism limit. This means that only up to <paramref name="parallelism"/>
            substreams will be executed at any given time. Substreams that are not
            yet executed are also not materialized, meaning that back-pressure will
            be exerted at the operator that creates the substreams when the parallelism
            limit is reached.
            </summary>
            <param name="parallelism">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.ConcatSubstream">
            <summary>
            Flatten the sub-flows back into the super-flow by concatenating them.
            This is usually a bad idea when combined with <see cref="T:Akka.Streams.Implementation.Fusing.GroupBy`2"/>
            since it can easily lead to deadlockâ€”the concatenation does not consume from the second
            substream until the first has finished and the <see cref="T:Akka.Streams.Implementation.Fusing.GroupBy`2"/>
            stage will get back-pressure from the second stream.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.SubFlowOperations">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Recover``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``0}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para/>
            Throwing an exception inside Recover will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="partialFunc"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception pf can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.RecoverWith``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWith will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.RecoverWithRetries``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}},System.Int32)">
            <summary>
            RecoverWithRetries  allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered up to <paramref name="attempts"/> number of times so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized. Note that if you pass in 0, this won't attempt to recover at all. Passing in -1 will behave exactly the same as  <see cref="M:Akka.Streams.Dsl.SubFlowOperations.RecoverWithRetries``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}},System.Int32)"/>.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Throwing an exception inside RecoverWithRetries will be logged on ERROR level automatically.
            <para>
            Emits when element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception <paramref name="partialFunc"/> can handle
            </para>
            Cancels when downstream cancels 
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="partialFunc">Receives the failure cause and returns the new Source to be materialized if any</param>
            <param name="attempts">Maximum number of retries or -1 to retry indefinitely</param>
            <exception cref="T:System.ArgumentException">if <paramref name="attempts"/> is a negative number other than -1</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SelectError``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,System.Exception})">
            <summary>
            While similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Recover``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``0}})"/> this stage can be used to transform an error signal to a different one without logging
            it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e => throw e2) since Recover
            would log the e2 error. 
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            Similarily to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Recover``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{System.Exception,Akka.Util.Option{``0}})"/> throwing an exception inside SelectError will be logged.
            <para>
            Emits when element is available from the upstream or upstream is failed and <paramref name="selector"/> returns an element
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when upstream completes or upstream failed with exception returned by the <paramref name="selector"/>
            </para>
            Cancels when downstream cancels 
            </summary>
            <param name="flow">TBD</param>
            <param name="selector">Receives the failure cause and returns the new cause, return the original exception if no other should be applied</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Select``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given <paramref name="mapper"/> function to each of the elements
            as they pass through this processing step.
            <para>
            Emits when the mapping function <paramref name="mapper"/> returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SelectMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            Emits when the mapping function <paramref name="mapConcater"/> returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcater">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.StatefulSelectMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Transform each input element into an Enumerable of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function <paramref name="mapConcaterFactory"/> a new for every materialization —
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>.
            
            The returned Enumerable MUST NOT contain null values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            Emits when the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            Backpressures when downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            Completes when upstream completes and all remaining elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="mapConcaterFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsync``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task`1"/> and the
            value of that task will be emitted downstream. The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsync``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>.
            These tasks may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when the task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream
            backpressures or the first task is not completed
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function <paramref name="asyncMapper"/> to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that task will be emitted downstream.  The number of tasks
            that shall run in parallel is given as the first argument to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsyncUnordered``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>.
            Each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            Emits when any of the tasks returned by the provided function complete
            </para>
            <para>
            Backpressures when the number of tasks reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            Completes when upstream completes and all tasks has been completed and all elements has been emitted
            </para>
            <para>
            Cancels when downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.SelectAsync``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="parallelism">TBD</param>
            <param name="asyncMapper">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Where``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0})">
            <summary>
            Only pass on those elements that satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.WhereNot``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0})">
            <summary>
            Only pass on those elements that NOT satisfy the given <paramref name="predicate"/>.
            <para>
            Emits when the given <paramref name="predicate"/> returns true for the element
            </para>
            <para>
            Backpressures when the given <paramref name="predicate"/> returns true for the element and downstream backpressures
            </para>
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.TakeWhile``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0},System.Boolean)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after <paramref name="predicate"/>
            returns false for the first time, including the first failed element iff inclusive is true
            Due to input buffering some elements may have been requested from upstream publishers
            that will then not be processed downstream of this step.
            
            The stream will be completed without producing any elements if <paramref name="predicate"/> is false for
            the first stream element.
            <para>
            Emits when the <paramref name="predicate"/> is true
            </para>
            <para>
            Backpressures when downstream backpressures
            </para>
            <para>
            Completes when <paramref name="predicate"/> returned false (or 1 after predicate returns false if <paramref name="inclusive"/>) or upstream completes
            </para>
            <para>
            Cancels when <paramref name="predicate"/> returned false or downstream cancels
            </para>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.Limit``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)"/> <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.LimitWeighted``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64,System.Func{``0,System.Int64})"/>
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <param name="inclusive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SkipWhile``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0})">
            <summary>
            Discard elements at the beginning of the stream while <paramref name="predicate"/> is true.
            All elements will be taken after <paramref name="predicate"/> returns false first time.
            <para>
            Emits when <paramref name="predicate"/> returned false and for all following stream elements
            </para>
            Backpressures when <paramref name="predicate"/> returned false and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Collect``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given function <paramref name="collector"/> to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            Emits when the provided function <paramref name="collector"/> is defined for the element
            </para>
            Backpressures when the function <paramref name="collector"/> is defined for the element and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="collector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Grouped``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the specified number of elements has been accumulated or upstream completed
            </para>
            Backpressures when a group has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Limit``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.Take``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.TakeWithin``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.TakeWhile``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.LimitWeighted``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64,System.Func{``0,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds <paramref name="max"/>, it will signal
            upstream failure <see cref="T:Akka.Streams.StreamLimitReachedException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="max"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.Take``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.TakeWithin``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.TakeWhile``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Predicate{``0},System.Boolean)"/>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Sliding``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            Emits when enough elements have been collected within the window or upstream completed
            </para>
            Backpressures when a window has been assembled and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="step">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Scan``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Aggregate``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when the function scanning the element returns a new element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.ScanAsync``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Scan``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/> but with a asynchronous function,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>
            emitting a <see cref="T:System.Threading.Tasks.Task`1"/> that resolves to the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> current value starts at the previous
            current value, or zero when it doesn't have one, and the stream will continue.
            <para>
            Emits the <see cref="T:System.Threading.Tasks.Task`1"/> returned by <paramref name="scan"/> completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes upstream completes and the last task returned by <paramref name="scan"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="scan">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Aggregate``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Scan``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/> but only emits its result when the upstream completes,
            after which it also completes. Applies the given function <paramref name="fold"/> towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> throws an exception and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.AggregateAsync``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Aggregate``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/> but with an asynchronous function.
            Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function <paramref name="fold"/> returns a failure and the supervision decision is
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            
            <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.Aggregate``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="zero">TBD</param>
            <param name="fold">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Sum``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Aggregate``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},``1,System.Func{``1,``0,``1})"/> but uses first element as zero element.
            Applies the given function <paramref name="reduce"/> towards its current and next value,
            yielding the next current value. 
            
            If the stream is empty (i.e. completes before signaling any elements),
            the sum stage will fail its downstream with a <see cref="T:Akka.Streams.NoSuchElementException"/>,
            which is semantically in-line with that standard library collections do in such situations.
            <para>
            Emits when upstream completes
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="reduce">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Intersperse``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},``0,``0,``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="T:Akka.Streams.Dsl.Concat`2"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="start"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="start">TBD</param>
            <param name="inject">TBD</param>
            <param name="end">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Intersperse``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the intercept feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="T:Akka.Streams.Dsl.Concat`2"/> for semantics details). 
            <para>
            Emits when upstream emits (or before with the <paramref name="inject"/> element if provided)
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="inject">TBD</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is undefined.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.GroupedWithin``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            Emits when the configured time elapses since the last group has been emitted
            </para>
            Backpressures when the configured time elapses since the last group has been emitted
            <para>
            Completes when upstream completes (emits last group)
            </para>
            Cancels when downstream completes
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <param name="timeout">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Delay``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            Emits when there is a pending element in the buffer and configured time for this element elapsed
             <para/> * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            Backpressures when depending on OverflowStrategy
             <para/> * Backpressure - backpressures when buffer is full
             <para/> * DropHead, DropTail, DropBuffer - never backpressures
             <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Skip``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            Emits when the specified number of elements has been dropped already
            </para>
            Backpressures when the specified number of elements has been dropped and downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.SkipWithin``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            Emits when the specified time elapsed and a new upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Take``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            Emits when the specified number of elements to take has not yet been reached
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when the defined number of elements has been taken or upstream completes
            </para>
            Cancels when the defined number of elements has been taken or downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.TakeWithin``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Take``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            Emits when an upstream element arrives
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or timer fires
            </para>
            Cancels when downstream cancels or timer fires
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="duration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.SubFlow{``0,``1,``3},System.Func{``0,``2},System.Func{``2,``0,``2})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Conflate``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{``0,``0,``0})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TSeed">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Conflate``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Func{``0,``0,``0})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.SubFlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.SubFlow{``0,``1,``3},System.Func{``0,``2},System.Func{``2,``0,``2})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            Emits when downstream stops backpressuring and there is a conflated element available
            </para>
            Backpressures when never
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Batch``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Emits when downstream stops backpressuring and there is an aggregated element available
            
             Backpressures when there are <paramref name="max"/> batched elements and 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.SubFlow{``0,``1,``3},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.BatchWeighted``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.BatchWeighted``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate <see cref="T:Akka.IO.ByteString"/>
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the <paramref name="seed"/> function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             Emits when downstream stops backpressuring and there is a batched element available
            
             Backpressures when there are <paramref name="max"/> weighted batched elements + 1 pending element and downstream backpressures
            
             Completes when upstream completes and there is no batched/pending element waiting
            
             Cancels when downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.SubFlow{``0,``1,``3},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.Batch``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Expand``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,System.Collections.Generic.IEnumerator{``1}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="extrapolate"/> function will complete the stream with failure.
            <para>
            Emits when downstream stops backpressuring
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Buffer``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            Emits when downstream stops backpressuring and there is a pending element in the buffer
            </para>
            Backpressures when downstream backpressures or depending on OverflowStrategy:
            <para/> * Backpressure - backpressures when buffer is full
            <para/> * DropHead, DropTail, DropBuffer - never backpressures
            <para/> * Fail - fails the stream if buffer gets full
            <para>
            Completes when upstream completes and buffered elements has been drained
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Transform``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{Akka.Streams.Stage.IStage{``0,``1}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="stageFactory">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.PrefixAndTail``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            Emits when the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            Backpressures when downstream backpressures or substream backpressures
            <para>
            Completes when prefix elements has been consumed and substream has been consumed
            </para>
            Cancels when downstream cancels or substream cancels
            </summary> 
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.ConcatMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.MergeMany``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.Int32,System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a <see cref="T:Akka.Streams.Dsl.Source`2"/> of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            Emits when a currently consumed substream has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes and all consumed substreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <param name="flatten">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.ZipWithIndex``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
            <summary>
            Combine the elements of current flow into a stream of tuples consisting
            of all elements paired with their index. Indices start at 0.
            
            <para/>
            Emits when upstream emits an element and is paired with their index
            <para/>
            Backpressures when downstream backpressures
            <para/>
            Completes when upstream completes
            <para/>
            Cancels when downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.InitialTimeout``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before first element arrives
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.CompletionTimeout``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses before upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.IdleTimeout``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>. 
            The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between two emitted elements
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.BackpressureTimeout``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
            the stream is failed with a <see cref="T:System.TimeoutException"/>. The timeout is checked periodically,
            so the resolution of the check is one period (equals to timeout value).
            <para>
            Emits when upstream emits an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes or fails if timeout elapses between element emission and downstream demand.
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.KeepAlive``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},System.TimeSpan,System.Func{``1})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            Emits when upstream emits an element or if the upstream was idle for the configured period
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TInjected">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="timeout">TBD</param>
            <param name="injectElement">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Throttle``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="elements"/>/<paramref name="per"/>. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="elements">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="mode">TBD</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Throttle``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,System.Func{``0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to <paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be spared for later use up to bucket capacity
            to allow some burstiness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
            <para/> - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            Emits when upstream emits an element and configured time per each element elapsed
            </para>
            Backpressures when downstream backpressures or the incoming rate is higher than the speed limit
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="cost">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="calculateCost">TBD</param>
            <param name="mode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.AlsoToMaterialized``5(Akka.Streams.Dsl.SubFlow{``0,``1,``4},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},System.Func{``1,``2,``3})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.SubFlowOperations.AlsoTo``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="materializerFunction">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.AlsoTo``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             Emits when element is available and demand exists both from the Sink and the downstream.
            
             Backpressures when downstream or Sink backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.WatchTermination``4(Akka.Streams.Dsl.SubFlow{``0,``1,``3},System.Func{``1,System.Threading.Tasks.Task,``2})">
            <summary>
             Materializes to <see cref="T:System.Threading.Tasks.Task`1"/> that completes on getting termination message.
             The task completes with success when received complete message from upstream or cancel
             from downstream. It fails with the same error when received error message from
             downstream.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="materializerFunction">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Detach``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             Emits when upstream emits an element
            
             Backpressures when downstream backpressures
            
             Completes when upstream completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.InitialDelay``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            Emits when upstream emits an element if the initial delay is already elapsed
            </para>
            Backpressures when downstream backpressures or initial delay is not yet elapsed
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="delay">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Log``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},System.String,System.Func{``0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            Emits when the mapping function returns an element
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="name">TBD</param>
            <param name="extract">TBD</param>
            <param name="log">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Zip``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Combine the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/> into a stream of tuples.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.ZipWith``5(Akka.Streams.Dsl.SubFlow{``0,``3,``4},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``0,``1,``2})">
            <summary>
            Put together the elements of current flow and the given <see cref="T:Akka.Streams.Dsl.Source`2"/>
            into a stream of combined elements using a combiner function.
            <para>
            Emits when all of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when any upstream completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Interleave``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="other"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            Emits when element is available from the currently consumed upstream
            </para>
            Backpressures when downstream backpressures. Signal to current
            upstream, switch to next upstream when received <paramref name="segmentSize"/> elements
            <para>
            Completes when the <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="segmentSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.InterleaveMaterialized``6(Akka.Streams.Dsl.SubFlow{``0,``2,``5},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Int32,System.Func{``2,``3,``4})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/> source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
             It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
             <typeparam name="T1">TBD</typeparam>
             <typeparam name="T2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TMat2">TBD</typeparam>
             <typeparam name="TMat3">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="graph">TBD</param>
             <param name="segmentSize">TBD</param>
             <param name="combine">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Merge``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="eagerComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.MergeMaterialized``6(Akka.Streams.Dsl.SubFlow{``0,``2,``5},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.SubFlowOperations.Merge``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="that">TBD</param>
            <param name="combine">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.MergeSorted``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Func{``0,``0,System.Int32})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="orderFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.MergeSorted``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.MergeSorted``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            Emits when one of the inputs has an element available
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when all upstreams complete
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Concat``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Concatenate the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that once this
            Flow’s input is exhausted and all result elements have been generated,
            the Source’s elements will be produced.
            
            Note that the <see cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> gets upstream error - no elements from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            <para>
            Emits when element is available from current stream or from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> when current is completed
            </para>
            Backpressures when downstream backpressures
            <para>
            Completes when given <see cref="T:Akka.Streams.Dsl.Source`2"/> completes
            </para>
            Cancels when downstream cancels
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.Prepend``4(Akka.Streams.Dsl.SubFlow{``0,``2,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
             <summary>
             Prepend the given <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, meaning that before elements
             are generated from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <see cref="T:Akka.Streams.Dsl.Source`2"/> gets upstream error - no elements from this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> will be pulled.
            
             Emits when element is available from the given <see cref="T:Akka.Streams.Dsl.Source`2"/> or from current stream when the <see cref="T:Akka.Streams.Dsl.Source`2"/> is completed
            
             Backpressures when downstream backpressures
            
             Completes when this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> completes
            
             Cancels when downstream cancels
             </summary>
             <typeparam name="TOut1">TBD</typeparam>
             <typeparam name="TOut2">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="that">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlowOperations.OrElse``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
             <summary>
             Provides a secondary source that will be consumed if this stream completes without any
             elements passing by. As soon as the first element comes through this stream, the alternative
             will be cancelled.
            
             Note that this Flow will be materialized together with the <see cref="T:Akka.Streams.Dsl.Source`2"/> and just kept
             from producing elements by asserting back-pressure until its time comes or it gets
             cancelled.
            
             On errors the stage is failed regardless of source of the error.
            
             '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                              is available from the second stream
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                                  without emitting and the secondary stream already has completed or when the secondary stream completes
            
             '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                                by from this stream.
             </summary>
             <typeparam name="T">TBD</typeparam>
             <typeparam name="TMat">TBD</typeparam>
             <typeparam name="TClosed">TBD</typeparam>
             <param name="flow">TBD</param>
             <param name="secondary">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.ServerBinding">
            <summary>
            Represents a successful TCP server binding.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.ServerBinding.#ctor(System.Net.EndPoint,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Tcp.ServerBinding"/> class.
            </summary>
            <param name="localAddress">TBD</param>
            <param name="unbindAction">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.ServerBinding.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.ServerBinding.Unbind">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.IncomingConnection">
            <summary>
            Represents an accepted incoming TCP connection.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.IncomingConnection.#ctor(System.Net.EndPoint,System.Net.EndPoint,Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,Akka.NotUsed})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Tcp.IncomingConnection"/> class.
            </summary>
            <param name="localAddress">TBD</param>
            <param name="remoteAddress">TBD</param>
            <param name="flow">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.IncomingConnection.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.IncomingConnection.RemoteAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.IncomingConnection.Flow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.IncomingConnection.HandleWith``1(Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,``0},Akka.Streams.IMaterializer)">
            <summary>
            Handles the connection using the given flow, which is materialized exactly once and the respective
            materialized instance is returned.
            <para/>
            Convenience shortcut for: flow.join(handler).run().
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="handler">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.OutgoingConnection">
            <summary>
            Represents a prospective outgoing TCP connection.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.OutgoingConnection.#ctor(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.Tcp.OutgoingConnection"/> class.
            </summary>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.OutgoingConnection.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.Tcp.OutgoingConnection.RemoteAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.TcpExt">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Dsl.TcpExt"/> class.
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="F:Akka.Streams.Dsl.TcpExt.BindShutdownTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.Bind(System.String,System.Int32,System.Int32,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.ServerBinding"/> instance which represents a prospective TCP server binding on the given <paramref name="host"/> and <paramref name="port"/>/>.
            <para/>
            Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
            <see cref="T:Akka.Streams.Dsl.RunnableGraph`1"/> the server is not immediately available. Only after the materialized future
            completes is the server ready to accept client connections.
            </summary>
            <param name="host">The host to listen on</param>
            <param name="port">The port to listen on</param>
            <param name="backlog">Controls the size of the connection backlog</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose">Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
            write to the connection even after the server has finished writing. The TCP socket is only closed
            after both the client and server finished writing.
            If set to false, the connection will immediately closed once the server closes its write side,
            independently whether the client is still attempting to write. This setting is recommended
            for servers, and therefore it is the default setting.
            </param>
            <param name="idleTimeout">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.BindAndHandle(Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,Akka.NotUsed},Akka.Streams.IMaterializer,System.String,System.Int32,System.Int32,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.ServerBinding"/> instance which represents a prospective TCP server binding on the given <paramref name="host"/> and <paramref name="port"/>/>
            handling the incoming connections using the provided Flow.
            <para/>
            Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
            <see cref="T:Akka.Streams.Dsl.RunnableGraph`1"/> the server is not immediately available. Only after the materialized future
            completes is the server ready to accept client connections.
            </summary>
            <param name="handler">A Flow that represents the server logic</param>
            <param name="materializer">TBD</param>
            <param name="host">The host to listen on</param>
            <param name="port">The port to listen on</param>
            <param name="backlog">Controls the size of the connection backlog</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose">Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
            write to the connection even after the server has finished writing. The TCP socket is only closed
            after both the client and server finished writing.
            If set to false, the connection will immediately closed once the server closes its write side,
            independently whether the client is still attempting to write. This setting is recommended
            for servers, and therefore it is the default setting.
            </param>
            <param name="idleTimeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.OutgoingConnection(System.Net.EndPoint,System.Net.EndPoint,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.OutgoingConnection"/> instance representing a prospective TCP client connection to the given endpoint.
            <para>
            Note that the <see cref="T:Akka.IO.ByteString"/> chunk boundaries are not retained across the network,
            to achieve application level chunks you have to introduce explicit framing in your streams,
            for example using the <see cref="T:Akka.Streams.Dsl.Framing"/> stages.
            </para>
            </summary>
            <param name="remoteAddress"> The remote address to connect to</param>
            <param name="localAddress">Optional local address for the connection</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose"> Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the server to
            write to the connection even after the client has finished writing.The TCP socket is only closed
            after both the client and server finished writing. This setting is recommended for clients and therefore it is the default setting.
            If set to false, the connection will immediately closed once the client closes its write side,
            independently whether the server is still attempting to write.
            </param>
            <param name="connectionTimeout">TBD</param>
            <param name="idleTimeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.OutgoingConnection(System.String,System.Int32)">
            <summary>
            Creates an <see cref="T:Akka.Streams.Dsl.Tcp.OutgoingConnection"/> without specifying options.
            It represents a prospective TCP client connection to the given endpoint.
            <para>
            Note that the <see cref="T:Akka.IO.ByteString"/> chunk boundaries are not retained across the network,
            to achieve application level chunks you have to introduce explicit framing in your streams,
            for example using the <see cref="T:Akka.Streams.Dsl.Framing"/> stages.
            </para>
            </summary>
            <param name="host">TBD</param>
            <param name="port">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.TcpStreamExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpStreamExtensions.TcpStream(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.SwitchMode">
            <summary>
            Mode for <see cref="T:Akka.Streams.Dsl.IValveSwitch"/>
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.IValveSwitch">
            <summary>
            Pause/resume a Flow
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IValveSwitch.Flip(Akka.Streams.Dsl.SwitchMode)">
            <summary>
            Change the state of the valve
            </summary>
            <param name="mode">expected mode to switch on</param>
            <returns>A task that completes with true if the mode did change and false if it already was in the requested mode</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.IValveSwitch.GetMode">
            <summary>
            Obtain the state of the valve
            </summary>
            <returns>A task that completes with <see cref="T:Akka.Streams.Dsl.SwitchMode"/> to indicate the current state of the valve</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Valve`1">
            <summary>
            Materializes into a task of <see cref="T:Akka.Streams.Dsl.IValveSwitch"/> which provides a the method flip that stops or restarts the flow of elements passing through the stage. 
            As long as the valve is closed it will backpressure.
            Note that closing the valve could result in one element being buffered inside the stage, and if the stream completes or fails while being closed, that element may be lost.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Valve`1.#ctor">
            <summary>
            Creates already open <see cref="T:Akka.Streams.Dsl.Valve`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Valve`1.#ctor(Akka.Streams.Dsl.SwitchMode)">
            <summary>
            Creates <see cref="T:Akka.Streams.Dsl.Valve`1"/> with inital <paramref name="mode"/>
            </summary>
            <param name="mode">state of the valve at the startup of the flow</param>
        </member>
        <member name="T:Akka.Streams.FanInShapeN`3">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShapeN`3.N">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShapeN`3.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShapeN`3.In1s">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.#ctor(System.Int32,Akka.Streams.FanInShape{`2}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.#ctor(System.Int32,System.String)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.#ctor(Akka.Streams.Outlet{`2},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1}[])">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="inlets">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="n" /> is less than or equal to zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShapeN`3.Construct(Akka.Streams.FanInShape{`2}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`3">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`3.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`3.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`3.#ctor(Akka.Streams.FanInShape{`2}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`3.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`3.#ctor(Akka.Streams.Outlet{`2},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`3.Construct(Akka.Streams.FanInShape{`2}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`4">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`4.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`4.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`4.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`4.#ctor(Akka.Streams.FanInShape{`3}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`4.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`4.#ctor(Akka.Streams.Outlet{`3},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`4.Construct(Akka.Streams.FanInShape{`3}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`5">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`5.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`5.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`5.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`5.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`5.#ctor(Akka.Streams.FanInShape{`4}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`5.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`5.#ctor(Akka.Streams.Outlet{`4},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`5.Construct(Akka.Streams.FanInShape{`4}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`6">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`6.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`6.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`6.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`6.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`6.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`6.#ctor(Akka.Streams.FanInShape{`5}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`6.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`6.#ctor(Akka.Streams.Outlet{`5},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3},Akka.Streams.Inlet{`4})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <param name="in4">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`6.Construct(Akka.Streams.FanInShape{`5}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`7">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`7.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`7.#ctor(Akka.Streams.FanInShape{`6}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`7.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`7.#ctor(Akka.Streams.Outlet{`6},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3},Akka.Streams.Inlet{`4},Akka.Streams.Inlet{`5})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <param name="in4">TBD</param>
            <param name="in5">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`7.Construct(Akka.Streams.FanInShape{`6}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`8">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`8.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`8.#ctor(Akka.Streams.FanInShape{`7}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`8.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`8.#ctor(Akka.Streams.Outlet{`7},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3},Akka.Streams.Inlet{`4},Akka.Streams.Inlet{`5},Akka.Streams.Inlet{`6})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <param name="in4">TBD</param>
            <param name="in5">TBD</param>
            <param name="in6">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`8.Construct(Akka.Streams.FanInShape{`7}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`9">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`9.In7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`9.#ctor(Akka.Streams.FanInShape{`8}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`9.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`9.#ctor(Akka.Streams.Outlet{`8},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3},Akka.Streams.Inlet{`4},Akka.Streams.Inlet{`5},Akka.Streams.Inlet{`6},Akka.Streams.Inlet{`7})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <param name="in4">TBD</param>
            <param name="in5">TBD</param>
            <param name="in6">TBD</param>
            <param name="in7">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`9.Construct(Akka.Streams.FanInShape{`8}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`10">
            <summary>
            TBD
            </summary>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanInShape`10.In8">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`10.#ctor(Akka.Streams.FanInShape{`9}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`10.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`10.#ctor(Akka.Streams.Outlet{`9},Akka.Streams.Inlet{`0},Akka.Streams.Inlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Inlet{`3},Akka.Streams.Inlet{`4},Akka.Streams.Inlet{`5},Akka.Streams.Inlet{`6},Akka.Streams.Inlet{`7},Akka.Streams.Inlet{`8})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="in0">TBD</param>
            <param name="in1">TBD</param>
            <param name="in2">TBD</param>
            <param name="in3">TBD</param>
            <param name="in4">TBD</param>
            <param name="in5">TBD</param>
            <param name="in6">TBD</param>
            <param name="in7">TBD</param>
            <param name="in8">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`10.Construct(Akka.Streams.FanInShape{`9}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`3.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`3.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`3.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`3.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`3.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`3.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`4">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`4.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`4.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`4.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`4.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`4.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`4.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`4.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`5.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`5.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`5.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`5.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`5.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`5.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`5.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`5.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`6">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`6.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`6.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`6.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`6.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`6.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`6.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`6.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`6.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4},Akka.Streams.Outlet{`5})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
            <param name="out4">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`6.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`7">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`7.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`7.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`7.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`7.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4},Akka.Streams.Outlet{`5},Akka.Streams.Outlet{`6})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
            <param name="out4">TBD</param>
            <param name="out5">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`7.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`8">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`8.Out6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`8.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`8.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`8.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4},Akka.Streams.Outlet{`5},Akka.Streams.Outlet{`6},Akka.Streams.Outlet{`7})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
            <param name="out4">TBD</param>
            <param name="out5">TBD</param>
            <param name="out6">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`8.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`9">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`9.Out7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`9.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`9.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`9.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4},Akka.Streams.Outlet{`5},Akka.Streams.Outlet{`6},Akka.Streams.Outlet{`7},Akka.Streams.Outlet{`8})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
            <param name="out4">TBD</param>
            <param name="out5">TBD</param>
            <param name="out6">TBD</param>
            <param name="out7">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`9.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`10">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="T0">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out0">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out3">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out5">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out7">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.FanOutShape`10.Out8">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`10.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`10.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`10.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Outlet{`2},Akka.Streams.Outlet{`3},Akka.Streams.Outlet{`4},Akka.Streams.Outlet{`5},Akka.Streams.Outlet{`6},Akka.Streams.Outlet{`7},Akka.Streams.Outlet{`8},Akka.Streams.Outlet{`9})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="out0">TBD</param>
            <param name="out1">TBD</param>
            <param name="out2">TBD</param>
            <param name="out3">TBD</param>
            <param name="out4">TBD</param>
            <param name="out5">TBD</param>
            <param name="out6">TBD</param>
            <param name="out7">TBD</param>
            <param name="out8">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`10.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Construct">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Construct.Instantiate(System.Type,System.Type,System.Object[])">
            <summary>
            TBD
            </summary>
            <param name="genericType">TBD</param>
            <param name="genericParam">TBD</param>
            <param name="constructorArgs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Construct.Instantiate(System.Type,System.Type[],System.Object[])">
            <summary>
            TBD
            </summary>
            <param name="genericType">TBD</param>
            <param name="genericParams">TBD</param>
            <param name="constructorArgs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.TimedSourceDsl">
            <summary>
            Provides time measurement utilities on Stream elements.
            
            See <see cref="T:Akka.Streams.Extra.Timed"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedSourceDsl.Timed``4(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``1,``3}},System.Action{System.TimeSpan})">
            <summary>
            Measures time from receiving the first element and completion events - one for each subscriber of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="measuredOps">TBD</param>
            <param name="onComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Extra.TimedSourceDsl.TimedIntervalBetween``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            Measures rolling interval between immediately subsequent "matching(o: O)" elements.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="matching">TBD</param>
            <param name="onInterval">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.TimedFlowDsl">
            <summary>
            Provides time measurement utilities on Stream elements.
            
            See <see cref="T:Akka.Streams.Extra.Timed"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedFlowDsl.Timed``5(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.Dsl.Flow{``0,``2,``4}},System.Action{System.TimeSpan})">
            <summary>
            Measures time from receiving the first element and completion events - one for each subscriber of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="measuredOps">TBD</param>
            <param name="onComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Extra.TimedFlowDsl.TimedIntervalBetween``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            Measures rolling interval between immediately subsequent "matching(o: O)" elements.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="matching">TBD</param>
            <param name="onInterval">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.TimedOps">
            <summary>
            INTERNAL API
            
            Provides operations needed to implement the <see cref="T:Akka.Streams.Extra.TimedFlowDsl"/> and <see cref="T:Akka.Streams.Extra.TimedSourceDsl"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedOps.Timed``4(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``1,``3}},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures time from receiving the first element and completion events - one for each subscriber of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="measuredOps">TBD</param>
            <param name="onComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Extra.TimedOps.Timed``5(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.Dsl.Flow{``0,``2,``4}},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures time from receiving the first element and completion events - one for each subscriber of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="measuredOps">TBD</param>
            <param name="onComplete">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.TimedIntervalBetweenOps">
            <summary>
            INTERNAL API
            
            Provides operations needed to implement the <see cref="T:Akka.Streams.Extra.TimedFlowDsl"/> and <see cref="T:Akka.Streams.Extra.TimedSourceDsl"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedIntervalBetweenOps.TimedIntervalBetween``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures rolling interval between immediately subsequent `matching(o: O)` elements.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="matching">TBD</param>
            <param name="onInterval">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.Timed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Extra.Timed.TimedFlowContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.TimedFlowContext.Start">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.TimedFlowContext.Stop">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.Timed.StartTimed`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.StartTimed`1.#ctor(Akka.Streams.Extra.Timed.TimedFlowContext)">
            <summary>
            TBD
            </summary>
            <param name="timedContext">TBD</param>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.StartTimed`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.Timed.StopTime`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.StopTime`1.#ctor(Akka.Streams.Extra.Timed.TimedFlowContext,System.Action{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="timedContext">TBD</param>
            <param name="onComplete">TBD</param>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.StopTime`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Extra.Timed.TimedInterval`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.TimedInterval`1.#ctor(System.Func{`0,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="matching">TBD</param>
            <param name="onInterval">TBD</param>
        </member>
        <member name="M:Akka.Streams.Extra.Timed.TimedInterval`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanInShape`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.FanInShape`1.IInit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.IInit.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.IInit.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.IInit.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FanInShape`1.InitName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.InitName.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitName.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitName.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitName.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FanInShape`1.InitPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.InitPorts.#ctor(Akka.Streams.Outlet{`0},System.Collections.Generic.IEnumerable{Akka.Streams.Inlet})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="inlets">TBD</param>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitPorts.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitPorts.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.InitPorts.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.#ctor(Akka.Streams.Outlet{`0},System.Collections.Generic.IEnumerable{Akka.Streams.Inlet},System.String)">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="registered">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.#ctor(Akka.Streams.FanInShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.Construct(Akka.Streams.FanInShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.NewInlet``1(System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanInShape`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanInShape`1.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.UniformFanInShape`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.UniformFanInShape`2.N">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.#ctor(System.Int32,Akka.Streams.FanInShape{`1}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.#ctor(System.Int32,System.String)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.#ctor(Akka.Streams.Outlet{`1},Akka.Streams.Inlet{`0}[])">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <param name="inlets">TBD</param>
        </member>
        <member name="P:Akka.Streams.UniformFanInShape`2.Ins">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.In(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UniformFanInShape`2.Construct(Akka.Streams.FanInShape{`1}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.FanOutShape`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.FanOutShape`1.IInit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.IInit.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.IInit.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.IInit.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FanOutShape`1.InitName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.InitName.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitName.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitName.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitName.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FanOutShape`1.InitPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.InitPorts.#ctor(Akka.Streams.Inlet{`0},System.Collections.Generic.IEnumerable{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitPorts.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitPorts.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.InitPorts.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.#ctor(Akka.Streams.Inlet{`0},System.Collections.Generic.IEnumerable{Akka.Streams.Outlet},System.String)">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="registered">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.#ctor(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FanOutShape`1.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.NewOutlet``1(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FanOutShape`1.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.UniformFanOutShape`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.#ctor(System.Int32,Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="init">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.#ctor(System.Int32,System.String)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1}[])">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="outlets">TBD</param>
        </member>
        <member name="P:Akka.Streams.UniformFanOutShape`2.Outs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.Out(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UniformFanOutShape`2.Construct(Akka.Streams.FanOutShape{`0}.IInit)">
            <summary>
            TBD
            </summary>
            <param name="init">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IFlowMonitor">
            <summary>
            Used to monitor the state of a stream
            </summary>
        </member>
        <member name="P:Akka.Streams.IFlowMonitor.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor.IStreamState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor.Initialized">
            <summary>
            Stream was created, but no events have passed through it
            </summary>
        </member>
        <member name="P:Akka.Streams.FlowMonitor.Initialized.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor.Received`1">
            <summary>
            Stream processed a message
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.FlowMonitor.Received`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.FlowMonitor.Received`1"/> class.
            </summary>
            <param name="message">The processed message</param>
        </member>
        <member name="P:Akka.Streams.FlowMonitor.Received`1.Message">
            <summary>
            The processed message
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor.Failed">
            <summary>
            Stream failed
            </summary>
        </member>
        <member name="M:Akka.Streams.FlowMonitor.Failed.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.FlowMonitor.Failed"/> class.
            </summary>
            <param name="cause">The cause of the failure</param>
        </member>
        <member name="P:Akka.Streams.FlowMonitor.Failed.Cause">
            <summary>
            The cause of the failure
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowMonitor.Finished">
            <summary>
            Stream completed successfully
            </summary>
        </member>
        <member name="P:Akka.Streams.FlowMonitor.Finished.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Fusing">
            <summary>
             This class holds some graph transformation functions that can fuse together
             multiple operation stages into synchronous execution islands. The purpose is
             to reduce the number of Actors that are created in order to execute the stream
             and thereby improve start-up cost as well as reduce element traversal latency
             for large graphs. Fusing itself is a time-consuming operation, meaning that
             usually it is best to cache the result of this computation and reuse it instead
             of fusing the same graph many times.
            
             Fusing together all operations which allow this treatment will reduce the
             parallelism that is available in the stream graphâ€™s executionâ€”in the worst case
             it will become single-threaded and not benefit from multiple CPU cores at all.
             Where parallelism is required, the <see cref="T:Akka.Streams.Attributes.AsyncBoundary"/>
             attribute can be used to declare subgraph boundaries across which the graph
             shall not be fused.
            </summary>
        </member>
        <member name="M:Akka.Streams.Fusing.Aggressive``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Fuse all operations where this is technically possible (i.e. all
            implementations based on <see cref="T:Akka.Streams.Stage.GraphStage`1"/>) and not forbidden
            via <see cref="T:Akka.Streams.Attributes.AsyncBoundary"/>
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Fusing.StructuralInfo``2(Akka.Streams.IGraph{``0,``1},Akka.Streams.Attributes)">
            <summary>
            Return the StructuralInfo for this Graph without any fusing
            </summary>
        </member>
        <member name="T:Akka.Streams.Fusing.FusedGraph`2">
            <summary>
            A fused graph of the right shape, containing a <see cref="T:Akka.Streams.Implementation.FusedModule"/> which holds more information 
            on the operation structure of the contained stream topology for convenient graph traversal.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Fusing.FusedGraph`2.#ctor(Akka.Streams.Implementation.FusedModule,`0)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <param name="shape">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.Fusing.FusedGraph`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Fusing.FusedGraph`2.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Fusing.FusedGraph`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Fusing.FusedGraph`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Fusing.FusedGraph`2.Named(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Fusing.FusedGraph`2.Async">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IGraph`1">
            <summary>
            </summary>
            <typeparam name="TShape">Type-level accessor for the shape parameter of this graph.</typeparam>
        </member>
        <member name="P:Akka.Streams.IGraph`1.Shape">
            <summary>
            The shape of a graph is all that is externally visible: its inlets and outlets.
            </summary>
        </member>
        <member name="P:Akka.Streams.IGraph`1.Module">
            <summary>
            INTERNAL API: Every materializable element must be backed by a stream layout module
            </summary>
        </member>
        <member name="T:Akka.Streams.IGraph`2">
            <summary>
            </summary>
            <typeparam name="TShape">Type-level accessor for the shape parameter of this graph.</typeparam>
            <typeparam name="TMaterialized">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.IGraph`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.IGraph`1"/> to the given ones
            and seal the list of attributes. This means that further calls will not be able
            to remove these attributes, but instead add new ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.IGraph`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.IGraph`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.IGraph`2.Named(System.String)">
            <summary>
            Add a name attribute to this Graph.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.IGraph`2.Async">
            <summary>
            Put an asynchronous boundary around this Graph.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.GraphDelegate`2">
            <summary>
            Allows creating additional API on top of an existing Graph by extending from this class and
            accessing the delegate
            </summary>
            <typeparam name="TShape"></typeparam>
            <typeparam name="TMat"></typeparam>
        </member>
        <member name="T:Akka.Streams.IMaterializer">
            <summary>
            Materializer SPI (Service Provider Interface) 
            
            Custom materializer implementations should be aware that the materializer SPI
            is not yet final and may change in patch releases of Akka. Please note that this
            does not impact end-users of Akka streams, only implementors of custom materializers,
            with whom the Akka.Net team co-ordinates such changes.
            
            Once the SPI is final this notice will be removed.
            </summary>
        </member>
        <member name="M:Akka.Streams.IMaterializer.WithNamePrefix(System.String)">
            <summary>
            The <paramref name="namePrefix"/> shall be used for deriving the names of processing
            entities that are created during materialization. This is meant to aid
            logging and failure reporting both during materialization and while the
            stream is running.
            </summary>
            <param name="namePrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.IMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            This method interprets the given Flow description and creates the running
            stream. The result can be highly implementation specific, ranging from
            local actor chains to remote-deployed processing networks.
            </summary>
            <typeparam name="TMat">The type of the materialized value</typeparam>
            <param name="runnable">The flow that should be materialized.</param>
            <returns>The materialized value</returns>
        </member>
        <member name="M:Akka.Streams.IMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},Akka.Streams.Attributes)">
            <summary>
            This method interprets the given Flow description and creates the running
            stream using an explicitly provided <see cref="T:Akka.Streams.Attributes"/> as top level attributes.
            stream. The result can be highly implementation specific, ranging from
            local actor chains to remote-deployed processing networks.
            </summary>
            <typeparam name="TMat">The type of the materialized value</typeparam>
            <param name="runnable">The flow that should be materialized.</param>
            <param name="initialAttributes">The initialAttributes for this materialization</param>
            <returns>The materialized value</returns>
        </member>
        <member name="M:Akka.Streams.IMaterializer.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            Interface for stages that need timer services for their functionality. Schedules a
            single task with the given delay.
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <returns>
            A <see cref="T:Akka.Actor.ICancelable"/> that allows cancelling the timer. Cancelling is best effort, 
            if the event has been already enqueued it will not have an effect.
            </returns>
        </member>
        <member name="M:Akka.Streams.IMaterializer.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Interface for stages that need timer services for their functionality. Schedules a
            repeated task with the given interval between invocations.
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <returns>
            A <see cref="T:Akka.Actor.ICancelable"/> that allows cancelling the timer. Cancelling is best effort, 
            if the event has been already enqueued it will not have an effect.
            </returns>
        </member>
        <member name="P:Akka.Streams.IMaterializer.ExecutionContext">
            <summary>
            Running a flow graph will require execution resources, as will computations
            within Sources, Sinks, etc. This <see cref="T:Akka.Dispatch.MessageDispatcher"/>
            can be used by parts of the flow to submit processing jobs for execution,
            run Future callbacks, etc.
            </summary>
        </member>
        <member name="T:Akka.Streams.NoMaterializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.NoMaterializer.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.NoMaterializer.WithNamePrefix(System.String)">
            <summary>
            N/A
            </summary>
            <param name="name">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> cannot be named.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Streams.NoMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            N/A
            </summary>
            <typeparam name="TMat">N/A</typeparam>
            <param name="runnable">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> cannot be materialized.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Streams.NoMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},Akka.Streams.Attributes)">
            <summary>
            N/A
            </summary>
            <typeparam name="TMat">N/A</typeparam>
            <param name="runnable">N/A</param>
            <param name="initialAttributes">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> cannot be materialized.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Streams.NoMaterializer.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            N/A
            </summary>
            <param name="delay">N/A</param>
            <param name="action">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> cannot schedule an event.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Streams.NoMaterializer.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            N/A
            </summary>
            <param name="initialDelay">N/A</param>
            <param name="interval">N/A</param>
            <param name="action">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> cannot schedule a repeatable event.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="P:Akka.Streams.NoMaterializer.ExecutionContext">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Streams.NoMaterializer"/> does not provide an execution context.
            </exception>
        </member>
        <member name="T:Akka.Streams.MaterializationContext">
            <summary>
            Context parameter to the create methods of sources and sinks.
            </summary>
        </member>
        <member name="F:Akka.Streams.MaterializationContext.Materializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.MaterializationContext.EffectiveAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.MaterializationContext.StageName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.MaterializationContext.#ctor(Akka.Streams.IMaterializer,Akka.Streams.Attributes,System.String)">
            <summary>
            TBD
            </summary>
            <param name="materializer">TBD</param>
            <param name="effectiveAttributes">TBD</param>
            <param name="stageName">TBD</param>
        </member>
        <member name="T:Akka.Streams.IMaterializerLoggingProvider">
            <summary>
            SPI intended only to be extended by custom <see cref="T:Akka.Streams.IMaterializer"/> implementations,
            that also want to provide stages they materialize with specialized <see cref="T:Akka.Event.ILoggingAdapter"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Streams.IMaterializerLoggingProvider.MakeLogger(System.Object)">
            <summary>
            Creates a new logging adapter.
            </summary>
            <param name="logSource">The source that produces the log events.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ExtendedActorMaterializer">
            <summary>
            ExtendedActorMaterializer used by subtypes which materializer using GraphInterpreterShell
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ExtendedActorMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},System.Func{Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Actor.IActorRef})">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="subFlowFuser">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ExtendedActorMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},System.Func{Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Actor.IActorRef},Akka.Streams.Attributes)">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="subFlowFuser">TBD</param>
            <param name="initialAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ExtendedActorMaterializer.ActorOf(Akka.Streams.MaterializationContext,Akka.Actor.Props)">
            <summary>
            INTERNAL API
            </summary>
            <param name="context">TBD</param>
            <param name="props">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ExtendedActorMaterializer.ActorOf(Akka.Actor.Props,System.String,System.String)">
            <summary>
            INTERNAL API
            </summary>
            <param name="props">TBD</param>
            <param name="name">TBD</param>
            <param name="dispatcher">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorMaterializerImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.#ctor(Akka.Actor.ActorSystem,Akka.Streams.ActorMaterializerSettings,Akka.Dispatch.Dispatchers,Akka.Actor.IActorRef,Akka.Util.AtomicBoolean,Akka.Streams.Implementation.EnumerableActorName)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="settings">TBD</param>
            <param name="dispatchers">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="haveShutDown">TBD</param>
            <param name="flowNames">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.IsShutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.Supervisor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.Logger">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.WithNamePrefix(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.EffectiveSettings(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},System.Func{Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Actor.IActorRef})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="subFlowFuser">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="initialAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},System.Func{Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Actor.IActorRef},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="subFlowFuser">TBD</param>
            <param name="initialAttributes">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.MakeLogger(System.Object)">
            <summary>
            Creates a new logging adapter.
            </summary>
            <param name="logSource">The source that produces the log events.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorMaterializerImpl.ExecutionContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorMaterializerImpl.Shutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubFusingActorMaterializerImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.#ctor(Akka.Streams.Implementation.ExtendedActorMaterializer,System.Func{Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Actor.IActorRef})">
            <summary>
            TBD
            </summary>
            <param name="delegateMaterializer">TBD</param>
            <param name="registerShell">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.WithNamePrefix(System.String)">
            <summary>
            TBD
            </summary>
            <param name="namePrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <param name="runnable">TBD</param>
            <param name="initialAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.SubFusingActorMaterializerImpl.ExecutionContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FlowNameCounter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FlowNameCounter.Instance(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.FlowNameCounter.Counter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FlowNameCounter.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.Materialize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.Materialize.Props">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.Materialize.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.Materialize.#ctor(Akka.Actor.Props,System.String)">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.GetChildren">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.GetChildren.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.StopChildren">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.StopChildren.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.StoppedChildren">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.StoppedChildren.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.PrintDebugDump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.PrintDebugDump.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamSupervisor.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.Children.Refs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.Children.#ctor(System.Collections.Immutable.IImmutableSet{Akka.Actor.IActorRef})">
            <summary>
            TBD
            </summary>
            <param name="refs">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.Props(Akka.Streams.ActorMaterializerSettings,Akka.Util.AtomicBoolean)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="haveShutdown">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.NextName">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamSupervisor.HaveShutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.#ctor(Akka.Streams.ActorMaterializerSettings,Akka.Util.AtomicBoolean)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="haveShutdown">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamSupervisor.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorProcessor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor.Create``2(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <param name="impl">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorProcessor`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="impl">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessor`2.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.BatchingInputBuffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.BatchingInputBuffer.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.BatchingInputBuffer.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.#ctor(System.Int32,Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
            <param name="pump">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="count"/> is either less than or equal to zero or is not a power of two.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.DequeueInputElement">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.EnqueueInputElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.NeedsInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.NeedsInputOrComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.IsOpen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.AreInputsDepleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BatchingInputBuffer.AreInputsAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="subscription"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.WaitingForUpstream(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.UpstreamRunning(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.Completed(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BatchingInputBuffer.InputOnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.SimpleOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.ExposedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.DownstreamDemand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SimpleOutputs.IsDownstreamCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.#ctor(Akka.Actor.IActorRef,Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="pump">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.IsSubscribed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.NeedsDemand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.NeedsDemandOrCancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.DemandCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.IsDemandAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.EnqueueOutputElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.Complete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.Error(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SimpleOutputs.IsOpen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.CreateSubscription">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.WaitingExposedPublisher(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SimpleOutputs.DownstreamRunning(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorProcessorImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorProcessorImpl.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.PrimaryInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.PrimaryOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.#ctor(Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.CurrentAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorProcessorImpl.IsPumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.Receive(System.Object)">
            <summary>
            Subclass may override <see cref="M:Akka.Streams.Implementation.ActorProcessorImpl.ActiveReceive(System.Object)"/>
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.ActiveReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.InitialPhase(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.WaitForUpstream(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.GotUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.NextPhase(Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.PumpFailed(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscribePending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SubscribePending.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.RequestMore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.RequestMore.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.RequestMore.Demand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.RequestMore.#ctor(Akka.Streams.Implementation.IActorSubscription,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <param name="demand">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Cancel.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Cancel.#ctor(Akka.Streams.Implementation.IActorSubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.ExposedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ExposedPublisher.Publisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ExposedPublisher.#ctor(Akka.Streams.Implementation.IActorPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.NormalShutdownException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.NormalShutdownException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.NormalShutdownException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IActorPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IActorPublisher.Shutdown(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IActorPublisher.TakePendingSubscribers">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorPublisher.NormalShutdownReasonMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorPublisher.NormalShutdownReason">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorPublisher`1">
            <summary>
            INTERNAL API
            
            When you instantiate this class, or its subclasses, you MUST send an ExposedPublisher message to the wrapped
            ActorRef! If you don't need to subclass, prefer the apply() method on the companion object which takes care of this.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorPublisher`1.Impl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorPublisher`1.WakeUpMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisher`1.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="impl">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisher`1.TakePendingSubscribers">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisher`1.Shutdown(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IActorSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscription.Create(Akka.Actor.IActorRef,Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="implementor">TBD</param>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscription.Create``1(Akka.Actor.IActorRef,Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="implementor">TBD</param>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorSubscription`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorSubscription`1.Implementor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorSubscription`1.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscription`1.#ctor(Akka.Actor.IActorRef,Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="implementor">TBD</param>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscription`1.Request(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscription`1.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.#ctor(Akka.Actor.IActorRef,Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="implementor">TBD</param>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.Dispatch(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.IsActive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.Cursor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.TotalDemand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriptionWithCursor`1.Dispatch(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1.#ctor(Akka.Actor.IActorRef,System.Object,System.Object,System.Object,System.Func{System.Exception,System.Object})">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <param name="onInitMessage">TBD</param>
            <param name="ackMessage">TBD</param>
            <param name="onCompleteMessage">TBD</param>
            <param name="onFailureMessage">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefSinkActor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSinkActor.Props(Akka.Actor.IActorRef,System.Int32,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
            <param name="highWatermark">TBD</param>
            <param name="onCompleteMessage">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSinkActor.HighWatermark">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSinkActor.Ref">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSinkActor.OnCompleteMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSinkActor.#ctor(Akka.Actor.IActorRef,System.Int32,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
            <param name="highWatermark">TBD</param>
            <param name="onCompleteMessage">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSinkActor.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSinkActor.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSinkActor.RequestStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefSourceActor`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.Props(System.Int32,Akka.Streams.OverflowStrategy,Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <param name="bufferSize">TBD</param>
            <param name="overflowStrategy">TBD</param>
            <param name="settings">TBD</param>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown when the specified <paramref name="overflowStrategy"/> is <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSourceActor`1.Buffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSourceActor`1.BufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ActorRefSourceActor`1.OverflowStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.#ctor(System.Int32,Akka.Streams.OverflowStrategy,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="bufferSize">TBD</param>
            <param name="overflowStrategy">TBD</param>
            <param name="maxFixedBufferSize">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSourceActor`1.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.DefaultReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.RequestElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSourceActor`1.ReceiveElement(`0)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IBuffer`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Implementation.IBuffer`1.Capacity">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IBuffer`1.Used">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IBuffer`1.IsFull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IBuffer`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IBuffer`1.NonEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.Enqueue(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.Dequeue">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.Peek">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.DropHead">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IBuffer`1.DropTail">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Buffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Buffer.Create``1(System.Int32,Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="size">TBD</param>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Buffer.Create``1(System.Int32,Akka.Streams.IMaterializer)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="size">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Buffer.Create``1(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="size">TBD</param>
            <param name="max">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FixedSizeBuffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer.Create``1(System.Int32)">
            <summary>
            INTERNAL API
            
            Returns a fixed size buffer backed by an array. The buffer implementation DOES NOT check against overflow or
            underflow, it is the responsibility of the user to track or check the capacity of the buffer before enqueueing
            dequeueing or dropping.
            
            Returns a specialized instance for power-of-two sized buffers.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="size">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="size"/> is less than 1.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FixedSizeBuffer`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.FixedSizeBuffer`1.ReadIndex">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FixedSizeBuffer`1.WriteIndex">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="capacity">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.FixedSizeBuffer`1.Capacity">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FixedSizeBuffer`1.Used">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FixedSizeBuffer`1.IsFull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FixedSizeBuffer`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FixedSizeBuffer`1.NonEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.ToOffset(System.Int64,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <param name="maintenance">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Enqueue(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Put(System.Int64,`0,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <param name="element">TBD</param>
            <param name="maintenance">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Get(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Peek">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Dequeue">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.DropHead">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer`1.DropTail">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ModuloFixedSizeBuffer`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ModuloFixedSizeBuffer`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ModuloFixedSizeBuffer`1.ToOffset(System.Int64,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <param name="maintenance">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.PowerOfTwoFixedSizeBuffer`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.PowerOfTwoFixedSizeBuffer`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.PowerOfTwoFixedSizeBuffer`1.ToOffset(System.Int64,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <param name="maintenance">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.BoundedBuffer`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="capacity">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.BoundedBuffer`1.Capacity">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BoundedBuffer`1.Used">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BoundedBuffer`1.IsFull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BoundedBuffer`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.BoundedBuffer`1.NonEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.Enqueue(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.Dequeue">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.Peek">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.DropHead">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BoundedBuffer`1.DropTail">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.EmptyPublisher`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.EmptyPublisher`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyPublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyPublisher`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ErrorPublisher`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.ErrorPublisher`1.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ErrorPublisher`1.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ErrorPublisher`1.#ctor(System.Exception,System.String)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ErrorPublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ErrorPublisher`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.MaybePublisher`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.MaybePublisher`1.Promise">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.MaybePublisher`1.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybePublisher`1.#ctor(System.Threading.Tasks.TaskCompletionSource{`0},System.String)">
            <summary>
            TBD
            </summary>
            <param name="promise">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybePublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybePublisher`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.CancelledSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.CancelledSubscription.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelledSubscription.Request(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelledSubscription.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.CancellingSubscriber`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.CancellingSubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancellingSubscriber`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancellingSubscriber`1.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancellingSubscriber`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancellingSubscriber`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.RejectAdditionalSubscribers`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.RejectAdditionalSubscribers`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.RejectAdditionalSubscribers`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.RejectAdditionalSubscribers`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ConstantFunctions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ConstantFunctions.OneLong``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.EnumerableActorName">
            <summary>
            Generator of sequentially numbered actor names.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorName.Create(System.String)">
            <summary>
            TBD
            </summary>
            <param name="prefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorName.Next">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorName.Copy(System.String)">
            <summary>
            TBD
            </summary>
            <param name="newPrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.EnumerableActorNameImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.EnumerableActorNameImpl.Prefix">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorNameImpl.#ctor(System.String,Akka.Util.Internal.AtomicCounterLong)">
            <summary>
            TBD
            </summary>
            <param name="prefix">TBD</param>
            <param name="counter">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorNameImpl.Next">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EnumerableActorNameImpl.Copy(System.String)">
            <summary>
            TBD
            </summary>
            <param name="newPrefix">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ExposedPublisherReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ExposedPublisherReceive.ActiveReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ExposedPublisherReceive.Unhandled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ExposedPublisherReceive.#ctor(Akka.Actor.Receive,System.Action{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="activeReceive">TBD</param>
            <param name="unhandled">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ExposedPublisherReceive.ReceiveExposedPublisher(Akka.Streams.Implementation.ExposedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ExposedPublisherReceive.Apply(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.InputBunch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.InputBunch.AllOfMarkedInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.InputBunch.AnyOfMarkedInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.InputBunch.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.#ctor(System.Int32,System.Int32,Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="inputCount">TBD</param>
            <param name="bufferSize">TBD</param>
            <param name="pump">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.InputBunch.LastDequeuedId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.InputBunch.IsAllCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.InputsAvailableFor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.InputsOrCompleteAvailableFor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.Cancel(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.OnError(System.Int32,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.OnDepleted(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.OnCompleteWhenNoInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.MarkInput(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.UnmarkInput(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.MarkAllInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.UnmarkAllInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.IdToDequeue">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when dequeuing with no input.
            TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.Dequeue(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <exception cref="T:System.ArgumentException">TBD
            This exception is thrown when either dequeuing from an empty <paramref name="id"/> or there are no pending inputs.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.DequeueAndYield">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.DequeueAndYield(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.DequeuePreferring(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="preferred">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.IsCancelled(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.IsCompleted(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.IsDepleted(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.InputBunch.IsPending(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn.OnError">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnError.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnError.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn.OnError.#ctor(System.Int32,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnComplete.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn.OnComplete.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn.OnNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnNext.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnNext.Element">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn.OnNext.#ctor(System.Int32,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn.OnSubscribe">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnSubscribe.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.OnSubscribe.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn.OnSubscribe.#ctor(System.Int32,Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="subscription">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.Marked">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.Pending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.Depleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.Completed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn.Cancelled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.FanIn`1.SubInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.SubInput.#ctor(Akka.Actor.IActorRef,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="impl">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.SubInput.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.SubInput.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.SubInput.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.SubInput.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn`1.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn`1.InputCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn`1.PrimaryOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanIn`1.InputBunch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.#ctor(Akka.Streams.ActorMaterializerSettings,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="inputCount">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the pump has not been initialized with a phase.
            </exception>
        </member>
        <member name="P:Akka.Streams.Implementation.FanIn`1.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD
            This exception is thrown automatically since the actor cannot be restarted.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.FanIn`1.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanIn`1.CurrentAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanIn`1.IsPumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.InitialPhase(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.WaitForUpstream(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.GotUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.NextPhase(Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.PumpFailed(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanIn`1.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.OutputBunch`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.#ctor(System.Int32,Akka.Actor.IActorRef,Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="outputCount">TBD</param>
            <param name="impl">TBD</param>
            <param name="pump">TBD</param>
        </member>
        <member name="F:Akka.Streams.Implementation.OutputBunch`1.AllOfMarkedOutputs">
            <summary>
            Will only transfer an element when all marked outputs
            have demand, and will complete as soon as any of the marked
            outputs have canceled.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.OutputBunch`1.AnyOfMarkedOutputs">
            <summary>
            Will transfer an element when any of the  marked outputs
            have demand, and will complete when all of the marked
            outputs have canceled.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.OutputBunch`1.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IsPending(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IsCompleted(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IsCancelled(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IsErrored(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.Complete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.Complete(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.Cancel(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.Error(System.Int32,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.MarkOutput(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.UnmarkOutput(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.MarkAllOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.UnmarkAllOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.UnmarkCancelledOutputs(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="enabled">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IdToEnqueue">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.Enqueue(System.Int32,`0)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.EnqueueMarked(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.IdToEnqueueAndYield">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.EnqueueAndYield(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.EnqueueAndPrefer(`0,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <param name="preferred">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.OnCancel(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="output">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.DemandAvailableFor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.OutputBunch`1.DemandOrCancelAvailableFor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut.SubstreamRequestMore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut.SubstreamRequestMore.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut.SubstreamRequestMore.Demand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamRequestMore.#ctor(System.Int32,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="demand">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut.SubstreamCancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut.SubstreamCancel.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamCancel.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut.SubstreamSubscribePending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut.SubstreamSubscribePending.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamSubscribePending.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut.SubstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamSubscription.#ctor(Akka.Actor.IActorRef,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamSubscription.Request(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamSubscription.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.SubstreamSubscription.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut.ExposedPublishers`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut.ExposedPublishers`1.Publishers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut.ExposedPublishers`1.#ctor(System.Collections.Immutable.ImmutableList{Akka.Streams.Implementation.ActorPublisher{`0}})">
            <summary>
            TBD
            </summary>
            <param name="publishers">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut`1.OutputBunch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.FanOut`1.PrimaryInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.#ctor(Akka.Streams.ActorMaterializerSettings,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="outputCount">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.FanOut`1.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown automatically since the actor cannot be restarted.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.FanOut`1.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanOut`1.CurrentAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanOut`1.IsPumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.InitialPhase(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.WaitForUpstream(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.GotUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.NextPhase(Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.PumpFailed(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanOut`1.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Unzip">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Unzip.Props``1(Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Unzip`1">
            <summary>
            INTERNAL API
            TODO Find out where this class will be used and check if the type parameter fit
            since we need to cast messages into a tuple and therefore maybe need additional type parameters
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Unzip`1.#ctor(Akka.Streams.ActorMaterializerSettings,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="outputCount">TBD</param>
            <exception cref="T:System.ArgumentException">TBD
            This exception is thrown when the elements in <see cref="F:Akka.Streams.Implementation.FanOut`1.PrimaryInputs"/>
            are of an unknown type.
            </exception>>
        </member>
        <member name="T:Akka.Streams.Implementation.FanoutOutputs`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.FanoutOutputs`1.ExposedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.NeedsDemand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.NeedsDemandOrCancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.IsDemandAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.DemandCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.InitialBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.MaxBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.#ctor(System.Int32,System.Int32,Akka.Actor.IActorRef,Akka.Streams.Implementation.IPump,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="maxBufferSize">TBD</param>
            <param name="initialBufferSize">TBD</param>
            <param name="self">TBD</param>
            <param name="pump">TBD</param>
            <param name="afterShutdown">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the first message isn't of type <see cref="F:Akka.Streams.Implementation.FanoutOutputs`1.ExposedPublisher"/>.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.CreateSubscription(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.DownstreamRunning(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.RequestFromUpstream(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.Shutdown(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="isCompleted">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.CancelUpstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.EnqueueOutputElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.Complete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutOutputs`1.Error(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutOutputs`1.IsOpen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanoutProcessorImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutProcessorImpl`1.Props(Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutProcessorImpl`1.PrimaryOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutProcessorImpl`1.#ctor(Akka.Streams.ActorMaterializerSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutProcessorImpl`1.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutProcessorImpl`1.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphModule">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphModule.MaterializedValueIds">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphModule.Assembly">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphModule.#ctor(Akka.Streams.Implementation.Fusing.GraphAssembly,Akka.Streams.Shape,Akka.Streams.Attributes,Akka.Streams.Implementation.IModule[])">
            <summary>
            TBD
            </summary>
            <param name="assembly">TBD</param>
            <param name="shape">TBD</param>
            <param name="attributes">TBD</param>
            <param name="materializedValueIds">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="newShape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphModule.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreterShell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Materializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreterShell._shellEventLimit">
            <summary>
            Limits the number of events processed by the interpreter before scheduling
            a self-message for fairness with other actors. The basic assumption here is
            to give each input buffer slot a chance to run through the whole pipeline
            and back (for the elements).
            
            Considered use case:
             - assume a composite Sink of one expand and one fold 
             - assume an infinitely fast source of data
             - assume maxInputBufferSize == 1
             - if the event limit is greater than maxInputBufferSize * (ins + outs) than there will always be expand activity
             because no data can enter "fast enough" from the outside
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.#ctor(Akka.Streams.Implementation.Fusing.GraphAssembly,Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection[],Akka.Streams.Stage.GraphStageLogic[],Akka.Streams.Shape,Akka.Streams.ActorMaterializerSettings,Akka.Streams.Implementation.ExtendedActorMaterializer)">
            <summary>
            TBD
            </summary>
            <param name="assembly">TBD</param>
            <param name="connections">TBD</param>
            <param name="logics">TBD</param>
            <param name="shape">TBD</param>
            <param name="settings">TbD</param>
            <param name="materializer">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.IsInitialized">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.CanShutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Self">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Interpreter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Init(Akka.Actor.IActorRef,Akka.Streams.Implementation.SubFusingActorMaterializerImpl,System.Action{System.Object},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="subMat">TBD</param>
            <param name="enqueueToShourtCircuit">TBD</param>
            <param name="eventLimit">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.Receive(Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
            <param name="eventLimit">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.TryAbort(System.Exception)">
            Attempts to abort execution, by first propagating the reason given until either
             - the interpreter successfully finishes
             - the event limit is reached
             - a new error is encountered
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnError">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnError.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnError.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnError.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
            <param name="cause">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnError.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnComplete.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnComplete.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnComplete.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnNext.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnNext.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnNext.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
            <param name="event">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnNext.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnSubscribe">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnSubscribe.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnSubscribe.Subscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnSubscribe.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32,Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
            <param name="subscription">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.OnSubscribe.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RequestMore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RequestMore.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RequestMore.Demand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RequestMore.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
            <param name="demand">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RequestMore.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Cancel.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Cancel.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Cancel.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.SubscribePending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.SubscribePending.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.SubscribePending.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.SubscribePending.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ExposedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ExposedPublisher.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ExposedPublisher.Publisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ExposedPublisher.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32,Akka.Streams.Implementation.IActorPublisher)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
            <param name="publisher">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ExposedPublisher.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput.Logic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput.Handler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell,Akka.Streams.Stage.GraphStageLogic,System.Object,System.Action{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <param name="logic">TBD</param>
            <param name="event">TBD</param>
            <param name="handler">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.AsyncInput.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Resume">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Resume.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Resume.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Abort">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Abort.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Abort.Shell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundaryPublisher`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundaryPublisher`1.#ctor(Akka.Actor.IActorRef,Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundaryPublisher`1.WakeUpMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscription.#ctor(Akka.Actor.IActorRef,Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscription.Request(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscription.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscription.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1.#ctor(Akka.Actor.IActorRef,Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BoundarySubscriber`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
            <param name="id">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.OnInternalError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.BatchingActorInputBoundary.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary.SubscribePending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary.ExposedPublisher(Akka.Streams.Implementation.IActorPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary.RequestMore(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IActorOutputBoundary.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.#ctor(Akka.Actor.IActorRef,Akka.Streams.Implementation.Fusing.GraphInterpreterShell,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="shell">TBD</param>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.RequestMore(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.SubscribePending">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.ExposedPublisher(Akka.Streams.Implementation.ActorPublisher{`0})">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.ActorOutputBoundary`1.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Props(Akka.Streams.Implementation.Fusing.GraphInterpreterShell)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.#ctor(Akka.Streams.Implementation.Fusing.GraphInterpreterShell)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.RegisterShell(Akka.Streams.Implementation.Fusing.GraphInterpreterShell)">
            <summary>
            TBD
            </summary>
            <param name="shell">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorUpstream`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorUpstream`1.HasNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorUpstream`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorUpstream`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.IsDone">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.NextElement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.NeedsPull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.LastFailure">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.Dispose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.MoveNext">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.Reset">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.HasNext">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter.EnumeratorDownstream`1.Current">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter`2.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IEnumerable{Akka.Streams.Stage.PushPullStage{`0,`1}})">
            <summary>
            TBD
            </summary>
            <param name="input">TBD</param>
            <param name="ops">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.EnumeratorInterpreter`2.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Fusing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.Fusing.IsDebug">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Aggressive``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Fuse everything that is not forbidden via AsyncBoundary attribute.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="graph">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.StructuralInfo``2(Akka.Streams.IGraph{``0,``1},Akka.Streams.Attributes)">
            <summary>
            Return the <see cref="T:Akka.Streams.Implementation.StructuralInfoModule"/> for this Graph without any fusing
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMat"></typeparam>
            <param name="graph"></param>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Fuse(Akka.Streams.Implementation.Fusing.BuildStructuralInfo)">
            <summary>
            Take the fusable islands identified by <see cref="M:Akka.Streams.Implementation.Fusing.Fusing.Descend``1(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes,Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},System.Int32)"/> in the <see cref="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Groups"/> list 
            and execute their fusion; only fusable islands will have multiple modules in their set.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.FuseGroup(Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule})">
            <summary>
            Transform a set of GraphStageModules into a single GraphModule. This is done
            by performing a traversal of all their Inlets, sorting them into those without
            internal connections(the exposed inlets) and those with internal connections
            (where the corresponding Outlet is recorded in a map so that it will be wired
            to the same slot number in the GraphAssembly). Then all Outlets are traversed,
            completing internal connections using the aforementioned maps and appending
            the others to the list of exposed Outlets.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Descend``1(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes,Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},System.Int32)">
            <summary>
            This is a normalization step for the graph that also collects the needed
            information for later fusing. The goal is to transform an arbitrarily deep
            module tree into one that has exactly two levels: all direct submodules are
            CopiedModules where each contains exactly one atomic module. This way all
            modules have their own identity and all necessary port copies have been
            made. The upstreams/downstreams in the BuildStructuralInfo are rewritten
            to point to the shapes of the copied modules.
            
            The materialized value computation is rewritten as well in that all
            leaf nodes point to the copied modules and all nested computations are
            "inlined", resulting in only one big computation tree for the whole
            normalized overall module. The contained MaterializedValueSource stages
            are also rewritten to point to the copied MaterializedValueNodes. This
            correspondence is then used during materialization to trigger these sources
            when "their" node has received its value.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.RewriteMaterializer(System.Collections.Generic.IDictionary{Akka.Streams.Implementation.IModule,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,System.Collections.Generic.Dictionary{Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode})">
            <summary>
            Given a mapping from old modules to new MaterializedValueNode, rewrite the given
            computation while also populating a mapping from old computation nodes to new ones.
            That mapping is needed to rewrite the MaterializedValueSource stages later-on in
            descend().
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.GetDispatcher(Akka.Streams.Implementation.IModule)">
            <summary>
            Figure out the dispatcher setting of a module.
            </summary>
            <param name="module">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Log(System.Int32,System.String)">
            <summary>
            TBD
            </summary>
            <param name="indent">TBD</param>
            <param name="msg">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.BuildStructuralInfo">
            <summary>
            Collect structural information about a module tree while descending into it and performing normalization.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Modules">
            <summary>
            The set of all contained modules.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Groups">
            <summary>
            The list of all groups of modules that are within each async boundary.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.OutGroups">
            <summary>
            A mapping from OutPort to its containing group, needed when determining whether an upstream connection is internal or not.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewInputs">
            <summary>
            A stack of mappings for a given non-copied InPort.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewOutputs">
            <summary>
            A stack of mappings for a given non-copied OutPort.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Downstreams">
            <summary>
            The downstreams relationships of the original module rewritten in terms of the copied ports.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Upstreams">
            <summary>
            The upstreams relationships of the original module rewritten in terms of the copied ports.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.InOwners">
            <summary>
            The owner mapping for the copied InPorts.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.OutOwners">
            <summary>
            The owner mapping for the copied OutPorts.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.InternalOuts">
            <summary>
            List of internal wirings of GraphModules that were incorporated.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo._materializedSources">
            <summary>
            A stack of materialized value sources, grouped by materialized computation context.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.EnterMaterializationContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.ExitMaterializationContext">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the stack of materialized value sources is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.PushMaterializationSource(Akka.Streams.Implementation.CopiedModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the stack of materialized value sources is empty.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.ToInfo``1(``0,System.Collections.Generic.IList{System.ValueTuple{Akka.Streams.Implementation.IModule,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode}},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Replace(Akka.Streams.Implementation.IModule,Akka.Streams.Implementation.IModule,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule})">
            <summary>
            TBD
            </summary>
            <param name="oldModule">TBD</param>
            <param name="newModule">TBD</param>
            <param name="localGroup">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.BreakUpGroupsByDispatcher">
            <summary>
            Fusable groups may contain modules with differing dispatchers, in which case the group needs to be broken up.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.RegisterInternals(Akka.Streams.Shape,System.Int32)">
            <summary>
            Register the outlets of the given Shape as sources for internal connections within imported 
            (and not dissolved) GraphModules. See also the comment in addModule where this is partially undone.
            </summary>
            <param name="shape">TBD</param>
            <param name="indent">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.RemoveInternalWires">
            <summary>
            Remove wirings that belong to the fused stages contained in GraphModules that were incorporated in this fusing run.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.CreateGroup(System.Int32)">
            <summary>
            Create and return a new grouping (i.e. an AsyncBoundary-delimited context)
            </summary>
            <param name="indent">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.AddModule(Akka.Streams.Implementation.IModule,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},Akka.Streams.Attributes,System.Int32,Akka.Streams.Shape)">
            <summary>
            Add a module to the given group, performing normalization (i.e. giving it a unique port identity).
            </summary>
            <param name="module">TBD</param>
            <param name="group">TBD</param>
            <param name="inheritedAttributes">TBD</param>
            <param name="indent">TBD</param>
            <param name="oldShape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Wire(Akka.Streams.OutPort,Akka.Streams.InPort,System.Int32)">
            <summary>
            Record a wiring between two copied ports, using (and reducing) the port mappings.
            </summary>
            <param name="outPort">TBD</param>
            <param name="inPort">TBD</param>
            <param name="indent">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Rewire(Akka.Streams.Shape,Akka.Streams.Shape,System.Int32)">
            <summary>
            Replace all mappings for a given shape with its new (copied) form.
            </summary>
            <param name="oldShape">TBD</param>
            <param name="newShape">TBD</param>
            <param name="indent">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewInlets(System.Collections.Generic.IEnumerable{Akka.Streams.Inlet})">
            <summary>
            Transform original into copied Inlets.
            </summary>
            <param name="old">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewOutlets(System.Collections.Generic.IEnumerable{Akka.Streams.Outlet})">
            <summary>
            Transform original into copied Outlets.
            </summary>
            <param name="old">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.GetRealModule(Akka.Streams.Implementation.IModule)">
            <summary>
            See through copied modules to the "real" module.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Dump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Hash(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphAssembly">
             <summary>
             INTERNAL API
             
             A GraphAssembly represents a small stream processing graph to be executed by the interpreter. Instances of this
             class **must not** be mutated after construction.
             
             The array <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.OriginalAttributes"/> may contain the attribute information of the original atomic module, otherwise
             it must contain a none (otherwise the enclosing module could not overwrite attributes defined in this array).
             
             The arrays <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Inlets"/> and <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Outlets"/> correspond to the notion of a *connection* in the <see cref="T:Akka.Streams.Implementation.Fusing.GraphInterpreter"/>. Each slot
             *i* contains the input and output port corresponding to connection *i*. Slots where the graph is not closed (i.e.
             ports are exposed to the external world) are marked with null values. For example if an input port p is
             exposed, then Outlets[p] will contain a null.
            
             The arrays <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.InletOwners"/> and <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.OutletOwners"/> are lookup tables from a connection id(the index of the slot)
             to a slot in the <see cref="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Stages"/> array, indicating which stage is the owner of the given input or output port.
            
             Slots which would correspond to non-existent stages(where the corresponding port is null since it represents
             the currently unknown external context) contain the value <see cref="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Boundary"/>.
            
            The current assumption by the infrastructure is that the layout of these arrays looks like this:
            
                        +---------------------------------------+-----------------+
             inOwners:  | index to stages array | Boundary(-1)                    |
                        +----------------+----------------------+-----------------+
             ins:       | exposed inputs | internal connections | nulls           |
                        +----------------+----------------------+-----------------+
             outs:      | nulls          | internal connections | exposed outputs |
                        +----------------+----------------------+-----------------+
             outOwners: | Boundary(-1)   | index to stages array                  |
                        +----------------+----------------------------------------+
            
             In addition, it is also assumed by the infrastructure that the order of exposed inputs and outputs in the
             corresponding segments of these arrays matches the exact same order of the ports in the <see cref="T:Akka.Streams.Shape"/>.
             </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphAssembly.Create(System.Collections.Generic.IList{Akka.Streams.Inlet},System.Collections.Generic.IList{Akka.Streams.Outlet},System.Collections.Generic.IList{Akka.Streams.Stage.IGraphStageWithMaterializedValue{Akka.Streams.Shape,System.Object}})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <param name="stages">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Stages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.OriginalAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.InletOwners">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphAssembly.OutletOwners">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphAssembly.#ctor(Akka.Streams.Stage.IGraphStageWithMaterializedValue{Akka.Streams.Shape,System.Object}[],Akka.Streams.Attributes[],Akka.Streams.Inlet[],System.Int32[],Akka.Streams.Outlet[],System.Int32[])">
            <summary>
            TBD
            </summary>
            <param name="stages">TBD</param>
            <param name="originalAttributes">TBD</param>
            <param name="inlets">TBD</param>
            <param name="inletOwners">TBD</param>
            <param name="outlets">TBD</param>
            <param name="outletOwners">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphAssembly.ConnectionCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphAssembly.Materialize(Akka.Streams.Attributes,Akka.Streams.Implementation.IModule[],System.Collections.Generic.IDictionary{Akka.Streams.Implementation.IModule,System.Object},System.Action{Akka.Streams.Implementation.Fusing.IMaterializedValueSource})">
            <summary>
            Takes an interpreter and returns three arrays required by the interpreter containing the input, output port
            handlers and the stage logic instances.
            
            <para>Returns a tuple of</para>
            <para/> - lookup table for InHandlers
            <para/> - lookup table for OutHandlers
            <para/> - array of the logics
            <para/> - materialized value
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <param name="copiedModules">TBD</param>
            <param name="materializedValues">TBD</param>
            <param name="register">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphAssembly.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter">
             <summary>
             INTERNAL API
            
             From an external viewpoint, the GraphInterpreter takes an assembly of graph processing stages encoded as a
             <see cref="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Assembly"/> object and provides facilities to execute and interact with this assembly.
             <para/> The lifecycle of the Interpreter is roughly the following:
             <para/> - Boundary logics are attached via <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachDownstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic)"/> and <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachUpstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic)"/>
             <para/> - <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Init(Akka.Streams.IMaterializer)"/> is called
             <para/> - <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Execute(System.Int32)"/> is called whenever there is need for execution, providing an upper limit on the processed events
             <para/> - <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Finish"/> is called before the interpreter is disposed, preferably after <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsCompleted"/> returned true, although
                in abort cases this is not strictly necessary
            
             The <see cref="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Execute(System.Int32)"/> method of the interpreter accepts an upper bound on the events it will process. After this limit
             is reached or there are no more pending events to be processed, the call returns. It is possible to inspect
             if there are unprocessed events left via the <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsSuspended"/> method. <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsCompleted"/> returns true once all stages
             reported completion inside the interpreter.
            
             The internal architecture of the interpreter is based on the usage of arrays and optimized for reducing allocations
             on the hot paths.
            
             One of the basic abstractions inside the interpreter is the <see cref="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection"/>. A connection represents an output-input port pair
             (an analogue for a connected RS Publisher-Subscriber pair). The Connection object contains all the necessary data for the interpreter 
             to pass elements, demand, completion or errors across the Connection.
             <para/> In particular
             <para/> - portStates contains a bitfield that tracks the states of the ports (output-input) corresponding to this
                connection. This bitfield is used to decode the event that is in-flight.
             <para/> - connectionSlot contains a potential element or exception that accompanies the
                event encoded in the portStates bitfield
             <para/> - inHandler contains the <see cref="T:Akka.Streams.Stage.InHandler"/> instance that handles the events corresponding
                to the input port of the connection
             <para/> - outHandler contains the <see cref="T:Akka.Streams.Stage.OutHandler"/> instance that handles the events corresponding
                to the output port of the connection
            
             On top of the Connection table there is an eventQueue, represented as a circular buffer of Connections. The queue
             contains the Connections that have pending events to be processed. The pending event itself is encoded
             in the portState bitfield of the Connection. This implies that there can be only one event in flight for a given
             Connection, which is true in almost all cases, except a complete-after-push or fail-after-push which has to
             be decoded accordingly.
            
             The layout of the portState  bitfield is the following:
            
                         |- state machn.-| Only one bit is hot among these bits
              64  32  16 | 8   4   2   1 |
             +---+---+---|---+---+---+---|
               |   |   |   |   |   |   |
               |   |   |   |   |   |   |  From the following flags only one is active in any given time. These bits encode
               |   |   |   |   |   |   |  state machine states, and they are "moved" around using XOR masks to keep other bits
               |   |   |   |   |   |   |  intact.
               |   |   |   |   |   |   |
               |   |   |   |   |   |   +- InReady:  The input port is ready to be pulled
               |   |   |   |   |   +----- Pulling:  A pull is active, but have not arrived yet (queued)
               |   |   |   |   +--------- Pushing:  A push is active, but have not arrived yet (queued)
               |   |   |   +------------- OutReady: The output port is ready to be pushed
               |   |   |
               |   |   +----------------- InClosed:  The input port is closed and will not receive any events.
               |   |                                 A push might be still in flight which will be then processed first.
               |   +--------------------- OutClosed: The output port is closed and will not receive any events.
               +------------------------- InFailed:  Always set in conjunction with InClosed. Indicates that the close event
                                                     is a failure
            
             Sending an event is usually the following sequence:
              - An action is requested by a stage logic (push, pull, complete, etc.)
              - the state machine in portStates is transitioned from a ready state to a pending event
              - the affected Connection is enqueued
            
             Receiving an event is usually the following sequence:
              - the connection to be processed is dequeued
              - the type of the event is determined from the bits set on portStates
              - the state machine in portStates is transitioned to a ready state
              - using the inHandlers/outHandlers table the corresponding callback is called on the stage logic.
            
             Because of the FIFO construction of the queue the interpreter is fair, i.e. a pending event is always executed
             after a bounded number of other events. This property, together with suspendability means that even infinite cycles can
             be modeled, or even dissolved (if preempted and a "stealing" external event is injected; for example the non-cycle
             edge of a balance is pulled, dissolving the original cycle).
            
             </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.Empty">
            <summary>
            Marker object that indicates that a port holds no element since it was already grabbed. 
            The port is still pullable, but there is no more element to grab.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Empty.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Empty.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.Failed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Failed.Reason">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Failed.PreviousElement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Failed.#ctor(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <param name="previousElement">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection">
            <summary>
            INTERNAL API
            
            Contains all the necessary information for the GraphInterpreter to be able to implement a connection
            between an output and input ports.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.#ctor(System.Int32,System.Int32,Akka.Streams.Stage.GraphStageLogic,System.Int32,Akka.Streams.Stage.GraphStageLogic,Akka.Streams.Stage.IInHandler,Akka.Streams.Stage.IOutHandler)">
            <summary>
            TBD
            </summary>
            <param name="id">Identifier of the connection. Corresponds to the array slot in the <see cref="T:Akka.Streams.Implementation.Fusing.GraphAssembly"/></param>
            <param name="inOwnerId">Identifier of the owner of the input side of the connection. Corresponds to the array slot in the <see cref="T:Akka.Streams.Implementation.Fusing.GraphAssembly"/></param>
            <param name="inOwner">The stage logic that corresponds to the input side of the connection.</param>
            <param name="outOwnerId">Identifier of the owner of the output side of the connection. Corresponds to the array slot in the <see cref="T:Akka.Streams.Implementation.Fusing.GraphAssembly"/></param>
            <param name="outOwner">The stage logic that corresponds to the output side of the connection.</param>
            <param name="inHandler">The handler that contains the callback for input events.</param>
            <param name="outHandler">The handler that contains the callback for output events.</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.InOwnerId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.InOwner">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.OutOwnerId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.OutOwner">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.InHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.OutHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.PortState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.Slot">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsDebug">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.NoEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Boundary">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.InReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Pulling">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Pushing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OutReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.InClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OutClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.InFailed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.PullStartFlip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.PullEndFlip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.PushStartFlip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.PushEndFlip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.KeepGoingFlag">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.KeepGoingMask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Current">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.CurrentInterpreterOrNull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.SingleNoAttribute">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Logics">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Assembly">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Materializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.Connections">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OnAsyncInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.FuzzingMode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Context">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.RunningStagesCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.#ctor(Akka.Streams.Implementation.Fusing.GraphAssembly,Akka.Streams.IMaterializer,Akka.Event.ILoggingAdapter,Akka.Streams.Stage.GraphStageLogic[],Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection[],System.Action{Akka.Streams.Stage.GraphStageLogic,System.Object,System.Action{System.Object}},System.Boolean,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="assembly">TBD</param>
            <param name="materializer">TBD</param>
            <param name="log">TBD</param>
            <param name="logics">TBD</param>
            <param name="connections">TBD</param>
            <param name="onAsyncInput">TBD</param>
            <param name="fuzzingMode">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.ActiveStage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.SubFusingMaterializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachUpstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic)">
            <summary>
            Assign the boundary logic to a given connection. This will serve as the interface to the external world
            (outside the interpreter) to process and inject events.
            </summary>
            <param name="connection">TBD</param>
            <param name="logic">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachUpstreamBoundary(System.Int32,Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="logic">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachDownstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic)">
            <summary>
            Assign the boundary logic to a given connection. This will serve as the interface to the external world
            (outside the interpreter) to process and inject events.
            </summary>
            <param name="connection">TBD</param>
            <param name="logic">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachDownstreamBoundary(System.Int32,Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="logic">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.SetHandler(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Stage.IInHandler)">
            <summary>
            Dynamic handler changes are communicated from a GraphStageLogic by this method.
            </summary>
            <param name="connection">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.SetHandler(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,Akka.Streams.Stage.IOutHandler)">
            <summary>
            Dynamic handler changes are communicated from a GraphStageLogic by this method.
            </summary>
            <param name="connection">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsSuspended">
            <summary>
            Returns true if there are pending unprocessed events in the event queue.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsCompleted">
            <summary>
            Returns true if there are no more running stages and pending events.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Init(Akka.Streams.IMaterializer)">
            <summary>
            Initializes the states of all the stage logics by calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/>.
            The passed-in materializer is intended to be a <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.SubFusingMaterializer"/>
            that avoids creating new Actors when stages materialize sub-flows.If no
            such materializer is available, passing in null will reuse the normal
            materializer for the GraphInterpreterâ€”fusing is only an optimization.
            </summary>
            <param name="subMaterializer">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Finish">
            <summary>
            Finalizes the state of all stages by calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/> (if necessary).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Execute(System.Int32)">
            <summary>
            Executes pending events until the given limit is met. If there were remaining events, <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsSuspended"/> will return true.
            </summary>
            <param name="eventLimit">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.RunAsyncInput(Akka.Streams.Stage.GraphStageLogic,System.Object,System.Action{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="evt">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.ProcessEvent(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            Decodes and processes a single event for the given connection
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Enqueue(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <exception cref="T:System.Exception">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AfterStageHasRun(Akka.Streams.Stage.GraphStageLogic)">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsStageCompleted(Akka.Streams.Stage.GraphStageLogic)">
            <summary>
            Returns true if the given stage is already completed
            </summary>
            <param name="stage">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.CompleteConnection(System.Int32)">
            <summary>
             Register that a connection in which the given stage participated has been completed and therefore the stage itself might stop, too.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.SetKeepGoing(Akka.Streams.Stage.GraphStageLogic,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="enabled">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.ChasePush(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.ChasePull(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Complete(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Fail(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Cancel(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.DumpWaits">
            <summary>
            Debug utility to dump the "waits-on" relationships in DOT format to the console for analysis of deadlocks.
            
            Only invoke this after the interpreter completely settled, otherwise the results might be off. This is a very
            simplistic tool, make sure you are understanding what you are doing and then it will serve you well.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphStages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStages.Identity``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStages.TerminationWatcher``1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStages.WithDetachedInputs``1(Akka.Streams.Stage.GraphStage{Akka.Streams.UniformFanInShape{``0,``0}})">
            <summary>
            Fusing graphs that have cycles involving FanIn stages might lead to deadlocks if
            demand is not carefully managed.
            
            This means that FanIn stages need to early pull every relevant input on startup.
            This can either be implemented inside the stage itself, or this method can be used,
            which adds a detacher stage to every input.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="stage">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphStageModule">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphStageModule.Stage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStageModule.#ctor(Akka.Streams.Shape,Akka.Streams.Attributes,Akka.Streams.Stage.IGraphStageWithMaterializedValue{Akka.Streams.Shape,System.Object})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <param name="attributes">TBD</param>
            <param name="stage">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphStageModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStageModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStageModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphStageModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStageModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStageModule.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage`1.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage`1.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage`1.#ctor(System.String)">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Identity`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.Identity`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Identity`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Identity`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Detacher`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Detacher`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Detacher`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Detacher`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Detacher`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TerminationWatcher`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.TerminationWatcher`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TerminationWatcher`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TerminationWatcher`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TerminationWatcher`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TerminationWatcher`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.FLowMonitorImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.FLowMonitorImpl`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.FLowMonitorImpl`1.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.MonitorFlow`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MonitorFlow`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MonitorFlow`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MonitorFlow`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MonitorFlow`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MonitorFlow`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MonitorFlow`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TickSource`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TickSource`1.#ctor(System.TimeSpan,System.TimeSpan,`0)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="tick">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TickSource`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TickSource`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TickSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TickSource`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TickSource`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.IMaterializedValueSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.IMaterializedValueSource.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.IMaterializedValueSource.CopySource">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.IMaterializedValueSource.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.IMaterializedValueSource.Computation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.IMaterializedValueSource.SetValue(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="result">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1">
            <summary>
            INTERNAL API
            
            This source is not reusable, it is only created internally.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.Computation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.#ctor(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Outlet{`0})">
            <summary>
            TBD
            </summary>
            <param name="computation">TBD</param>
            <param name="outlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.#ctor(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode)">
            <summary>
            TBD
            </summary>
            <param name="computation">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.SetValue(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.CopySource">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.MaterializedValueSource`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SingleSource`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SingleSource`1.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SingleSource`1.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SingleSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SingleSource`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TaskSource`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.TaskSource`1.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TaskSource`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TaskSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TaskSource`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TaskSource`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.IgnoreSink`1">
            <summary>
            INTERNAL API
            
            Discards all received elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Select`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Select`2.#ctor(System.Func{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="func">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Select`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Select`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Select`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Select`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Select`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Select`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Where`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Where`1.#ctor(System.Predicate{`0})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Where`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Where`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TakeWhile`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TakeWhile`1.#ctor(System.Predicate{`0},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
            <param name="inclusive">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.TakeWhile`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TakeWhile`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TakeWhile`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SkipWhile`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SkipWhile`1.#ctor(System.Predicate{`0})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SkipWhile`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SkipWhile`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SkipWhile`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic.#ctor(Akka.Streams.Attributes,Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic.WithSupervision``1(System.Func{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="function">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic.OnRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic.OnResume(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SupervisedGraphStageLogic.OnStop(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Collect`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Collect`2.#ctor(System.Func{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="func">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Collect`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Collect`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Collect`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Collect`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Collect`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Collect`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Recover`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Recover`1.#ctor(System.Func{System.Exception,Akka.Util.Option{`0}})">
            <summary>
            TBD
            </summary>
            <param name="recovery">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Recover`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Recover`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Recover`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SelectError`1">
            <summary>
            INTERNAL API
            
            Maps error with the provided function if it is defined for an error or, otherwise, passes it on unchanged.
            
            While similar to <see cref="T:Akka.Streams.Implementation.Fusing.Recover`1"/> this stage can be used to transform an error signal to a different one without logging
            it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e => throw e2) since Recover
            would log the e2 error.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Take`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Take`1.#ctor(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Take`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Take`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Take`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Skip`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Skip`1.#ctor(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Skip`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Skip`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Skip`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Scan`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Scan`2.#ctor(`1,System.Func{`1,`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Scan`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Scan`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Scan`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Scan`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Scan`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Scan`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.ScanAsync`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ScanAsync`2.#ctor(`1,System.Func{`1,`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            TBD
            </summary>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ScanAsync`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ScanAsync`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ScanAsync`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.ScanAsync`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ScanAsync`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.ScanAsync`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Aggregate`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Aggregate`2.#ctor(`1,System.Func{`1,`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Aggregate`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Aggregate`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Aggregate`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Aggregate`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Aggregate`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Aggregate`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.AggregateAsync`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.AggregateAsync`2.#ctor(`1,System.Func{`1,`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            TBD
            </summary>
            <param name="zero">TBD</param>
            <param name="aggregate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.AggregateAsync`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.AggregateAsync`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.AggregateAsync`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.AggregateAsync`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.AggregateAsync`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.AggregateAsync`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Intersperse`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Intersperse`1.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="inject">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Intersperse`1.#ctor(`0,`0,`0)">
            <summary>
            TBD
            </summary>
            <param name="start">TBD</param>
            <param name="inject">TBD</param>
            <param name="end">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Intersperse`1.InjectStartEnd">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Intersperse`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Grouped`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Grouped`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="count"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Grouped`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Grouped`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Grouped`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Grouped`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Grouped`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Grouped`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.LimitWeighted`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.LimitWeighted`1.#ctor(System.Int64,System.Func{`0,System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.LimitWeighted`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.LimitWeighted`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.LimitWeighted`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Sliding`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sliding`1.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
            <param name="step">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="count"/>
            or <paramref name="step"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Sliding`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Sliding`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Sliding`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Sliding`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sliding`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sliding`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Buffer`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Buffer`1.#ctor(System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
            <param name="overflowStrategy">TBD</param>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown when the specified <paramref name="overflowStrategy"/>  has an unknown <see cref="T:Akka.Streams.OverflowStrategy"/>.
            </exception>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.OnCompleted`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Batch`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Batch`2.#ctor(System.Int64,System.Func{`0,System.Int64},System.Func{`0,`1},System.Func{`1,`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="max">TBD</param>
            <param name="costFunc">TBD</param>
            <param name="seed">TBD</param>
            <param name="aggregate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Batch`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Batch`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Expand`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Expand`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerator{`1}})">
            <summary>
            TBD
            </summary>
            <param name="extrapolate">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Expand`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Expand`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Expand`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Expand`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Expand`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Expand`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SelectAsync`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SelectAsync`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SelectAsync`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SelectAsync`2.#ctor(System.Int32,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            TBD
            </summary>
            <param name="parallelism">TBD</param>
            <param name="mapFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SelectAsync`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SelectAsync`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SelectAsync`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.#ctor(System.Int32,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            TBD
            </summary>
            <param name="parallelism">TBD</param>
            <param name="mapFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SelectAsyncUnordered`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Log`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Log`1.#ctor(System.String,System.Func{`0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="extract">TBD</param>
            <param name="adapter">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Log`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Log`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TimerKeys">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.TimerKeys.TakeWithin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.TimerKeys.DropWithin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.TimerKeys.GroupedWithin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GroupedWithin`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GroupedWithin`1.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GroupedWithin`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GroupedWithin`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GroupedWithin`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Delay`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Delay`1.#ctor(System.TimeSpan,Akka.Streams.DelayOverflowStrategy)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="strategy">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Delay`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Delay`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Delay`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.TakeWithin`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TakeWithin`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.TakeWithin`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SkipWithin`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SkipWithin`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SkipWithin`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Sum`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sum`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            TBD
            </summary>
            <param name="reduce">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Sum`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sum`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Sum`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.RecoverWith`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.RecoverWith`2.#ctor(System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},`1}},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="partialFunction">TBD</param>
            <param name="maximumRetries">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="maximumRetries"/> is less than zero or not equal to -1.
            </exception>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.RecoverWith`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.RecoverWith`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.RecoverWith`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2.#ctor(System.Func{System.Func{`0,System.Collections.Generic.IEnumerable{`1}}})">
            <summary>
            TBD
            </summary>
            <param name="concatFactory">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.StatefulSelectMany`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.FlattenMerge`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TGraph">TBD</typeparam>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.FlattenMerge`3.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="breadth">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.FlattenMerge`3.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.FlattenMerge`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.FlattenMerge`3.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="enclosingAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.FlattenMerge`3.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.PrefixAndTail`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.PrefixAndTail`1.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="count">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.PrefixAndTail`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.PrefixAndTail`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.PrefixAndTail`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.PrefixAndTail`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GroupBy`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GroupBy`2.#ctor(System.Int32,System.Func{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="maxSubstreams">TBD</param>
            <param name="keyFor">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GroupBy`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GroupBy`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GroupBy`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GroupBy`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Split">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Split.SplitDecision">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.Split.SplitDecision.SplitBefore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.Split.SplitDecision.SplitAfter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Split.When``1(System.Func{``0,System.Boolean},Akka.Streams.SubstreamCancelStrategy)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="p">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Split.After``1(System.Func{``0,System.Boolean},Akka.Streams.SubstreamCancelStrategy)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="p">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Split`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Split`1.#ctor(Akka.Streams.Implementation.Fusing.Split.SplitDecision,System.Func{`0,System.Boolean},Akka.Streams.SubstreamCancelStrategy)">
            <summary>
            TBD
            </summary>
            <param name="decision">TBD</param>
            <param name="predicate">TBD</param>
            <param name="substreamCancelStrategy">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.Split`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Split`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Split`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink.Uninitialized">
            <summary>
            Not yet materialized and no command has been scheduled
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink.CommandScheduledBeforeMaterialization">
            <summary>
            A command was scheduled before materialization
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink.RequestOneScheduledBeforeMaterialization">
            <summary>
            A RequestOne command was scheduled before materialization
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink.CancelScheduledBeforeMaterialization">
            <summary>
            A Cancel command was scheduled before materialization
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSink`1.#ctor(System.String,System.Action{Akka.Streams.Actors.IActorSubscriberMessage})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="externalCallback">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SubSink`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SubSink`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSink`1.PullSubstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSink`1.CancelSubstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSink`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSink`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSource">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource.Kill``2(Akka.Streams.Dsl.Source{``0,``1})">
            <summary>
            INTERNAL API
            
            HERE ACTUALLY ARE DRAGONS, YOU HAVE BEEN WARNED!
            
            FIXME #19240 (jvm)
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <param name="s">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSource`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.#ctor(System.String,System.Action{Akka.Streams.Implementation.Fusing.SubSink.ICommand})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="externalCallback">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SubSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SubSource`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.SubSource`1.ExternalCallback">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.PushSubstream(`0)">
            <summary>
            TBD
            </summary>
            <param name="elem">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.CompleteSubstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.FailSubstream(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.Timeout(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="d">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FilePublisher">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FilePublisher.Props(System.IO.FileInfo,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="chunkSize">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="initialBuffer">TBD</param>
            <param name="maxBuffer">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when one of the following conditions is met.
            
            <ul>
            <li>The specified <paramref name="chunkSize"/> is less than or equal to zero.</li>
            <li>The specified <paramref name="startPosition"/> is less than zero</li>
            <li>The specified <paramref name="initialBuffer"/> is less than or equal to zero.</li>
            <li>The specified <paramref name="maxBuffer"/> is less than the specified <paramref name="initialBuffer"/>.</li>
            </ul>
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FilePublisher.#ctor(System.IO.FileInfo,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Int64,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="chunkSize">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="maxBuffer">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FilePublisher.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FilePublisher.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FilePublisher.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSubscriber">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSubscriber.Props(System.IO.FileInfo,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Int64,System.IO.FileMode)">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="bufferSize">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="fileMode">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSubscriber.#ctor(System.IO.FileInfo,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Int64,System.IO.FileMode)">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="bufferSize">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="fileMode">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.FileSubscriber.RequestStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSubscriber.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSubscriber.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSubscriber.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamPublisher">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamPublisher.Props(System.IO.Stream,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inputstream">TBD</param>
            <param name="completionSource">TBD</param>
            <param name="chunkSize">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="chunkSize"/> is less than or equal to zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamPublisher.#ctor(System.IO.Stream,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inputstream">TBD</param>
            <param name="completionSource">TBD</param>
            <param name="chunkSize">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamPublisher.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamPublisher.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.IAdapterToStageMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.ReadElementAcknowledgement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.ReadElementAcknowledgement.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Close">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.Close.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.IStreamToAdapterMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.Data.Bytes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSinkStage.Data.#ctor(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="bytes">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Finished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.Finished.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Initialized">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.Initialized.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Failed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.InputStreamSinkStage.Failed.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSinkStage.Failed.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.IStageWithCallback">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSinkStage.IStageWithCallback.WakeUp(Akka.Streams.Implementation.IO.InputStreamSinkStage.IAdapterToStageMessage)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSinkStage.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="readTimeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamSinkStage.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamSinkStage.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSinkStage.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the maximum size of the input buffer is less than or equal to zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamAdapter">
            <summary>
            INTERNAL API
            InputStreamAdapter that interacts with InputStreamSinkStage
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.Flush">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            TBD
            </summary>
            <param name="offset">TBD</param>
            <param name="origin">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.SetLength(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="offset">TBD</param>
            <param name="count">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamAdapter.Length">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamAdapter.Position">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.#ctor(System.Collections.Concurrent.BlockingCollection{Akka.Streams.Implementation.IO.InputStreamSinkStage.IStreamToAdapterMessage},Akka.Streams.Implementation.IO.InputStreamSinkStage.IStageWithCallback,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="sharedBuffer">TBD</param>
            <param name="sendToStage">TBD</param>
            <param name="readTimeout">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.Dispose(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="disposing">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.ReadByte">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when an <see cref="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Initialized"/> message is not the first message.
            </exception>
            <exception cref="T:System.IO.IOException">
            This exception is thrown when a timeout occurs waiting on new data.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamAdapter.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="offset">TBD</param>
            <param name="count">TBD</param>
            <exception cref="T:System.ArgumentException">TBD
            This exception is thrown for a number of reasons. These include:
            <ul>
            <li>the specified <paramref name="buffer"/> size is less than or equal to zero</li>
            <li>the specified <paramref name="buffer"/> size is less than the combination of <paramref name="offset"/> and <paramref name="count"/></li>
            <li>the specified <paramref name="offset"/> is less than zero</li>
            <li>the specified <paramref name="count"/> is less than or equal to zero</li>
            </ul>
            </exception>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when an <see cref="T:Akka.Streams.Implementation.IO.InputStreamSinkStage.Initialized"/> message is not the first message.
            </exception>
            <exception cref="T:System.IO.IOException">
            This exception is thrown when a timeout occurs waiting on new data.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamAdapter.CanRead">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamAdapter.CanSeek">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamAdapter.CanWrite">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSink">
            <summary>
            INTERNAL API
            Creates simple synchronous Sink which writes all incoming elements to the given file
            (creating it before hand if necessary).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSink.#ctor(System.IO.FileInfo,System.Int64,System.IO.FileMode,Akka.Streams.Attributes,Akka.Streams.SinkShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="fileMode">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.FileSink.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.FileSink.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSink.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSink.NewInstance(Akka.Streams.SinkShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSink.Create(Akka.Streams.MaterializationContext,System.Threading.Tasks.Task{Akka.Streams.IO.IOResult}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSink">
            <summary>
            INTERNAL API
            Creates simple synchronous  Sink which writes all incoming elements to the given file
            (creating it before hand if necessary).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSink.#ctor(System.Func{System.IO.Stream},Akka.Streams.Attributes,Akka.Streams.SinkShape{Akka.IO.ByteString},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="createOutput">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
            <param name="autoFlush">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamSink.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSink.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSink.NewInstance(Akka.Streams.SinkShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSink.Create(Akka.Streams.MaterializationContext,System.Threading.Tasks.Task{Akka.Streams.IO.IOResult}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSource">
            <summary>
            INTERNAL API
            Creates simple synchronous Source backed by the given file.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSource.#ctor(System.IO.FileInfo,System.Int32,System.Int64,Akka.Streams.Attributes,Akka.Streams.SourceShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
            <param name="chunkSize">TBD</param>
            <param name="startPosition">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.FileSource.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.FileSource.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSource.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSource.NewInstance(Akka.Streams.SourceShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.FileSource.Create(Akka.Streams.MaterializationContext,System.Threading.Tasks.Task{Akka.Streams.IO.IOResult}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSource">
            <summary>
            INTERNAL API
            Source backed by the given input stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSource.#ctor(System.Func{System.IO.Stream},System.Int32,Akka.Streams.Attributes,Akka.Streams.SourceShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="createInputStream">TBD</param>
            <param name="chunkSize">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.InputStreamSource.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSource.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSource.NewInstance(Akka.Streams.SourceShape{Akka.IO.ByteString})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.InputStreamSource.Create(Akka.Streams.MaterializationContext,System.Threading.Tasks.Task{Akka.Streams.IO.IOResult}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.IAdapterToStageMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Flush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Flush.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Close">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Close.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.IDownstreamStatus">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Ok">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Ok.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Canceled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Canceled.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage.IStageWithCallback">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSourceStage.IStageWithCallback.WakeUp(Akka.Streams.Implementation.IO.OutputStreamSourceStage.IAdapterToStageMessage)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSourceStage.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="writeTimeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamSourceStage.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamSourceStage.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSourceStage.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamAdapter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            TBD
            </summary>
            <param name="offset">TBD</param>
            <param name="origin">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.SetLength(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="offset">TBD</param>
            <param name="count">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamAdapter.Length">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamAdapter.Position">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.#ctor(System.Collections.Concurrent.BlockingCollection{Akka.IO.ByteString},Akka.Util.AtomicReference{Akka.Streams.Implementation.IO.OutputStreamSourceStage.IDownstreamStatus},Akka.Streams.Implementation.IO.OutputStreamSourceStage.IStageWithCallback,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="dataQueue">TBD</param>
            <param name="downstreamStatus">TBD</param>
            <param name="stageWithCallback">TBD</param>
            <param name="writeTimeout">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.Flush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="offset">TBD</param>
            <param name="count">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamAdapter.Dispose(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="disposing">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamAdapter.CanRead">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamAdapter.CanSeek">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamAdapter.CanWrite">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSubscriber">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSubscriber.Props(System.IO.Stream,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="os">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="bufferSize">TBD</param>
            <param name="autoFlush">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSubscriber.#ctor(System.IO.Stream,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IO.IOResult},System.Int32,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="outputStream">TBD</param>
            <param name="completionPromise">TBD</param>
            <param name="bufferSize">TBD</param>
            <param name="autoFlush">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutputStreamSubscriber.RequestStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSubscriber.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutputStreamSubscriber.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.ConnectionSourceStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.ConnectionSourceStage.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Int32,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan},System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="tcpManager">TBD</param>
            <param name="endpoint">TBD</param>
            <param name="backlog">TBD</param>
            <param name="options">TBD</param>
            <param name="halfClose">TBD</param>
            <param name="idleTimeout">TBD</param>
            <param name="bindShutdownTimeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.ConnectionSourceStage.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.ConnectionSourceStage.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.ConnectionSourceStage.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.IncomingConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.IncomingConnectionStage.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="remoteAddress">TBD</param>
            <param name="halfClose">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.IncomingConnectionStage.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.IncomingConnectionStage.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.IncomingConnectionStage.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.IncomingConnectionStage.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage.ITcpRole">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.TcpConnectionStage.ITcpRole.HalfClose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound.#ctor(Akka.Actor.IActorRef,Akka.IO.Tcp.Connect,System.Threading.Tasks.TaskCompletionSource{System.Net.EndPoint},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="manager">TBD</param>
            <param name="connectCmd">TBD</param>
            <param name="localAddressPromise">TBD</param>
            <param name="halfClose">TBD</param>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound.ConnectCmd">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound.LocalAddressPromise">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.TcpConnectionStage.Outbound.HalfClose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage.Inbound">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.TcpConnectionStage.Inbound.#ctor(Akka.Actor.IActorRef,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="halfClose">TBD</param>
        </member>
        <member name="F:Akka.Streams.Implementation.IO.TcpConnectionStage.Inbound.Connection">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.TcpConnectionStage.Inbound.HalfClose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage.TcpStreamLogic">
            <summary>
            This is a *non-detached* design, i.e. this does not prefetch itself any of the inputs. It relies on downstream
            stages to provide the necessary prefetch on `bytesOut` and the framework to do the proper prefetch in the buffer
            backing `bytesIn`. If prefetch on `bytesOut` is required (i.e. user stages cannot be trusted) then it is better
            to attach an extra, fused buffer to the end of this flow. Keeping this stage non-detached makes it much simpler and
            easier to maintain and understand.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.TcpConnectionStage.TcpStreamLogic.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.TcpConnectionStage.TcpStreamLogic.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutgoingConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutgoingConnectionStage.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Net.EndPoint,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="tcpManager">TBD</param>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="options">TBD</param>
            <param name="halfClose">TBD</param>
            <param name="connectionTimeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutgoingConnectionStage.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IO.OutgoingConnectionStage.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutgoingConnectionStage.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IO.OutgoingConnectionStage.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpIdleTimeout">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.JsonObjectParser">
            <summary>
            INTERNAL API: Use <see cref="T:Akka.Streams.Dsl.JsonFraming"/> instead
            
            **Mutable** framing implementation that given any number of <see cref="T:Akka.IO.ByteString"/> chunks, can emit JSON objects contained within them.
            Typically JSON objects are separated by new-lines or commas, however a top-level JSON Array can also be understood and chunked up
            into valid JSON objects by this framing implementation.
            
            Leading whitespace between elements will be trimmed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.JsonObjectParser.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maximumObjectLength">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.JsonObjectParser.Offer(Akka.IO.ByteString)">
            <summary>
            Appends input ByteString to internal byte string buffer.
            Use <see cref="M:Akka.Streams.Implementation.JsonObjectParser.Poll"/> to extract contained JSON objects.
            </summary>
            <param name="input">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.JsonObjectParser.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.JsonObjectParser.Poll">
            <summary>
            Attempt to locate next complete JSON object in buffered <see cref="T:Akka.IO.ByteString"/> and returns it if found.
            May throw a <see cref="T:Akka.Streams.Dsl.Framing.FramingException"/> if the contained JSON is invalid or max object size is exceeded.
            </summary>
            <exception cref="T:Akka.Streams.Dsl.Framing.FramingException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.JsonObjectParser.SeekObject">
            <summary>
            Returns true if an entire valid JSON object was found, false otherwise
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ISourceModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ISourceModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ISourceModule.Create(Akka.Streams.MaterializationContext,System.Object@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SourceModule`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.#ctor(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SourceModule`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SourceModule`2.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.Create(Akka.Streams.MaterializationContext,`1@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SourceModule`2.AmendShape(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberSource`1">
            <summary>
            INTERNAL API
            Holds a `Subscriber` representing the input side of the flow. The `Subscriber` can later be connected to an upstream `Publisher`.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSource`1.#ctor(Akka.Streams.Attributes,Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SubscriberSource`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSource`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSource`1.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSource`1.Create(Akka.Streams.MaterializationContext,Reactive.Streams.ISubscriber{`0}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.PublisherSource`1">
            <summary>
            INTERNAL API
            Construct a transformation starting with given publisher. The transformation steps are executed 
            by a series of <see cref="T:Reactive.Streams.IProcessor`2"/> instances that mediate the flow of elements 
            downstream and the propagation of back-pressure upstream.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSource`1.#ctor(Reactive.Streams.IPublisher{`0},Akka.Streams.Attributes,Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.PublisherSource`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.PublisherSource`1.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSource`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSource`1.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSource`1.Create(Akka.Streams.MaterializationContext,Akka.NotUsed@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.MaybeSource`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybeSource`1.#ctor(Akka.Streams.Attributes,Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.MaybeSource`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybeSource`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybeSource`1.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaybeSource`1.Create(Akka.Streams.MaterializationContext,System.Threading.Tasks.TaskCompletionSource{`0}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorPublisherSource`1">
            <summary>
            INTERNAL API
            Creates and wraps an actor into <see cref="T:Reactive.Streams.IPublisher`1"/> from the given <see cref="T:Akka.Actor.Props"/>, which should be props for an <see cref="T:Akka.Streams.Implementation.ActorPublisher`1"/>.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisherSource`1.#ctor(Akka.Actor.Props,Akka.Streams.Attributes,Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorPublisherSource`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisherSource`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisherSource`1.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorPublisherSource`1.Create(Akka.Streams.MaterializationContext,Akka.Actor.IActorRef@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefSource`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSource`1.#ctor(System.Int32,Akka.Streams.OverflowStrategy,Akka.Streams.Attributes,Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="bufferSize">TBD</param>
            <param name="overflowStrategy">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSource`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSource`1.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSource`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSource`1.NewInstance(Akka.Streams.SourceShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSource`1.Create(Akka.Streams.MaterializationContext,Akka.Actor.IActorRef@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ISpecViolation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SignalThrewException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SignalThrewException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.SignalThrewException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.Implementation.ReactiveStreamsCompliance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.CanNotSubscribeTheSameSubscriberMultipleTimes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.SupportsOnlyASingleSubscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.NumberOfElementsInRequestMustBePositiveMsg">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.SubscriberMustNotBeNullMsg">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.ExceptionMustNotBeNullMsg">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.ElementMustNotBeNullMsg">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.SubscriptionMustNotBeNullMsg">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.NumberOfElementsInRequestMustBePositiveException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.CanNotSubscribeTheSameSubscriberMultipleTimesException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.ElementMustNotBeNullException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.ReactiveStreamsCompliance.SubscriptionMustNotBeNullException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ReactiveStreamsCompliance.SubscriberMustNotBeNullException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ReactiveStreamsCompliance.ExceptionMustNotBeNullException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnSubscribe``1(Reactive.Streams.ISubscriber{``0},Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <param name="subscription">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnSubscribe(Akka.Streams.IUntypedSubscriber,Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="subscription">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnNext``1(Reactive.Streams.ISubscriber{``0},``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <param name="element">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnNext(Akka.Streams.IUntypedSubscriber,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="element">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnError``1(Reactive.Streams.ISubscriber{``0},System.Exception)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <param name="cause">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnError(Akka.Streams.IUntypedSubscriber,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="cause">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnComplete``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryOnComplete(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RejectDuplicateSubscriber``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RejectAdditionalSubscriber``1(Reactive.Streams.ISubscriber{``0},System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <param name="rejector">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RejectAdditionalSubscriber(Akka.Streams.IUntypedSubscriber,System.String)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="rejector">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RejectDueToNonPositiveDemand``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RequireNonNullSubscriber``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RequireNonNullSubscription(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="subscription"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RequireNonNullException(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="exception">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="exception"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.RequireNonNullElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="element"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryCancel(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">
            This exception is thrown when an exception occurs while canceling the specified <paramref name="subscription"/>.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.ReactiveStreamsCompliance.TryRequest(Reactive.Streams.ISubscription,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <param name="demand">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.SignalThrewException">
            This exception is thrown when an exception occurs while requesting no events be sent to the specified <paramref name="subscription"/>.
            </exception>
        </member>
        <member name="T:Akka.Streams.Implementation.NothingToReadException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.NothingToReadException.Instance">
            <summary>
            The singleton instance of this exception
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ICursors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ICursors.Cursors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ICursor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ICursor.Cursor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1">
            <summary>
            INTERNAL API
            A mutable RingBuffer that can grow in size and supports multiple readers.
            Contrary to many other ring buffer implementations this one does not automatically overwrite the oldest
            elements, rather, if full, the buffer tries to grow and rejects further writes if max capacity is reached.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1._writeIndex">
            <summary>
            Two counters counting the number of elements ever written and read; wrap-around is
            handled by always looking at differences or masked values
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.LengthBit">
            <summary>
            Current array.length log2, we don't keep it as an extra field because <see cref="M:Akka.Streams.Util.Int32Extensions.NumberOfTrailingZeros(System.Int32)"/>
            is a JVM intrinsic compiling down to a `BSF` instruction on x86, which is very fast on modern CPUs
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.#ctor(System.Int32,System.Int32,Akka.Streams.Implementation.ICursors)">
            <summary>
            TBD
            </summary>
            <param name="initialSize">TBD</param>
            <param name="maxSize">TBD</param>
            <param name="cursors">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="F:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Cursors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.UnderlyingArray">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Length">
            <summary>
            The number of elements currently in the buffer.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.NonEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.ImmediatelyAvailable">
            <summary>
            The number of elements the buffer can still take without having to be resized.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.CapacityLeft">
            <summary>
            The maximum number of elements the buffer can still take.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Count(Akka.Streams.Implementation.ICursor)">
            <summary>
            Returns the number of elements that the buffer currently contains for the given cursor.
            </summary>
            <param name="cursor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.InitCursor(Akka.Streams.Implementation.ICursor)">
            <summary>
            Initializes the given Cursor to the oldest buffer entry that is still available.
            </summary>
            <param name="cursor">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Write(`0)">
            <summary>
            Tries to write the given value into the buffer thereby potentially growing the backing array.
            Returns true if the write was successful and false if the buffer is full and cannot grow anymore.
            </summary> 
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Read(Akka.Streams.Implementation.ICursor)">
            <summary>
            Tries to read from the buffer using the given Cursor.
            If there are no more data to be read (i.e. the cursor is already
            at writeIx) the method throws <see cref="T:Akka.Streams.Implementation.NothingToReadException"/>!
            </summary>
            <param name="cursor">TBD</param>
            <exception cref="T:Akka.Streams.Implementation.NothingToReadException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.OnCursorRemoved(Akka.Streams.Implementation.ICursor)">
            <summary>
            TBD
            </summary>
            <param name="cursor">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SinkholeSubscriber`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkholeSubscriber`1.#ctor(System.Threading.Tasks.TaskCompletionSource{Akka.NotUsed})">
            <summary>
            TBD
            </summary>
            <param name="whenCompleted">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkholeSubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkholeSubscriber`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkholeSubscriber`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkholeSubscriber`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.ISinkModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ISinkModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ISinkModule.Create(Akka.Streams.MaterializationContext,System.Object@)">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SinkModule`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.#ctor(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SinkModule`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SinkModule`2.Label">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.Create(Akka.Streams.MaterializationContext,`1@)">
            <summary>
            Create the Subscriber or VirtualPublisher that consumes the incoming
            stream, plus the materialized value. Since Subscriber and VirtualPublisher
            do not share a common supertype apart from AnyRef this is what the type
            union devolves into; unfortunately we do not have union types at our
            disposal at this point.
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SinkModule`2.AmendShape(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attrs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.PublisherSink`1">
            <summary>
            INTERNAL API
            
            Holds the downstream-most <see cref="T:Reactive.Streams.IPublisher`1"/> interface of the materialized flow.
            The stream will not have any subscribers attached at this point, which means that after prefetching
            elements to fill the internal buffers it will assert back-pressure until
            a subscriber connects and creates demand for elements to be emitted.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSink`1.#ctor(Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.PublisherSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.PublisherSink`1.Create(Akka.Streams.MaterializationContext,Reactive.Streams.IPublisher{`0}@)">
            <summary>
            This method is the reason why SinkModule.create may return something that is
            not a Subscriber: a VirtualPublisher is used in order to avoid the immediate
            subscription a VirtualProcessor would perform (and it also saves overhead).
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FanoutPublisherSink`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutPublisherSink`1.#ctor(Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.FanoutPublisherSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutPublisherSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutPublisherSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FanoutPublisherSink`1.Create(Akka.Streams.MaterializationContext,Reactive.Streams.IPublisher{`0}@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberSink`1">
            <summary>
            INTERNAL API
            
            Attaches a subscriber to this stream.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSink`1.#ctor(Reactive.Streams.ISubscriber{`0},Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SubscriberSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberSink`1.Create(Akka.Streams.MaterializationContext,Akka.NotUsed@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.CancelSink`1">
            <summary>
            INTERNAL API
            
            A sink that immediately cancels its upstream upon materialization.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelSink`1.#ctor(Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.CancelSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelSink`1.Create(Akka.Streams.MaterializationContext,Akka.NotUsed@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorSubscriberSink`1">
            <summary>
            INTERNAL API
            
            Creates and wraps an actor into <see cref="T:Reactive.Streams.ISubscriber`1"/> from the given <see cref="T:Akka.Actor.Props"/>,
            which should be <see cref="T:Akka.Actor.Props"/> for an <see cref="T:Akka.Streams.Actors.ActorSubscriber"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriberSink`1.#ctor(Akka.Actor.Props,Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorSubscriberSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriberSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriberSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorSubscriberSink`1.Create(Akka.Streams.MaterializationContext,Akka.Actor.IActorRef@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefSink`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSink`1.#ctor(Akka.Actor.IActorRef,System.Object,Akka.Streams.Attributes,Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
            <param name="onCompleteMessage">TBD</param>
            <param name="attributes">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ActorRefSink`1.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSink`1.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSink`1.NewInstance(Akka.Streams.SinkShape{`0})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorRefSink`1.Create(Akka.Streams.MaterializationContext,Akka.NotUsed@)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="materializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.LastOrDefaultStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.LastOrDefaultStage`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LastOrDefaultStage`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LastOrDefaultStage`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LastOrDefaultStage`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.FirstOrDefaultStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.FirstOrDefaultStage`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FirstOrDefaultStage`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FirstOrDefaultStage`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FirstOrDefaultStage`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SeqStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SeqStage`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SeqStage`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SeqStage`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SeqStage`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SeqStage`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SeqStage`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSink`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.QueueSink`1.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSink`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSink`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSink`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSink`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSink`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.LazySink`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySink`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{Akka.Streams.Dsl.Sink{`0,`1}}},System.Func{`1})">
            <summary>
            TBD
            </summary>
            <param name="sinkFactory">TBD</param>
            <param name="zeroMaterialised">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySink`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySink`2.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySink`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySink`2.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySink`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1.IInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1.Offer`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Offer`1.#ctor(`1,System.Threading.Tasks.TaskCompletionSource{Akka.Streams.IQueueOfferResult})">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <param name="completionSource">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Offer`1.Element">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Offer`1.CompletionSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1.Completion">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Completion.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1.Failure">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Failure.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Failure.Ex">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.QueueSource`1.Materialized">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Materialized.#ctor(System.Action{Akka.Streams.Implementation.QueueSource{`0}.IInput},System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="invokeLogic">TBD</param>
            <param name="completion">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Materialized.OfferAsync(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Materialized.WatchCompletionAsync">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Materialized.Complete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.Materialized.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.#ctor(System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            TBD
            </summary>
            <param name="maxBuffer">TBD</param>
            <param name="overflowStrategy">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.QueueSource`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.QueueSource`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.UnfoldResourceSource`2">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSource`2.#ctor(System.Func{`1},System.Func{`1,Akka.Util.Option{`0}},System.Action{`1})">
            <summary>
            TBD
            </summary>
            <param name="create">TBD</param>
            <param name="readData">TBD</param>
            <param name="close">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSource`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSource`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSource`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSource`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSource`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TSource">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.#ctor(System.Func{System.Threading.Tasks.Task{`1}},System.Func{`1,System.Threading.Tasks.Task{Akka.Util.Option{`0}}},System.Func{`1,System.Threading.Tasks.Task})">
            <summary>
            TBD
            </summary>
            <param name="create">TBD</param>
            <param name="readData">TBD</param>
            <param name="close">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldResourceSourceAsync`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.LazySource`2">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySource`2.#ctor(System.Func{Akka.Streams.Dsl.Source{`0,`1}})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.Implementation.LazySource`2"/>
            </summary>
            <param name="sourceFactory">The factory that generates the source when needed</param>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySource`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySource`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LazySource`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySource`2.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySource`2.ToString">
            <summary>
            Returns the string representation of the <see cref="T:Akka.Streams.Implementation.LazySource`2"/>
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.LazySource">
            <summary>
            API for the <see cref="T:Akka.Streams.Implementation.LazySource`2"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LazySource.Create``2(System.Func{Akka.Streams.Dsl.Source{``0,``1}})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.Implementation.LazySource`2"/> for the given <paramref name="create"/> factory
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.EmptySource`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EventWrapper`2.#ctor(System.Action{`0},System.Action{`0},System.Func{System.Action{`1},`0})">
            <summary>
            Creates a new instance of EventWrapper - an object wrapping C# events with an observable object.
            </summary>
            <param name="conversion">Function used to convert given event handler to delegate compatible with underlying .NET event.</param>
            <param name="addHandler">Action which attaches given event handler to the underlying .NET event.</param>
            <param name="removeHandler">Action which detaches given event handler to the underlying .NET event.</param>
        </member>
        <member name="T:Akka.Streams.Implementation.ObservableSourceStage`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.DefaultAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.IODispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Fused">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Select">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Where">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Collect">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Sum">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Recover">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.RecoverWith">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.MapAsync">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.MapAsyncUnordered">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Grouped">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Limit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.LimitWeighted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Sliding">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Take">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Drop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Skip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.TakeWhile">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.SkipWhile">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Scan">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ScanAsync">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Aggregate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.AggregateAsync">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Buffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Batch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.BatchWeighted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Conflate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Expand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.StatefulSelectMany">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.GroupBy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.PrefixAndTail">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Split">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ConcatAll">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Processor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ProcessorWithKey">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.IdentityOp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.DelimiterFraming">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Initial">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Completion">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Idle">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.IdleTimeoutBidi">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.DelayInitial">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.IdleInject">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.BackpressureTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Merge">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.MergePreferred">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FlattenMerge">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Broadcast">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Balance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Zip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Unzip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Concat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.OrElse">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Repeat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Unfold">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.UnfoldAsync">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.UnfoldInf">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.UnfoldResourceSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.UnfoldResourceSourceAsync">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.TerminationWatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.Delay">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ZipN">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ZipWithN">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ZipWithIndex">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.PublisherSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.EnumerableSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.CycledSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.TaskSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.TickSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.SingleSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.EmptySource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.MaybeSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FailedSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ConcatSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ConcatMaterializedSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.SubscriberSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ActorPublisherSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ActorRefSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.QueueSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.InputStreamSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.OutputStreamSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FileSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.SubscriberSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.CancelledSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FirstSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FirstOrDefaultSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.LastSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.LastOrDefaultSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.PublisherSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FanoutPublisherSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.IgnoreSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ActorRefSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ActorRefWithAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.ActorSubscriberSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.QueueSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.LazySink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.LazySource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.InputStreamSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.OutputStreamSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.FileSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Stages.DefaultAttributes.SeqSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.SymbolicGraphStage`2">
            <summary>
            Stage that is backed by a GraphStage but can be symbolically introspected
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.SymbolicGraphStage`2.#ctor(Akka.Streams.Implementation.Stages.ISymbolicStage{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="symbolicStage">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.ISymbolicStage`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Implementation.Stages.ISymbolicStage`2.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.ISymbolicStage`2.Create(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="effectiveAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.SymbolicStage`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.SymbolicStage`2.#ctor(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Stages.SymbolicStage`2.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.SymbolicStage`2.Create(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="effectiveAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.SymbolicStage`2.Supervision(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.FirstOrDefault`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.FirstOrDefault`1.#ctor(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="throwOnDefault">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Stages.FirstOrDefault`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.FirstOrDefault`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.FirstOrDefault`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.LastOrDefault`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.LastOrDefault`1.#ctor(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="throwOnDefault">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Stages.LastOrDefault`1.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.LastOrDefault`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Stages.LastOrDefault`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.IsDebug">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout.Combine">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Combine.Combinator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Combine.Left">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Combine.Right">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Combine.#ctor(System.Func{System.Object,System.Object,System.Object},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode)">
            <summary>
            TBD
            </summary>
            <param name="combinator">TBD</param>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Combine.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout.Atomic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Atomic.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Atomic.#ctor(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Atomic.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout.Transform">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Transform.Transformator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Transform.Node">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Transform.#ctor(System.Func{System.Object,System.Object},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode)">
            <summary>
            TBD
            </summary>
            <param name="transformator">TBD</param>
            <param name="node">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Transform.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamLayout.Ignore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.StreamLayout.Ignore.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Ignore.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamLayout.Validate(Akka.Streams.Implementation.IModule,System.Int32,System.Boolean,System.Collections.Generic.IDictionary{System.Object,System.Int32})">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <param name="level">TBD</param>
            <param name="shouldPrint">TBD</param>
            <param name="idMap">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.IgnorableMaterializedValueComposites">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IgnorableMaterializedValueComposites.Apply(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode)">
            <summary>
            TBD
            </summary>
            <param name="composition">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IgnorableMaterializedValueComposites.Apply(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            Verify that the given Shape has the same ports and return a new module with that shape.
            Concrete implementations may throw UnsupportedOperationException where applicable.
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.InPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.OutPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsRunnable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsBidiFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsAtomic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsCopied">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Fuse(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            Fuses this Module to <paramref name="that"/> Module by wiring together <paramref name="from"/> and <paramref name="to"/>,
            retaining the materialized value of `this` in the result
            </summary>
            <param name="that">A module to fuse with</param>
            <param name="from">The data source to wire</param>
            <param name="to">The data sink to wire</param>
            <returns>A module representing fusion of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Fuse``3(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort,System.Func{``0,``1,``2})">
            <summary>
            Fuses this Module to <paramref name="that"/> Module by wiring together <paramref name="from"/> and <paramref name="to"/>,
            retaining the materialized value of `this` in the result, using the provided function <paramref name="matFunc"/>.
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="that">A module to fuse with</param>
            <param name="from">The data source to wire</param>
            <param name="to">The data sink to wire</param>
            <param name="matFunc">The function to apply to the materialized values</param>
            <returns>A module representing fusion of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Wire(Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            Creates a new Module based on the current Module but with the given OutPort wired to the given InPort.
            </summary>
            <param name="from">The OutPort to wire.</param>
            <param name="to">The InPort to wire.</param>
            <returns>A new Module with the ports wired</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.TransformMaterializedValue``2(System.Func{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Compose(Akka.Streams.Implementation.IModule)">
            <summary>
            Creates a new Module which is this Module composed with <paramref name="that"/> Module.
            </summary>
            <param name="that">A Module to be composed with (cannot be itself)</param>
            <returns>A Module that represents the composition of this and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Compose``3(Akka.Streams.Implementation.IModule,System.Func{``0,``1,``2})">
            <summary>
            Creates a new Module which is this Module composed with <paramref name="that"/> Module,
            using the given function <paramref name="matFunc"/> to compose the materialized value of `this` with
            the materialized value of <paramref name="that"/>.
            </summary>
            <param name="that">A Module to be composed with (cannot be itself)</param>
            <param name="matFunc">A function which combines the materialized values</param>
            <typeparam name="T1">The type of the materialized value of this</typeparam>
            <typeparam name="T2">The type of the materialized value of <paramref name="that"/></typeparam>
            <typeparam name="T3">The type of the materialized value of the returned Module</typeparam>
            <returns>A Module that represents the composition of this and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.ComposeNoMaterialized(Akka.Streams.Implementation.IModule)">
             <summary>
             Creates a new Module which is this Module composed with <paramref name="that"/> Module.
            
             The difference to compose(that) is that this version completely ignores the materialized value
             computation of <paramref name="that"/> while the normal version executes the computation and discards its result.
             This means that this version must not be used for user-provided <paramref name="that"/> modules because users may
             transform materialized values only to achieve some side-effect; it can only be
             used where we know that there is no meaningful computation to be done (like for
             MaterializedValueSource).
             </summary>
             <param name="that">a Module to be composed with (cannot be itself)</param>
             <returns>a Module that represents the composition of this and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Nest">
            <summary>
            Creates a new Module which contains this Module
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.IsSealed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.InPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.OutPorts">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsRunnable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsSink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsSource">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsBidiFlow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsAtomic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsCopied">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsFused">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Fuse(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Fuse``3(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort,System.Func{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="other">TBD</param>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
            <param name="matFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Wire(Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.TransformMaterializedValue``2(System.Func{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Compose(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Compose``3(Akka.Streams.Implementation.IModule,System.Func{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="other">TBD</param>
            <param name="matFunc">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.ComposeNoMaterialized(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.Nest">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.IsSealed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.Module.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Module.CompareTo(Akka.Streams.Implementation.IModule)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Implementation.EmptyModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.EmptyModule.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.IsAtomic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.IsRunnable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.Compose(Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.Compose``3(Akka.Streams.Implementation.IModule,System.Func{``0,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <param name="other">TBD</param>
            <param name="matFunc">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.Nest">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.EmptyModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.EmptyModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.CopiedModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CopiedModule.#ctor(Akka.Streams.Shape,Akka.Streams.Attributes,Akka.Streams.Implementation.IModule)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <param name="attributes">TBD</param>
            <param name="copyOf">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.CopyOf">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.IsCopied">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CopiedModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CopiedModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CopiedModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CopiedModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CopiedModule.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Implementation.CompositeModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.#ctor(System.Collections.Immutable.ImmutableArray{Akka.Streams.Implementation.IModule},Akka.Streams.Shape,System.Collections.Immutable.IImmutableDictionary{Akka.Streams.OutPort,Akka.Streams.InPort},System.Collections.Immutable.IImmutableDictionary{Akka.Streams.InPort,Akka.Streams.OutPort},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="subModules">TBD</param>
            <param name="shape">TBD</param>
            <param name="downstreams">TBD</param>
            <param name="upstreams">TBD</param>
            <param name="materializedValueComputation">TBD</param>
            <param name="attributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.CompositeModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.Create(Akka.Streams.Implementation.Module,Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.CompositeModule.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Implementation.StructuralInfoModule">
            <summary>
            When fusing a <see cref="T:Akka.Streams.IGraph`1"/> a part of the internal stage wirings are hidden within
            <see cref="T:Akka.Streams.Implementation.Fusing.GraphAssembly"/> objects that are
            optimized for high-speed execution. This structural information bundle contains
            the wirings in a more accessible form, allowing traversal from port to upstream
            or downstream port and from there to the owning module (or graph vertex).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StructuralInfoModule.#ctor(System.Collections.Immutable.ImmutableArray{Akka.Streams.Implementation.IModule},Akka.Streams.Shape,System.Collections.Immutable.IImmutableDictionary{Akka.Streams.OutPort,Akka.Streams.InPort},System.Collections.Immutable.IImmutableDictionary{Akka.Streams.InPort,Akka.Streams.OutPort},System.Collections.Immutable.IImmutableDictionary{Akka.Streams.InPort,Akka.Streams.Implementation.IModule},System.Collections.Immutable.IImmutableDictionary{Akka.Streams.OutPort,Akka.Streams.Implementation.IModule},System.Collections.Immutable.IImmutableList{System.ValueTuple{Akka.Streams.Implementation.IModule,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode}},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="subModules">TBD</param>
            <param name="shape">TBD</param>
            <param name="downstreams">TBD</param>
            <param name="upstreams">TBD</param>
            <param name="inOwners">TBD</param>
            <param name="outOwners">TBD</param>
            <param name="materializedValues">TBD</param>
            <param name="materializedValueComputation">TBD</param>
            <param name="attributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.IsFused">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.InOwners">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.OutOwners">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.StructuralInfoModule.MaterializedValues">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StructuralInfoModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StructuralInfoModule.CarbonCopy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StructuralInfoModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FusedModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FusedModule.#ctor(System.Collections.Immutable.ImmutableArray{Akka.Streams.Implementation.IModule},Akka.Streams.Shape,System.Collections.Immutable.IImmutableDictionary{Akka.Streams.OutPort,Akka.Streams.InPort},System.Collections.Immutable.IImmutableDictionary{Akka.Streams.InPort,Akka.Streams.OutPort},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Attributes,Akka.Streams.Implementation.StructuralInfoModule)">
            <summary>
            TBD
            </summary>
            <param name="subModules">TBD</param>
            <param name="shape">TBD</param>
            <param name="downstreams">TBD</param>
            <param name="upstreams">TBD</param>
            <param name="materializedValueComputation">TBD</param>
            <param name="attributes">TBD</param>
            <param name="info">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.Info">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.IsFused">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.MaterializedValueComputation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.FusedModule.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FusedModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FusedModule.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FusedModule.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.FusedModule.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Implementation.AtomicModule">
            <summary>
            This is the only extension point for the sealed type hierarchy: composition
            (i.e. the module tree) is managed strictly within this file, only leaf nodes
            may be declared elsewhere.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.AtomicModule.SubModules">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.AtomicModule.Downstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.AtomicModule.Upstreams">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.VirtualProcessor`1">
            <summary>
            INTERNAL API
            
            This is a transparent processor that shall consume as little resources as
            possible. Due to the possibility of receiving uncoordinated inputs from both
            downstream and upstream, this needs an atomic state machine which looks a
            little like this:
            
            <![CDATA[
                       +--------------+      (2)    +------------+
                       |     null     | ----------> | Subscriber |
                       +--------------+             +------------+
                              |                           |
                          (1) |                           | (1)
                             \|/                         \|/
                       +--------------+      (2)    +------------+ --\
                       | Subscription | ----------> |    Both    |    | (4)
                       +--------------+             +------------+ <-/
                              |                           |
                          (3) |                           | (3)
                             \|/                         \|/
                       +--------------+      (2)    +------------+ --\
                       |   Publisher  | ----------> |   Inert    |    | (4, *)
                       +--------------+             +------------+ <-/
            ]]>
            The idea is to keep the major state in only one atomic reference. The actions
            that can happen are:
            
             (1) onSubscribe
             (2) subscribe
             (3) onError / onComplete
             (4) onNext
                 (*) Inert can be reached also by cancellation after which onNext is still fine
                     so we just silently ignore possible spec violations here
            
            Any event that occurs in a state where no matching outgoing arrow can be found
            is a spec violation, leading to the shutdown of this processor (meaning that
            the state is updated such that all following actions match that of a failed
            Publisher or a cancelling Subscriber, and the non-guilty party is informed if
            already connected).
            
            request() can only be called after the Subscriber has received the Subscription
            and that also means that onNext() will only happen after having transitioned into
            the Both state as well. The Publisher state means that if the real
            Publisher terminates before we get the Subscriber, we can just forget about the
            real one and keep an already finished one around for the Subscriber.
            
            The Subscription that is offered to the Subscriber must cancel the original
            Publisher if things go wrong (like `request(0)` coming in from downstream) and
            it must ensure that we drop the Subscriber reference when `cancel` is invoked.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualProcessor`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <exception cref="T:System.Exception">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualProcessor`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
            <exception cref="T:System.Exception">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualProcessor`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <exception cref="T:System.Exception">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualProcessor`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualProcessor`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <exception cref="T:System.Exception">TBD</exception>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.VirtualPublisher`1">
            <summary>
            INTERNAL API
            
            The implementation of <see cref="M:Akka.Streams.Dsl.Sink.AsPublisher``1(System.Boolean)"/> needs to offer a <see cref="T:Reactive.Streams.IPublisher`1"/> that
            defers to the upstream that is connected during materialization. This would
            be trivial if it were not for materialized value computations that may even
            spawn the code that does <see cref="M:Reactive.Streams.IPublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})"/> in a Future, running concurrently
            with the actual materialization. Therefore we implement a minimal shell here
            that plugs the downstream and the upstream together as soon as both are known.
            Using a VirtualProcessor would technically also work, but it would defeat the
            purpose of subscription timeoutsï¿½the subscription would always already be
            established from the Actorï¿½s perspective, regardless of whether a downstream
            will ever be connected.
            
            One important consideration is that this <see cref="T:Reactive.Streams.IPublisher`1"/> must not retain a reference
            to the <see cref="T:Reactive.Streams.ISubscriber`1"/> after having hooked it up with the real <see cref="T:Reactive.Streams.IPublisher`1"/>, hence
            the use of `Inert.subscriber` as a tombstone.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualPublisher`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualPublisher`1.RegisterPublisher(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.VirtualPublisher`1.RegisterPublisher(Reactive.Streams.IPublisher{`0})">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.MaterializerSession">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.MaterializerSession.IsDebug">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.MaterializerSession.MaterializationPanicException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.MaterializationPanicException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.MaterializerSession.MaterializationPanicException"/> class.
            </summary>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="F:Akka.Streams.Implementation.MaterializerSession.TopLevel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.MaterializerSession.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.MaterializerSession._moduleStack">
             <summary>
             Please note that this stack keeps track of the scoped modules wrapped in CopiedModule but not the CopiedModule
             itself. The reason is that the CopiedModule itself is only needed for the enterScope and exitScope methods but
             not elsewhere. For this reason they are just simply passed as parameters to those methods.
            
             The reason why the encapsulated (copied) modules are stored as mutable state to save subclasses of this class
             from passing the current scope around or even knowing about it.
             </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.#ctor(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="topLevel">TBD</param>
            <param name="initialAttributes">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.EnterScope(Akka.Streams.Implementation.CopiedModule)">
            <summary>
             Enters a copied module and establishes a scope that prevents internals to leak out and interfere with copies
             of the same module.
             We don't store the enclosing CopiedModule itself as state since we don't use it anywhere else than exit and enter
             </summary>
             <param name="enclosing">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.ExitScope(Akka.Streams.Implementation.CopiedModule)">
            <summary>
            Exits the scope of the copied module and propagates Publishers/Subscribers to the enclosing scope assigning
            them to the copied ports instead of the original ones (since there might be multiple copies of the same module
            leading to port identity collisions)
            We don't store the enclosing CopiedModule itself as state since we don't use it anywhere else than exit and enter
            </summary>
            <param name="enclosing">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.Materialize">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.MergeAttributes(Akka.Streams.Attributes,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
            <param name="current">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.RegisterSource(Akka.Streams.Implementation.Fusing.IMaterializedValueSource)">
            <summary>
            TBD
            </summary>
            <param name="materializedSource">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.MaterializeModule(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="module">TBD</param>
            <param name="effectiveAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.MaterializeComposite(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="composite">TBD</param>
            <param name="effectiveAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.MaterializeAtomic(Akka.Streams.Implementation.AtomicModule,Akka.Streams.Attributes,System.Collections.Generic.IDictionary{Akka.Streams.Implementation.IModule,System.Object})">
            <summary>
            TBD
            </summary>
            <param name="atomic">TBD</param>
            <param name="effectiveAttributes">TBD</param>
            <param name="materializedValues">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.AssignPort(Akka.Streams.InPort,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="inPort">TBD</param>
            <param name="subscriberOrVirtual">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.AssignPort(Akka.Streams.OutPort,Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="outPort">TBD</param>
            <param name="publisher">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IProcessorModule">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IProcessorModule.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IProcessorModule.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IProcessorModule.CreateProcessor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ProcessorModule`3">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.ProcessorModule`3.#ctor(System.Func{System.ValueTuple{Reactive.Streams.IProcessor{`0,`1},`2}},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="createProcessor">TBD</param>
            <param name="attributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ProcessorModule`3.In">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ProcessorModule`3.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ProcessorModule`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ProcessorModule`3.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ProcessorModule`3.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.ProcessorModule`3.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ProcessorModule`3.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.ProcessorModule`3.CreateProcessor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SinkRefImpl">
            <summary>
            Abstract class defined serialization purposes of <see cref="T:Akka.Streams.Implementation.StreamRef.SinkRefImpl`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SinkRefStageImpl`1">
             <summary>
             INTERNAL API: Actual stage implementation backing <see cref="T:Akka.Streams.ISinkRef`1"/>s.
            
             If initialPartnerRef is set, then the remote side is already set up. If it is none, then we are the side creating
             the ref.
             </summary>
             <typeparam name="TIn"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SourceRefImpl">
            <summary>
            Abstract class defined serialization purposes of <see cref="T:Akka.Streams.Implementation.StreamRef.SourceRefImpl`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SourceRefImpl`1">
            <summary>
            INTERNAL API:  Implementation class, not intended to be touched directly by end-users.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SourceRefStageImpl`1">
            <summary>
            INTERNAL API: Actual stage implementation backing [[SourceRef]]s.
            
            If initialPartnerRef is set, then the remote side is already set up.
            If it is none, then we are the side creating the ref.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.StreamRef.SourceRefStageImpl`1.Logic.ObserveAndValidateSender(Akka.Actor.IActorRef,System.String)">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Streams.InvalidPartnerActorException"> Thrown when <paramref name="partner"/> is invalid</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.SequencedOnNext">
            <summary>
            Sequenced <see cref="M:Reactive.Streams.ISubscriber`1.OnNext(`0)"/> equivalent.
            The receiving end of these messages MUST fail the stream if it observes gaps in the sequence,
            as these messages will not be re-delivered.
            
            Sequence numbers start from `0`.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.OnSubscribeHandshake">
            <summary>
            Initial message sent to remote side to establish partnership between origin and remote stream refs.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.RemoteStreamFailure">
            <summary>
            Sent to a the receiver side of a stream ref, once the sending side of the SinkRef gets signalled a Failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.RemoteStreamCompleted">
            <summary>
            Sent to a the receiver side of a stream ref, once the sending side of the SinkRef gets signalled a completion.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.StreamRef.CumulativeDemand">
            <summary>
            INTERNAL API: Cumulative demand, equivalent to sequence numbering all events in a stream.
            
            This message may be re-delivered.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriptionTimeoutException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriptionTimeoutException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.SubscriptionTimeoutException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriptionTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.SubscriptionTimeoutException"/> class.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.Implementation.CancelingSubscriber`1">
            <summary>
            A subscriber who calls <see cref="M:Reactive.Streams.ISubscription.Cancel"/> directly from <see cref="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)"/> and ignores all other callbacks.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.CancelingSubscriber`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnNext(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.NoopSubscriptionTimeout">
            <summary>
            INTERNAL API
            
            Subscription timeout which does not start any scheduled events and always returns `true`.
            This specialized implementation is to be used for "noop" timeout mode.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.NoopSubscriptionTimeout.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.NoopSubscriptionTimeout.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.NoopSubscriptionTimeout.IsCancellationRequested">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.NoopSubscriptionTimeout.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.NoopSubscriptionTimeout.CancelAfter(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.NoopSubscriptionTimeout.CancelAfter(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="millisecondsDelay">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.NoopSubscriptionTimeout.Cancel(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="throwOnFirstException">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport">
            <summary>
            INTERNAL API
            Provides support methods to create Publishers and Subscribers which time-out gracefully,
            and are cancelled subscribing an <see cref="T:Akka.Streams.Implementation.CancellingSubscriber`1"/> to the publisher, or by calling onError on the timed-out subscriber.
            
            See "akka.stream.materializer.subscription-timeout" for configuration options.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.SubscriptionTimeoutSettings">
            <summary>
            Default settings for subscription timeouts.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.ScheduleSubscriptionTimeout(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Schedules a Subscription timeout.
            The actor will receive the message created by the provided block if the timeout triggers.
            </summary>
            <param name="actorRef">TBD</param>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.SubscriptionTimedOut(Akka.Streams.IUntypedPublisher)">
            <summary>
            Called by the actor when a subscription has timed out. Expects the actual <see cref="T:Akka.Streams.IUntypedPublisher"/> or <see cref="T:Reactive.Streams.IProcessor`2"/> target.
            </summary>
            <param name="target">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.HandleSubscriptionTimeout(Akka.Streams.IUntypedPublisher,System.Exception)">
            <summary>
            Callback that should ensure that the target is canceled with the given cause.
            </summary>
            <param name="target">TBD</param>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IMergeBack`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.IMergeBack`2.Apply``1(Akka.Streams.Dsl.Flow{`0,``0,`1},System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="breadth">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SubFlowImpl`4">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
            <typeparam name="TClosed">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.#ctor(Akka.Streams.Dsl.Flow{`0,`1,`2},Akka.Streams.Implementation.IMergeBack{`0,`2},System.Func{Akka.Streams.Dsl.Sink{`0,`2},`3})">
            <summary>
            TBD
            </summary>
            <param name="flow">TBD</param>
            <param name="mergeBackFunction">TBD</param>
            <param name="finishFunction">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SubFlowImpl`4.Flow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="flow">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,``0},``1},System.Func{`2,``1,``2})">
            <summary>
            TBD
            </summary>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="TMat2">TBD</typeparam>
            <typeparam name="TMat3">TBD</typeparam>
            <param name="flow">TBD</param>
            <param name="combine">TBD</param>
            <exception cref="T:System.NotImplementedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.MapMaterializedValue``1(System.Func{`2,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="mapFunc">TBD</param>
            <exception cref="T:System.NotImplementedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0},Akka.Streams.IMaterializer)">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <param name="materializer">TBD</param>
            <exception cref="T:System.NotImplementedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TMat2">TBD</typeparam>
            <param name="sink">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.MergeSubstreamsWithParallelism(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="parallelism">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to the given ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
            <param name="attributes">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.ISubscriptionWithCursor`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Implementation.ISubscriptionWithCursor`1.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ISubscriptionWithCursor`1.Dispatch(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.ISubscriptionWithCursor`1.IsActive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ISubscriptionWithCursor`1.TotalDemand">
            <summary>
             Do not increment directly, use <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)"/> instead (it provides overflow protection)!
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement.IEndOfStream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement.IEndOfStream.Apply``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement.NotReached">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SubscriberManagement.NotReached.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement.NotReached.Apply``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement.Completed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SubscriberManagement.Completed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement.Completed.Apply``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement.ErrorCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.SubscriberManagement.ErrorCompleted.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement.ErrorCompleted.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement.ErrorCompleted.Apply``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
        </member>
        <member name="F:Akka.Streams.Implementation.SubscriberManagement.ShutDown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberManagement`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SubscriberManagement`1.InitialBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SubscriberManagement`1.MaxBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.SubscriberManagement`1.Cursors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.RequestFromUpstream(System.Int64)">
            <summary>
            Called when we are ready to consume more elements from our upstream.
            MUST NOT call <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.PushToDownstream(`0)"/>.
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CancelUpstream">
            <summary>
            Called before <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.Shutdown(System.Boolean)"/> if the stream is *not* being regularly completed
            but shut-down due to the last subscriber having cancelled its subscription
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.Shutdown(System.Boolean)">
            <summary>
            Called when the spi.Publisher/Processor is ready to be shut down.
            </summary>
            <param name="isCompleted">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CreateSubscription(Reactive.Streams.ISubscriber{`0})">
            <summary>
            Use to register a subscriber
            </summary>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)">
            <summary>
            More demand was signaled from a given subscriber.
            </summary>
            <param name="subscription">TBD</param>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.PushToDownstream(`0)">
            <summary>
            This method must be called by the implementing class whenever a new value is available to be pushed downstream.
            </summary>
            <param name="value">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CompleteDownstream">
            <summary>
            This method must be called by the implementing class whenever
            it has been determined that no more elements will be produced
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.AbortDownstream(System.Exception)">
            <summary>
            This method must be called by the implementing class to push an error downstream.
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.RegisterSubscriber(Reactive.Streams.ISubscriber{`0})">
            <summary>
            Register a new subscriber.
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.UnregisterSubscription(Akka.Streams.Implementation.ISubscriptionWithCursor{`0})">
            <summary>
            Called from <see cref="M:Reactive.Streams.ISubscription.Cancel"/>, i.e. from another thread,
            override to add synchronization with itself, <see cref="T:Akka.Streams.Actors.Subscribe`1"/> and <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)"/>
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Throttle`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.Throttle`1.#ctor(System.Int32,System.TimeSpan,System.Int32,System.Func{`0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            TBD
            </summary>
            <param name="cost">TBD</param>
            <param name="per">TBD</param>
            <param name="maximumBurst">TBD</param>
            <param name="costCalculation">TBD</param>
            <param name="mode">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Throttle`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Throttle`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Timers">
            <summary>
            INTERNAL API
            
            Various stages for controlling timeouts on IO related streams (although not necessarily).
            
            The common theme among the processing stages here that
             - they wait for certain event or events to happen
             - they have a timer that may fire before these events
             - if the timer fires before the event happens, these stages all fail the stream
             - otherwise, these streams do not interfere with the element flow, ordinary completion or failure
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Timers.IdleTimeoutCheckInterval(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Implementation.Timers.GraphStageLogicTimer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Initial`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Initial`1.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Initial`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Initial`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Initial`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Initial`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Completion`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Completion`1.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Completion`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Completion`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Completion`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Completion`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.Idle`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Idle`1.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Idle`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Idle`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Idle`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Idle`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.BackpressureTimeout`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.BackpressureTimeout`1.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BackpressureTimeout`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.BackpressureTimeout`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.BackpressureTimeout`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.BackpressureTimeout`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IdleTimeoutBidi`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.IdleTimeoutBidi`2.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IdleTimeoutBidi`2.In1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IdleTimeoutBidi`2.In2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IdleTimeoutBidi`2.Out1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.IdleTimeoutBidi`2.Out2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleTimeoutBidi`2.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IdleTimeoutBidi`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IdleTimeoutBidi`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleTimeoutBidi`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleTimeoutBidi`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.DelayInitial`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.DelayInitial`1.Delay">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.DelayInitial`1.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.DelayInitial`1.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.DelayInitial`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.DelayInitial`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IdleInject`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleInject`2.#ctor(System.TimeSpan,System.Func{`1})">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
            <param name="inject">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IdleInject`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IdleInject`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleInject`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IdleInject`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubReceive.#ctor(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="initial">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.SubReceive.CurrentReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubReceive.Become(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IInputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.NeedsInput">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.NeedsInputOrComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IInputs.DequeueInputElement">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IInputs.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.IsOpen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.AreInputsDepleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IInputs.AreInputsAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.DefaultInputTransferStates">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.DefaultInputTransferStates.NeedsInput(Akka.Streams.Implementation.IInputs)">
            <summary>
            TBD
            </summary>
            <param name="inputs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.DefaultInputTransferStates.NeedsInputOrComplete(Akka.Streams.Implementation.IInputs)">
            <summary>
            TBD
            </summary>
            <param name="inputs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.IOutputs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.SubReceive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.NeedsDemand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.NeedsDemandOrCancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.DemandCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.IsDemandAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IOutputs.EnqueueOutputElement(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IOutputs.Complete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IOutputs.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IOutputs.Error(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IOutputs.IsOpen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.DefaultOutputTransferStates">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.DefaultOutputTransferStates.NeedsDemand(Akka.Streams.Implementation.IOutputs)">
            <summary>
            TBD
            </summary>
            <param name="outputs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.DefaultOutputTransferStates.NeedsDemandOrCancel(Akka.Streams.Implementation.IOutputs)">
            <summary>
            TBD
            </summary>
            <param name="outputs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.TransferState.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.TransferState.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.TransferState.IsExecutable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.TransferState.Or(Akka.Streams.Implementation.TransferState)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.TransferState.And(Akka.Streams.Implementation.TransferState)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.LambdaTransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LambdaTransferState.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.LambdaTransferState.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.LambdaTransferState.#ctor(System.Func{System.Boolean},System.Func{System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="isReady">TBD</param>
            <param name="isCompleted">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Completed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Completed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Completed.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Completed.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.NotInitialized">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.NotInitialized.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.NotInitialized.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.NotInitialized.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.WaitingForUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.WaitingForUpstreamSubscription.Remaining">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.WaitingForUpstreamSubscription.AndThen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.WaitingForUpstreamSubscription.#ctor(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="remaining">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.WaitingForUpstreamSubscription.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.WaitingForUpstreamSubscription.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Always">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Always.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Always.IsReady">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Always.IsCompleted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.TransferPhase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.TransferPhase.Precondition">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.TransferPhase.Action">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.TransferPhase.#ctor(Akka.Streams.Implementation.TransferState,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="precondition">TBD</param>
            <param name="action">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.IPump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IPump.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IPump.CurrentAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IPump.IsPumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.InitialPhase(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.WaitForUpstream(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.GotUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.NextPhase(Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.PumpFailed(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.IPump.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.PumpBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Implementation.PumpBase" /> class.
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the pump has not been initialized with a phase.
            </exception>
        </member>
        <member name="P:Akka.Streams.Implementation.PumpBase.TransferState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.PumpBase.CurrentAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.PumpBase.IsPumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.InitialPhase(System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.WaitForUpstream(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="waitForUpstream">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.GotUpstreamSubscription">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.NextPhase(Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.Pump">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.PumpFailed(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.PumpBase.PumpFinished">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Pumps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.Init(Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the pump has not been initialized with a phase.
            </exception>
        </member>
        <member name="F:Akka.Streams.Implementation.Pumps.CompletedPhase">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the action of the completed phase tried to execute.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.InitialPhase(Akka.Streams.Implementation.IPump,System.Int32,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="waitForUpstream">TBD</param>
            <param name="andThen">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="waitForUpstream"/> is less than one.
            </exception>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the initial state is not <see cref="F:Akka.Streams.Implementation.NotInitialized.Instance"/>.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.WaitForUpstream(Akka.Streams.Implementation.IPump,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="waitForUpstream">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="waitForUpstream"/> is less than one.
            </exception>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.GotUpstreamSubscription(Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.NextPhase(Akka.Streams.Implementation.IPump,Akka.Streams.Implementation.TransferPhase)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="phase">TBD</param>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.IsPumpFinished(Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Pumps.Pump(Akka.Streams.Implementation.IPump)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
        </member>
        <member name="T:Akka.Streams.Implementation.Unfold`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElement">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.Unfold`2.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Unfold`2.UnfoldFunc">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Unfold`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Unfold`2.#ctor(`0,System.Func{`0,Akka.Util.Option{System.ValueTuple{`0,`1}}})">
            <summary>
            TBD
            </summary>
            <param name="state">TBD</param>
            <param name="unfoldFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.Unfold`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Unfold`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.UnfoldAsync`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElement">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldAsync`2.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldAsync`2.UnfoldFunc">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldAsync`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldAsync`2.#ctor(`0,System.Func{`0,System.Threading.Tasks.Task{Akka.Util.Option{System.ValueTuple{`0,`1}}}})">
            <summary>
            TBD
            </summary>
            <param name="state">TBD</param>
            <param name="unfoldFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldAsync`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldAsync`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Implementation.UnfoldInfinite`2">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TElement">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldInfinite`2.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldInfinite`2.UnfoldFunc">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.UnfoldInfinite`2.Out">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldInfinite`2.#ctor(`0,System.Func{`0,System.ValueTuple{`0,`1}})">
            <summary>
            TBD
            </summary>
            <param name="state">TBD</param>
            <param name="unfoldFunc">TBD</param>
        </member>
        <member name="P:Akka.Streams.Implementation.UnfoldInfinite`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.UnfoldInfinite`2.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IUntypedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.IUntypedPublisher.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="T:Akka.Streams.UntypedPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.FromTyped(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.FromTyped``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="publisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.ToTyped(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="untypedPublisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedPublisher.ToTyped``1(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="untypedPublisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.UntypedPublisherImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.UntypedPublisherImpl`1.#ctor(Reactive.Streams.IPublisher{`0})">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedPublisherImpl`1.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedPublisherImpl`1.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedPublisherImpl`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IUntypedSubscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.IUntypedSubscriber.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.IUntypedSubscriber.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.IUntypedSubscriber.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.IUntypedSubscriber.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.UntypedSubscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.FromTyped(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.FromTyped``1(Reactive.Streams.ISubscriber{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="subscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.ToTyped(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="untypedSubscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriber.ToTyped``1(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="untypedSubscriber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.UntypedSubscriberImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.#ctor(Reactive.Streams.ISubscriber{`0})">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <summary>
            TBD
            </summary>
            <param name="subscription">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.OnNext(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.OnError(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.OnComplete">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedSubscriberImpl`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IUntypedVirtualPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.IUntypedVirtualPublisher.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.IUntypedVirtualPublisher.RegisterPublisher(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="T:Akka.Streams.UntypedVirtualPublisher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.RegisterPublisher(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.FromTyped(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.FromTyped``1(Akka.Streams.Implementation.VirtualPublisher{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="publisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.ToTyped(Akka.Streams.IUntypedVirtualPublisher)">
            <summary>
            TBD
            </summary>
            <param name="untypedPublisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisher.ToTyped``1(Akka.Streams.IUntypedVirtualPublisher)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="untypedPublisher">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.UntypedVirtualPublisherImpl`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisherImpl`1.#ctor(Akka.Streams.Implementation.VirtualPublisher{`0})">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisherImpl`1.Subscribe(Akka.Streams.IUntypedSubscriber)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisherImpl`1.RegisterPublisher(Akka.Streams.IUntypedPublisher)">
            <summary>
            TBD
            </summary>
            <param name="publisher">TBD</param>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisherImpl`1.Unwrap">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.UntypedVirtualPublisherImpl`1.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IO.IOResult">
            <summary>
            Holds a result of an IO operation.
            </summary>
        </member>
        <member name="M:Akka.Streams.IO.IOResult.#ctor(System.Int64,Akka.Util.Result{Akka.NotUsed})">
            <summary>
            Creates a new IOResult.
            </summary>
            <param name="count">Numeric value depending on context, for example IO operations performed or bytes processed.</param>
            <param name="status">Status of the result. Can be either <see cref="T:Akka.NotUsed"/> or an exception.</param>
        </member>
        <member name="F:Akka.Streams.IO.IOResult.Count">
            <summary>
            Numeric value depending on context, for example IO operations performed or bytes processed.
            </summary>
        </member>
        <member name="P:Akka.Streams.IO.IOResult.WasSuccessful">
            <summary>
            Indicates whether IO operation completed successfully or not.
            </summary>
        </member>
        <member name="P:Akka.Streams.IO.IOResult.Error">
            <summary>
            If the IO operation resulted in an error, returns the corresponding <see cref="T:System.Exception"/>
            or throws <see cref="T:System.NotSupportedException"/> otherwise.
            </summary>
            <exception cref="T:System.NotSupportedException">Is thrown if the property is accessed for a successful <see cref="T:Akka.Streams.IO.IOResult"/></exception>
        </member>
        <member name="M:Akka.Streams.IO.IOResult.Success(System.Int64)">
            <summary>
            Creates successful IOResult
            </summary>
            <param name="count">Numeric value depending on context, for example IO operations performed or bytes processed.</param>
            <returns>Successful IOResult</returns>
        </member>
        <member name="M:Akka.Streams.IO.IOResult.Failed(System.Int64,System.Exception)">
            <summary>
            Creates failed IOResult, <paramref name="count"/> should be the number of bytes (or other unit, please document in your APIs) processed before failing
            </summary>
            <param name="count">Numeric value depending on context, for example IO operations performed or bytes processed.</param>
            <param name="reason">The corresponding <see cref="T:System.Exception"/></param>
            <returns>Failed IOResult</returns>
        </member>
        <member name="T:Akka.Streams.KillSwitches">
            <summary>
            Creates shared or single kill switches which can be used to control completion of graphs from the outside.
             - The factory <see cref="M:Akka.Streams.KillSwitches.Shared(System.String)"/> returns a <see cref="T:Akka.Streams.SharedKillSwitch"/> which provides a 
               <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that can be
               used in arbitrary number of graphs and materializations. The switch simultaneously
               controls completion in all of those graphs.
             - The factory <see cref="M:Akka.Streams.KillSwitches.Single``1"/> returns a <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> 
               that materializes to a <see cref="T:Akka.Streams.UniqueKillSwitch"/> which is always unique to that materialized Flow itself.
            </summary>
        </member>
        <member name="M:Akka.Streams.KillSwitches.Shared(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Streams.SharedKillSwitch"/> with the given name that can be used to control the completion of multiple
            streams from the outside simultaneously.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.KillSwitches.Single``1">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that materializes to an external switch that allows external completion
            of that unique materialization. Different materializations result in different, independent switches.
            
            For a Bidi version see <see cref="M:Akka.Streams.KillSwitches.SingleBidi``2"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.KillSwitches.SingleBidi``2">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.BidiShape`4"/> that materializes to an external switch that allows external completion
            of that unique materialization. Different materializations result in different, independent switches.
            
            For a Flow version see <see cref="M:Akka.Streams.KillSwitches.Single``1"/>
            </summary>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.KillSwitches.AsFlow``1(System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns a flow, which works like a kill switch stage based on a provided <paramref name="cancellationToken"/>.
            Since unlike cancellation tokens, kill switches expose ability to finish a stream either gracefully via
            <see cref="M:Akka.Streams.IKillSwitch.Shutdown"/> or abruptly via <see cref="M:Akka.Streams.IKillSwitch.Abort(System.Exception)"/>, this distinction is
            handled by specifying <paramref name="cancelGracefully"/> parameter.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cancellationToken">Cancellation token used to create a cancellation flow.</param>
            <param name="cancelGracefully">
            When set to true, will close stream gracefully via completting the stage.
            When set to false, will close stream by failing the stage with <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns></returns>
        </member>
        <member name="T:Akka.Streams.KillSwitches.KillableGraphStageLogic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.KillSwitches.KillableGraphStageLogic.#ctor(System.Threading.Tasks.Task,Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="terminationSignal">TBD</param>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.KillSwitches.KillableGraphStageLogic.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.IKillSwitch">
            <summary>
            A <see cref="T:Akka.Streams.IKillSwitch"/> allows completion of <see cref="T:Akka.Streams.IGraph`1"/>s from the outside by completing 
            <see cref="T:Akka.Streams.IGraph`1"/>s of <see cref="T:Akka.Streams.FlowShape`2"/> linked to the switch. 
            Depending on whether the <see cref="T:Akka.Streams.IKillSwitch"/> is a <see cref="T:Akka.Streams.UniqueKillSwitch"/> or a <see cref="T:Akka.Streams.SharedKillSwitch"/> one or
            multiple streams might be linked with the switch. For details see the documentation of the concrete subclasses of
            this interface.
            </summary>
        </member>
        <member name="M:Akka.Streams.IKillSwitch.Shutdown">
            <summary>
            After calling <see cref="M:Akka.Streams.IKillSwitch.Shutdown"/> the linked <see cref="T:Akka.Streams.IGraph`1"/>s of <see cref="T:Akka.Streams.FlowShape`2"/> are completed normally.
            </summary>
        </member>
        <member name="M:Akka.Streams.IKillSwitch.Abort(System.Exception)">
            <summary>
            After calling <see cref="M:Akka.Streams.IKillSwitch.Abort(System.Exception)"/> the linked <see cref="T:Akka.Streams.IGraph`1"/>s of <see cref="T:Akka.Streams.FlowShape`2"/> are failed.
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Streams.UniqueKillSwitch">
            <summary>
            A <see cref="T:Akka.Streams.UniqueKillSwitch"/> is always a result of a materialization (unlike <see cref="T:Akka.Streams.SharedKillSwitch"/> which is constructed
            before any materialization) and it always controls that graph and stage which yielded the materialized value.
            
            After calling <see cref="M:Akka.Streams.UniqueKillSwitch.Shutdown"/> the running instance of the <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that materialized to the
            <see cref="T:Akka.Streams.UniqueKillSwitch"/> will complete its downstream and cancel its upstream (unless if finished or failed already in which
            case the command is ignored). Subsequent invocations of completion commands will be ignored.
            
            After calling <see cref="M:Akka.Streams.UniqueKillSwitch.Abort(System.Exception)"/> the running instance of the <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that materialized to the
            <see cref="T:Akka.Streams.UniqueKillSwitch"/> will fail its downstream with the provided exception and cancel its upstream
            (unless if finished or failed already in which case the command is ignored). Subsequent invocations of completion commands will be ignored.
            
            It is also possible to individually cancel, complete or fail upstream and downstream parts by calling the corresponding methods.
            </summary>
        </member>
        <member name="M:Akka.Streams.UniqueKillSwitch.#ctor(System.Threading.Tasks.TaskCompletionSource{Akka.NotUsed})">
            <summary>
            TBD
            </summary>
            <param name="promise">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniqueKillSwitch.Shutdown">
            <summary>
            After calling <see cref="M:Akka.Streams.UniqueKillSwitch.Shutdown"/> the running instance of the <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that materialized to the
            <see cref="T:Akka.Streams.UniqueKillSwitch"/> will complete its downstream and cancel its upstream (unless if finished or failed already in which
            case the command is ignored). Subsequent invocations of completion commands will be ignored.
            </summary>
        </member>
        <member name="M:Akka.Streams.UniqueKillSwitch.Abort(System.Exception)">
            <summary>
            After calling <see cref="M:Akka.Streams.UniqueKillSwitch.Abort(System.Exception)"/> the running instance of the <see cref="T:Akka.Streams.IGraph`1"/> of <see cref="T:Akka.Streams.FlowShape`2"/> that materialized to the
            <see cref="T:Akka.Streams.UniqueKillSwitch"/> will fail its downstream with the provided exception and cancel its upstream
            (unless if finished or failed already in which case the command is ignored). Subsequent invocations of
            completion commands will be ignored.
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.UniqueKillSwitch.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.SharedKillSwitch">
             <summary>
             A <see cref="T:Akka.Streams.SharedKillSwitch"/> is a provider for <see cref="T:Akka.Streams.IGraph`1"/>s of <see cref="T:Akka.Streams.FlowShape`2"/> that can be completed or failed from the outside.
            
             A <see cref="T:Akka.Streams.IGraph`1"/> returned by the switch can be materialized arbitrary amount of times: every newly materialized<see cref="T:Akka.Streams.IGraph`1"/>
             belongs to the switch from which it was acquired. Multiple <see cref="T:Akka.Streams.SharedKillSwitch"/> instances are isolated from each other,
             shutting down or aborting on instance does not affect the <see cref="T:Akka.Streams.IGraph`1"/>s provided by another instance.
            
            
             After calling <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> all materialized, running instances of all <see cref="T:Akka.Streams.IGraph`1"/>s provided by the
             <see cref="T:Akka.Streams.SharedKillSwitch"/> will complete their downstreams and cancel their upstreams(unless if finished or failed already in which
             case the command is ignored). Subsequent invocations of <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> and <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> will be
             ignored.
            
             After calling <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> all materialized, running instances of all <see cref="T:Akka.Streams.IGraph`1"/>s provided by the
             <see cref="T:Akka.Streams.SharedKillSwitch"/> will fail their downstreams with the provided exception and cancel their upstreams
             (unless it finished or failed already in which case the command is ignored). Subsequent invocations of
             <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> and <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> will be ignored.
            
             The <see cref="T:Akka.Streams.IGraph`1"/>s provided by the <see cref="T:Akka.Streams.SharedKillSwitch"/> do not modify the passed through elements in any way or affect
             backpressure in the stream. All provided <see cref="T:Akka.Streams.IGraph`1"/>s provide the parent <see cref="T:Akka.Streams.SharedKillSwitch"/> as materialized value.
            
             This class is thread-safe, the instance can be passed safely among threads and its methods may be invoked concurrently.
             </summary>
        </member>
        <member name="M:Akka.Streams.SharedKillSwitch.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.SharedKillSwitch.Shutdown">
            <summary>
            After calling <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> all materialized, running instances of all <see cref="T:Akka.Streams.IGraph`1"/>s provided by the
            <see cref="T:Akka.Streams.SharedKillSwitch"/> will complete their downstreams and cancel their upstreams (unless if finished or failed already in which
            case the command is ignored). Subsequent invocations of <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> and <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> will be
            ignored.
            </summary>
        </member>
        <member name="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)">
             <summary>
             After calling <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> all materialized, running instances of all <see cref="T:Akka.Streams.IGraph`1"/>s provided by the
             <see cref="T:Akka.Streams.SharedKillSwitch"/> will fail their downstreams with the provided exception and cancel their upstreams
             (unless it finished or failed already in which case the command is ignored). Subsequent invocations of
             <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> and <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> will be ignored.
            
             These provided <see cref="T:Akka.Streams.IGraph`1"/>s materialize to their owning switch. This might make certain integrations simpler than
             passing around the switch instance itself.
             </summary>
             <param name="cause">The exception to be used for failing the linked <see cref="T:Akka.Streams.IGraph`1"/>s</param>
        </member>
        <member name="M:Akka.Streams.SharedKillSwitch.Flow``1">
            <summary>
            Returns a typed Flow of a requested type that will be linked to this <see cref="T:Akka.Streams.SharedKillSwitch"/> instance. By invoking
            <see cref="M:Akka.Streams.SharedKillSwitch.Shutdown"/> or <see cref="M:Akka.Streams.SharedKillSwitch.Abort(System.Exception)"/> all running instances of all provided <see cref="T:Akka.Streams.IGraph`1"/>s by this
            switch will be stopped normally or failed.
            </summary>
            <returns>A reusable <see cref="T:Akka.Streams.IGraph`1"/> that is linked with the switch. The materialized value provided is this switch itself.</returns> 
            <typeparam name="T">Type of the elements the Flow will forward</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.SharedKillSwitch.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.OverflowStrategy">
            <summary>
            Represents a strategy that decides how to deal with a buffer that is full but is about to receive a new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropHead">
            <summary>
            If the buffer is full when a new element arrives, drops the oldest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropTail">
            <summary>
            If the buffer is full when a new element arrives, drops the youngest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropBuffer">
            <summary>
            If the buffer is full when a new element arrives, drops all the buffered elements to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropNew">
            <summary>
            If the buffer is full when a new element arrives, drops the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.Backpressure">
            <summary>
            If the buffer is full when a new element is available this strategy backpressures the upstream publisher until space becomes available in the buffer.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.Fail">
            <summary>
            If the buffer is full when a new element is available this strategy completes the stream with failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.DelayOverflowStrategy">
            <summary>
            Represents a strategy that decides how to deal with a buffer of time based stage that is full but is about to receive a new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.EmitEarly">
            <summary>
            If the buffer is full when a new element is available this strategy send next element downstream without waiting
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropHead">
            <summary>
            If the buffer is full when a new element arrives, drops the oldest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropTail">
            <summary>
            If the buffer is full when a new element arrives, drops the youngest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropBuffer">
            <summary>
            If the buffer is full when a new element arrives, drops all the buffered elements to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropNew">
            <summary>
            If the buffer is full when a new element arrives, drops the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.Backpressure">
            <summary>
            If the buffer is full when a new element is available this strategy backpressures the upstream publisher until space becomes available in the buffer.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.Fail">
            <summary>
            If the buffer is full when a new element is available this strategy completes the stream with failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.BufferOverflowException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.BufferOverflowException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.BufferOverflowException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Streams.BufferOverflowException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.BufferOverflowException"/> class.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.ISourceQueue`1">
            <summary>
            This interface allows to have the queue as a data source for some stream.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.ISourceQueue`1.OfferAsync(`0)">
            <summary>
            Method offers next element to a stream and returns task that:
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Enqueued"/> if element
            is consumed by a stream</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Dropped"/> when stream
            dropped offered element</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.QueueClosed"/> when
            stream is completed while task is active</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Failure"/> when failure
            to enqueue element from upstream</para>
            <para>- fails if stream is completed or you cannot call offer in this moment
            because of implementation rules (like for backpressure mode and full buffer
            you need to wait for last offer call task completion.</para>
            </summary>
            <param name="element">element to send to a stream</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ISourceQueue`1.WatchCompletionAsync">
            <summary>
            Method returns <see cref="T:System.Threading.Tasks.Task"/> that will be completed if the stream completes,
            or will be failed when the stage faces an internal failure.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.ISourceQueueWithComplete`1">
            <summary>
            This interface adds completion support to <see cref="T:Akka.Streams.ISourceQueue`1"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.ISourceQueueWithComplete`1.Complete">
            <summary>
            Complete the stream normally. Use <see cref="M:Akka.Streams.ISourceQueue`1.WatchCompletionAsync"/> to be notified of this operation’s success.
            </summary>
        </member>
        <member name="M:Akka.Streams.ISourceQueueWithComplete`1.Fail(System.Exception)">
            <summary>
            Complete the stream with a failure. Use <see cref="M:Akka.Streams.ISourceQueue`1.WatchCompletionAsync"/> to be notified of this operation’s success.
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.ISourceQueueWithComplete`1.WatchCompletionAsync">
            <summary>
            Method returns <see cref="T:System.Threading.Tasks.Task"/> that will be completed if the stream completes,
            or will be failed when the stage faces an internal failure or the the <see cref="M:Akka.Streams.ISourceQueueWithComplete`1.Fail(System.Exception)"/> method is invoked.
            </summary>
            <returns>Task</returns>
        </member>
        <member name="T:Akka.Streams.ISinkQueue`1">
            <summary>
            Trait allows to have the queue as a sink for some stream.
            "SinkQueue" pulls data from stream with backpressure mechanism.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.ISinkQueue`1.PullAsync">
            <summary>
            Method pulls elements from stream and returns task that:
            <para>- fails if stream is finished</para>
            <para>- completes with None in case if stream is completed after we got task</para>
            <para>- completes with `Some(element)` in case next element is available from stream.</para>
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.IQueueOfferResult">
            <summary>
            Used as return type for async callbacks to streams
            </summary>
        </member>
        <member name="T:Akka.Streams.QueueOfferResult">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.QueueOfferResult.Enqueued">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.QueueOfferResult.Enqueued.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.QueueOfferResult.Dropped">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.QueueOfferResult.Dropped.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.QueueOfferResult.Failure">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.QueueOfferResult.Failure.Cause">
            <summary>
            The cause of the failure
            </summary>
        </member>
        <member name="M:Akka.Streams.QueueOfferResult.Failure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.QueueOfferResult.Failure"/> class.
            </summary>
            <param name="cause">The cause of the failure</param>
        </member>
        <member name="T:Akka.Streams.QueueOfferResult.QueueClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.QueueOfferResult.QueueClosed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Serialization.Proto.Msg.StreamRefMessagesReflection">
            <summary>Holder for reflection information generated from StreamRefMessages.proto</summary>
        </member>
        <member name="P:Akka.Streams.Serialization.Proto.Msg.StreamRefMessagesReflection.Descriptor">
            <summary>File descriptor for StreamRefMessages.proto</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.EventType.TypeNameFieldNumber">
            <summary>Field number for the "typeName" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SinkRef.TargetRefFieldNumber">
            <summary>Field number for the "targetRef" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SinkRef.EventTypeFieldNumber">
            <summary>Field number for the "eventType" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SourceRef.OriginRefFieldNumber">
            <summary>Field number for the "originRef" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SourceRef.EventTypeFieldNumber">
            <summary>Field number for the "eventType" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.ActorRef.PathFieldNumber">
            <summary>Field number for the "path" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.Payload.EnclosedMessageFieldNumber">
            <summary>Field number for the "enclosedMessage" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.Payload.SerializerIdFieldNumber">
            <summary>Field number for the "serializerId" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.Payload.MessageManifestFieldNumber">
            <summary>Field number for the "messageManifest" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.OnSubscribeHandshake.TargetRefFieldNumber">
            <summary>Field number for the "targetRef" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.CumulativeDemand.SeqNrFieldNumber">
            <summary>Field number for the "seqNr" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SequencedOnNext.SeqNrFieldNumber">
            <summary>Field number for the "seqNr" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.SequencedOnNext.PayloadFieldNumber">
            <summary>Field number for the "payload" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.RemoteStreamFailure.CauseFieldNumber">
            <summary>Field number for the "cause" field.</summary>
        </member>
        <member name="F:Akka.Streams.Serialization.Proto.Msg.RemoteStreamCompleted.SeqNrFieldNumber">
            <summary>Field number for the "seqNr" field.</summary>
        </member>
        <member name="T:Akka.Streams.InPort">
            <summary>
            An input port of a <see cref="T:Akka.Streams.Implementation.IModule"/>. This type logically belongs
            into the impl package but must live here due to how sealed works.
            It is also used in the Java DSL for "untyped Inlets" as a work-around
            for otherwise unreasonable existential types.
            </summary>
        </member>
        <member name="F:Akka.Streams.InPort.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.OutPort">
            <summary>
            An output port of a StreamLayout.Module. This type logically belongs
            into the impl package but must live here due to how sealed works.
            It is also used in the Java DSL for "untyped Outlets" as a work-around
            for otherwise unreasonable existential types.
            </summary>
        </member>
        <member name="F:Akka.Streams.OutPort.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Inlet">
            <summary>
            An Inlet is a typed input to a Shape. Its partner in the Module view 
            is the InPort(which does not bear an element type because Modules only 
            express the internal structural hierarchy of stream topologies).
            </summary>
        </member>
        <member name="M:Akka.Streams.Inlet.Create``1(Akka.Streams.Inlet)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Inlet.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="name"/> is undefined.
            </exception>
        </member>
        <member name="F:Akka.Streams.Inlet.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Inlet.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Inlet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Inlet`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Inlet`1.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.Inlet`1.As``1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOther">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Inlet`1.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Outlet">
            <summary>
            An Outlet is a typed output to a Shape. Its partner in the Module view
            is the OutPort(which does not bear an element type because Modules only
            express the internal structural hierarchy of stream topologies).
            </summary>
        </member>
        <member name="M:Akka.Streams.Outlet.Create``1(Akka.Streams.Outlet)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Outlet.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="F:Akka.Streams.Outlet.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Outlet.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Outlet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Outlet`1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Outlet`1.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Streams.Outlet`1.As``1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOther">TBD</typeparam>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Outlet`1.CarbonCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Shape">
            <summary>
            A Shape describes the inlets and outlets of a <see cref="T:Akka.Streams.IGraph`1"/>. In keeping with the
            philosophy that a Graph is a freely reusable blueprint, everything that
            matters from the outside are the connections that can be made with it,
            otherwise it is just a black box.
            </summary>
        </member>
        <member name="P:Akka.Streams.Shape.Inlets">
            <summary>
            Gets list of all input ports.
            </summary>
        </member>
        <member name="P:Akka.Streams.Shape.Outlets">
            <summary>
            Gets list of all output ports.
            </summary>
        </member>
        <member name="M:Akka.Streams.Shape.DeepCopy">
            <summary>
            Create a copy of this Shape object, returning the same type as the
            original; this constraint can unfortunately not be expressed in the
            type system.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Shape.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            Create a copy of this Shape object, returning the same type as the
            original but containing the ports given within the passed-in Shape.
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Shape.HasSamePortsAs(Akka.Streams.Shape)">
            <summary>
            Compare this to another shape and determine whether the set of ports is the same (ignoring their ordering).
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Shape.HasSamePortsAndShapeAs(Akka.Streams.Shape)">
            <summary>
            Compare this to another shape and determine whether the arrangement of ports is the same (including their ordering).
            </summary>
            <param name="shape">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Shape.Clone">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Shape.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.ClosedShape">
            <summary>
            This <see cref="T:Akka.Streams.Shape"/> is used for graphs that have neither open inputs nor open
            outputs. Only such a <see cref="T:Akka.Streams.IGraph`2"/> can be materialized by a <see cref="T:Akka.Streams.IMaterializer"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.ClosedShape.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ClosedShape.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.ClosedShape.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ClosedShape.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.ClosedShape.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the size of the specified <paramref name="inlets"/> array is zero
            or the size of the specified <paramref name="outlets"/> array is zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.AmorphousShape">
            <summary>
            This type of <see cref="T:Akka.Streams.Shape"/> can express any number of inputs and outputs at the
            expense of forgetting about their specific types. It is used mainly in the
            implementation of the <see cref="T:Akka.Streams.IGraph`2"/> builders and typically replaced by a more
            meaningful type of Shape when the building is finished.
            </summary>
        </member>
        <member name="M:Akka.Streams.AmorphousShape.#ctor(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
        </member>
        <member name="P:Akka.Streams.AmorphousShape.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.AmorphousShape.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.AmorphousShape.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.AmorphousShape.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.SourceShape`1">
            <summary>
            A Source <see cref="T:Akka.Streams.Shape"/> has exactly one output and no inputs, it models a source of data.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.#ctor(Akka.Streams.Outlet{`0})">
            <summary>
            TBD
            </summary>
            <param name="outlet">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="F:Akka.Streams.SourceShape`1.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.SourceShape`1.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.SourceShape`1.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the size of the specified <paramref name="inlets"/> array is zero
            or the size of the specified <paramref name="outlets"/> array is one.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.Equals(Akka.Streams.SourceShape{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.SourceShape`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.IFlowShape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.IFlowShape.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.IFlowShape.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowShape`2">
            <summary>
            A Flow <see cref="T:Akka.Streams.Shape"/> has exactly one input and one output, it looks from the
            outside like a pipe (but it can be a complex topology of streams within of course).
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.FlowShape`2.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <param name="outlet">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when either the specified <paramref name="inlet"/> or <paramref name="outlet"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Streams.FlowShape`2.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FlowShape`2.Outlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FlowShape`2.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.FlowShape`2.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.FlowShape`2.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.FlowShape`2.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the size of the specified <paramref name="inlets"/> array is one
            or the size of the specified <paramref name="outlets"/> array is one.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.SinkShape`1">
            <summary>
            A Sink <see cref="T:Akka.Streams.Shape"/> has exactly one input and no outputs, it models a data sink.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.SinkShape`1.Inlet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.SinkShape`1.#ctor(Akka.Streams.Inlet{`0})">
            <summary>
            TBD
            </summary>
            <param name="inlet">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="inlet"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Streams.SinkShape`1.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.SinkShape`1.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.SinkShape`1.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.SinkShape`1.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the size of the specified <paramref name="inlets"/> array is zero
            or the size of the specified <paramref name="outlets"/> array is one.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.SinkShape`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.SinkShape`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.BidiShape`4">
            <summary>
            A bidirectional flow of elements that consequently has two inputs and two outputs.
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.BidiShape`4.Inlet1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.BidiShape`4.Inlet2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.BidiShape`4.Outlet1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.BidiShape`4.Outlet2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.BidiShape`4.#ctor(Akka.Streams.Inlet{`0},Akka.Streams.Outlet{`1},Akka.Streams.Inlet{`2},Akka.Streams.Outlet{`3})">
            <summary>
            TBD
            </summary>
            <param name="in1">TBD</param>
            <param name="out1">TBD</param>
            <param name="in2">TBD</param>
            <param name="out2">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when either the specified <paramref name="in1"/>, <paramref name="out1"/>,
            <paramref name="in2"/>, or <paramref name="out2"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.BidiShape`4.#ctor(Akka.Streams.FlowShape{`0,`1},Akka.Streams.FlowShape{`2,`3})">
            <summary>
            TBD
            </summary>
            <param name="top">TBD</param>
            <param name="bottom">TBD</param>
        </member>
        <member name="P:Akka.Streams.BidiShape`4.Inlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.BidiShape`4.Outlets">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.BidiShape`4.DeepCopy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.BidiShape`4.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            TBD
            </summary>
            <param name="inlets">TBD</param>
            <param name="outlets">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the size of the specified <paramref name="inlets"/> array is two
            or the size of the specified <paramref name="outlets"/> array is two.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.BidiShape`4.Reversed">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.BidiShape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.BidiShape.FromFlows``4(Akka.Streams.FlowShape{``0,``1},Akka.Streams.FlowShape{``2,``3})">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn1">TBD</typeparam>
            <typeparam name="TOut1">TBD</typeparam>
            <typeparam name="TIn2">TBD</typeparam>
            <typeparam name="TOut2">TBD</typeparam>
            <param name="top">TBD</param>
            <param name="bottom">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.NoSuchElementException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.NoSuchElementException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.NoSuchElementException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Akka.Streams.Stage.PushPullGraphLogic`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.#ctor(Akka.Streams.FlowShape{`0,`1},Akka.Streams.Attributes,Akka.Streams.Stage.AbstractStage{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
            <param name="attributes">TBD</param>
            <param name="stage">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.Stage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.Attributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.Context">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.BeforePreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.Push(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.Push(`1)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.Pull">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.Finish">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PushAndFinish(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PushAndFinish(`1)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.Fail(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.IsFinishing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.AbsorbTermination">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown when the <see cref="P:Akka.Streams.FlowShape`2.Outlet"/> is closed.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PushAndPull(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PushAndPull(`1)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.HoldUpstreamAndPush(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.HoldUpstreamAndPush(`1)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.HoldDownstreamAndPull">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.IsHoldingBoth">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.IsHoldingDownstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphLogic`2.IsHoldingUpstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.HoldDownstream">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.HoldUpstream">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphLogic`2.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TMat">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.Factory">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.#ctor(System.Func{Akka.Streams.Attributes,System.ValueTuple{Akka.Streams.Stage.IStage{`0,`1},`2}},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="factory">TBD</param>
            <param name="stageAttributes">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue`3.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.PushPullGraphStage`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.PushPullGraphStage`2.#ctor(System.Func{Akka.Streams.Attributes,Akka.Streams.Stage.IStage{`0,`1}},Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="factory">TBD</param>
            <param name="stageAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.AbstractStage`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Stage.AbstractStage`2.IsDetached">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.PreStart(Akka.Streams.Stage.ILifecycleContext)">
            <summary>
            User overridable callback.
            <para>
            It is called before any other method defined on the <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            Empty default implementation.
            </para>
            </summary>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a "push".
            </para>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnDownstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
            <param name="cause">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.PostStop">
            <summary>
            User overridable callback.
            Is called after the Stages final action is performed.  
            Empty default implementation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.Decide(System.Exception)">
            <summary>
            If an exception is thrown from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> this method is invoked to decide how
            to handle the exception. By default this method returns <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>.
            <para>
            If an exception is thrown from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> the stream will always be completed with
            failure, because it is not always possible to recover from that state.
            In concrete stages it is of course possible to use ordinary try-catch-recover inside
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> when it is know how to recover from such exceptions.
            </para>
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.Restart">
            <summary>
            Used to create a fresh instance of the stage after an error resulting in a <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            directive. By default it will return the same instance untouched, so you must override it
            if there are any state that should be cleared before restarting, e.g. by returning a new instance.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.AbstractStage`5">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TPushDirective">TBD</typeparam>
            <typeparam name="TPullDirective">TBD</typeparam>
            <typeparam name="TContext">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Stage.AbstractStage`5.Context">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnPull(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a "push".
            </para>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFinish(`4)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a "push".
            </para>
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnDownstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnDownstreamFinish(`4)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
            <param name="cause">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,`4)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPush(`0,`4)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`5.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
            <param name="cause">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IAsyncDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ISyncDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IUpstreamDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IDownstreamDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ITerminationDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.FreeDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ILifecycleContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.ILifecycleContext.Materializer">
            <summary>
            Returns the Materializer that was used to materialize this Stage/>.
            It can be used to materialize sub-flows.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.ILifecycleContext.Attributes">
            <summary>
            Returns operation attributes associated with the this Stage
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IContext">
            <summary>
            Passed to the callback methods of <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> and <see cref="T:Akka.Streams.Stage.StatefulStage`2"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.IContext.IsFinishing">
            <summary>
            This returns true after <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> has been used.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)">
            <summary>
            Push one element to downstream immediately followed by
            cancel of upstreams and complete of downstreams.
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Push(System.Object)">
            <summary>
            Push one element to downstreams.
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Pull">
            <summary>
            Request for more elements from upstreams.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Finish">
            <summary>
            Cancel upstreams and complete downstreams successfully.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Fail(System.Exception)">
            <summary>
            Cancel upstreams and complete downstreams with failure.
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext.AbsorbTermination">
            <summary>
            Puts the stage in a finishing state so that
            final elements can be pushed from onPull.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IContext`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.IContext`1.PushAndFinish(`0)">
            <summary>
            Push one element to downstream immediately followed by
            cancel of upstreams and complete of downstreams.
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IContext`1.Push(`0)">
            <summary>
            Push one element to downstreams.
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IDetachedContext">
            <summary>
            Passed to the callback methods of <see cref="T:Akka.Streams.Stage.DetachedStage`2"/>.
            
            <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldDownstream"/> and <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldUpstream"/> stops execution and at the same time putting the stage in a holding state.
            If the stage is in a holding state it contains one absorbed signal, therefore in
            this state the only possible command to call is <see cref="M:Akka.Streams.Stage.IDetachedContext.PushAndPull(System.Object)"/> which results in two
            events making the balance right again: 1 hold + 1 external event = 2 external event
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.IDetachedContext.IsHoldingBoth">
            <summary>
            This returns true when <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldDownstream"/> and <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldUpstream"/> has been used
            and it is reset to false after <see cref="M:Akka.Streams.Stage.IDetachedContext.PushAndPull(System.Object)"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.IDetachedContext.IsHoldingUpstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.IDetachedContext.IsHoldingDownstream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext.PushAndPull(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext.HoldUpstream">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext.HoldUpstreamAndPush(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext.HoldDownstream">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext.HoldDownstreamAndPull">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IDetachedContext`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext`1.PushAndPull(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IDetachedContext`1.HoldUpstreamAndPush(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.AsyncCallback">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.AsyncCallback`1">
            <summary>
            An asynchronous callback holder that is attached to an <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/>.
            
            Invoking <see cref="!:Invoke"/> will eventually lead to <see cref="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OnAsyncInput"/>
            being called.
            
            Dispatch an asynchronous notification. This method is thread-safe and
            may be invoked from external execution contexts.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="element">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.IAsyncContext">
            <summary>
            This kind of context is available to <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/>. It implements the same
            interface as for <see cref="T:Akka.Streams.Stage.IDetachedContext"/> with the addition of being able to obtain
            <see cref="T:Akka.Streams.Stage.AsyncCallback"/> objects that allow the registration of asynchronous notifications.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext.GetAsyncCallback">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/> with an asynchronous notification. After the
            notification has been invoked, eventually <see cref="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OnAsyncInput"/>
            will be called with the given data item.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/>.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext.Ignore">
            <summary>
            In response to an asynchronous notification an <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/> may choose
            to neither push nor pull nor terminate, which is represented as this directive.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IAsyncContext`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TExt">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext`2.GetAsyncCallback">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/> with an asynchronous notification. After the
            notification has been invoked, eventually <see cref="F:Akka.Streams.Implementation.Fusing.GraphInterpreter.OnAsyncInput"/>
            will be called with the given data item.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.IAsyncContext`2"/>.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.IBoundaryContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IBoundaryContext.Exit">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.ILogicAndMaterializedValue`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TMaterialized">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Stage.ILogicAndMaterializedValue`1.Logic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.ILogicAndMaterializedValue`1.MaterializedValue">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.LogicAndMaterializedValue`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TMaterialized">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.LogicAndMaterializedValue`1.#ctor(Akka.Streams.Stage.GraphStageLogic,`0)">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="materializedValue">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.LogicAndMaterializedValue`1.Logic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.LogicAndMaterializedValue`1.MaterializedValue">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IGraphStageWithMaterializedValue`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMaterialized">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.IGraphStageWithMaterializedValue`2.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageWithMaterializedValue`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TShape">TBD</typeparam>
            <typeparam name="TMaterialized">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.InitialAttributes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.Shape">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.Module">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.Named(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageWithMaterializedValue`2.Async">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStage`1">
            <summary>
            A GraphStage represents a reusable graph stream processing stage. A GraphStage consists of a <see cref="T:Akka.Streams.Shape"/> which describes
            its input and output ports and a factory function that creates a <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> which implements the processing
            logic that ties the ports together.
            </summary>
            <typeparam name="TShape">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStage`1.CreateLogicAndMaterializedValue(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStage`1.CreateLogic(Akka.Streams.Attributes)">
            <summary>
            TBD
            </summary>
            <param name="inheritedAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.TimerGraphStageLogic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)">
            <summary>
            Will be called when the scheduled timer is triggered.
            </summary>
            <param name="timerKey">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleRepeatedly(System.Object,System.TimeSpan,System.TimeSpan)">
            <summary>
            Schedule timer to call <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> periodically with the given interval after the specified
            initial delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
            <param name="timerKey">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleRepeatedly(System.Object,System.TimeSpan)">
            <summary>
            Schedule timer to call <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> periodically with the given interval after the specified
            initial delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
            <param name="timerKey">TBD</param>
            <param name="interval">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleOnce(System.Object,System.TimeSpan)">
            <summary>
            Schedule timer to call <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> after given delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
            <param name="timerKey">TBD</param>
            <param name="delay">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.CancelTimer(System.Object)">
            <summary>
            Cancel timer, ensuring that the <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> is not subsequently called.
            </summary>
            <param name="timerKey">key of the timer to cancel</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.IsTimerActive(System.Object)">
            <summary>
            Inquire whether the timer is still active. Returns true unless the
            timer does not exist, has previously been canceled or if it was a
            single-shot timer that was already triggered.
            </summary>
            <param name="timerKey">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.AfterPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.TimerMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.TimerMessages.Scheduled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TimerMessages.Scheduled.TimerKey">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TimerMessages.Scheduled.TimerId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TimerMessages.Scheduled.IsRepeating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerMessages.Scheduled.#ctor(System.Object,System.Int32,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="timerKey">TBD</param>
            <param name="timerId">TBD</param>
            <param name="isRepeating">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="timerKey"/> is undefined.
            </exception>
        </member>
        <member name="T:Akka.Streams.Stage.TimerMessages.Timer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TimerMessages.Timer.Id">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TimerMessages.Timer.Task">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerMessages.Timer.#ctor(System.Int32,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="task">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic">
            <summary>
            Represents the processing logic behind a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>. Roughly speaking, a subclass of <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> is a
            collection of the following parts:
             <para>* A set of <see cref="T:Akka.Streams.Stage.InHandler"/> and <see cref="T:Akka.Streams.Stage.OutHandler"/> instances and their assignments to the <see cref="T:Akka.Streams.Inlet"/>s and <see cref="T:Akka.Streams.Outlet"/>s
               of the enclosing <see cref="T:Akka.Streams.Stage.GraphStage`1"/></para>
             <para>* Possible mutable state, accessible from the <see cref="T:Akka.Streams.Stage.InHandler"/> and <see cref="T:Akka.Streams.Stage.OutHandler"/> callbacks, but not from anywhere
               else (as such access would not be thread-safe)</para>
             <para>* The lifecycle hooks <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/> and <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/></para>
             <para>* Methods for performing stream processing actions, like pulling or pushing elements</para> 
            The stage logic is completed once all its input and output ports have been closed. This can be changed by
            setting <see cref="M:Akka.Streams.Stage.GraphStageLogic.SetKeepGoing(System.Boolean)"/> to true.
            <para />
            The <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/> lifecycle hook on the logic itself is called once all ports are closed. This is the only tear down
            callback that is guaranteed to happen, if the actor system or the materializer is terminated the handlers may never
            see any callbacks to <see cref="M:Akka.Streams.Stage.InHandler.OnUpstreamFailure(System.Exception)"/>, <see cref="M:Akka.Streams.Stage.InHandler.OnUpstreamFinish"/> or <see cref="M:Akka.Streams.Stage.OutHandler.OnDownstreamFinish"/>. 
            Therefore stage resource cleanup should always be done in <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emitting.Dequeue">
            <summary>
            Dequeue this from the head of the queue, meaning that this object will
            not be retained (setHandler will install the followUp). For this reason
            the followUpsTail knowledge needs to be passed on to the next runner.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.LambdaInHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaInHandler.#ctor(System.Action,System.Action,System.Action{System.Exception})">
            <summary>
            TBD
            </summary>
            <param name="onPush">TBD</param>
            <param name="onUpstreamFinish">TBD</param>
            <param name="onUpstreamFailure">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaInHandler.OnPush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaInHandler.OnUpstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaInHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.LambdaOutHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaOutHandler.#ctor(System.Action,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="onPull">TBD</param>
            <param name="onDownstreamFinish">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaOutHandler.OnPull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.LambdaOutHandler.OnDownstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.EagerTerminateInput">
            <summary>
            Input handler that terminates the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.IgnoreTerminateInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion.
            The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ConditionalTerminateInput(System.Func{System.Boolean})">
            <summary>
            Input handler that terminates the state upon receiving completion if the
            given condition holds at that time. The stage fails upon receiving a failure.
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.TotallyIgnorantInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion
            nor failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.EagerTerminateOutput">
            <summary>
            Output handler that terminates the stage upon cancellation.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.IgnoreTerminateOutput">
            <summary>
            Output handler that does not terminate the stage upon cancellation.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.DoNothing">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ConditionalTerminateOutput(System.Func{System.Boolean})">
            <summary>
            Output handler that terminates the state upon receiving completion if the
            given condition holds at that time. The stage fails upon receiving a failure.
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.InCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.OutCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.Handlers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.PortToConn">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.StageId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.Interpreter">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the class is not initialized.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inCount">TBD</param>
            <param name="outCount">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.Materializer">
            <summary>
            The <see cref="T:Akka.Streams.IMaterializer"/> that has set this GraphStage in motion.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubFusingMaterializer">
            <summary>
            An <see cref="T:Akka.Streams.IMaterializer"/> that may run fusable parts of the graphs that it materializes 
            within the same actor as the current GraphStage(if fusing is available). This materializer 
            must not be shared outside of the GraphStage.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.KeepGoingAfterAllPortsClosed">
            <summary>
            If this method returns true when all ports had been closed then the stage is not stopped 
            until <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)"/> are explicitly called
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.StageActor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.LogSource">
            <summary>
            Override to customise reported log source 
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler``1(Akka.Streams.Inlet{``0},Akka.Streams.Stage.IInHandler)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Inlet`1"/>.
            </summary>
            <param name="inlet">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler``1(Akka.Streams.Inlet{``0},System.Action,System.Action,System.Action{System.Exception})">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
            <param name="inlet">TBD</param>
            <param name="onPush">TBD</param>
            <param name="onUpstreamFinish">TBD</param>
            <param name="onUpstreamFailure">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="onPush"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetHandler``1(Akka.Streams.Inlet{``0})">
            <summary>
            Retrieves the current callback for the events on the given <see cref="T:Akka.Streams.Inlet`1"/>
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler(Akka.Streams.Outlet,Akka.Streams.Stage.IOutHandler)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
            <param name="outlet">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler``1(Akka.Streams.Outlet{``0},Akka.Streams.Stage.IOutHandler)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
            <param name="outlet">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler``1(Akka.Streams.Outlet{``0},System.Action,System.Action)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
            <param name="outlet">TBD</param>
            <param name="onPull">TBD</param>
            <param name="onDownstreamFinish">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="onPull"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler``2(Akka.Streams.Inlet{``0},Akka.Streams.Outlet{``1},Akka.Streams.Stage.InAndOutGraphStageLogic)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Inlet`1"/> and <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetHandler(Akka.Streams.Outlet)">
            <summary>
            Retrieves the current callback for the events on the given <see cref="T:Akka.Streams.Outlet`1"/>
            </summary>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetHandler``1(Akka.Streams.Outlet{``0})">
            <summary>
            Retrieves the current callback for the events on the given <see cref="T:Akka.Streams.Outlet`1"/>
            </summary>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Pull(Akka.Streams.Inlet)">
            <summary>
            Requests an element on the given port. Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)"/> can be used
            query whether pull is allowed to be called or not.This method will also fail if the port is already closed.
            </summary>
            <param name="inlet">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="inlet"/> is closed or already pulled.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Pull``1(Akka.Streams.Inlet{``0})">
            <summary>
            Requests an element on the given port. Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)"/> can be used
            query whether pull is allowed to be called or not.This method will also fail if the port is already closed.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.TryPull``1(Akka.Streams.Inlet{``0})">
            <summary>
            Requests an element on the given port unless the port is already closed.
            Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)"/> can be used
            query whether pull is allowed to be called or not.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Cancel``1(Akka.Streams.Inlet{``0})">
            <summary>
            Requests to stop receiving events from a given input port. Cancelling clears any ungrabbed elements from the port.
            </summary>
            <param name="inlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)">
            <summary>
            Once the callback <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> for an input port has been invoked, the element that has been pushed
            can be retrieved via this method. After <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> has been called the port is considered to be empty, and further
            calls to <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> will fail until the port is pulled again and a new element is pushed as a response.
            
            The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)"/> can be used to query if the port has an element that can be grabbed or not.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="inlet"/> is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})">
            <summary>
            Once the callback <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> for an input port has been invoked, the element that has been pushed
            can be retrieved via this method. After <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> has been called the port is considered to be empty, and further
            calls to <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> will fail until the port is pulled again and a new element is pushed as a response.
            
            The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)"/> can be used to query if the port has an element that can be grabbed or not.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)">
            <summary>
            Indicates whether there is already a pending pull for the given input port. If this method returns true 
            then <see cref="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)"/> must return false for that same port.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled``1(Akka.Streams.Inlet{``0})">
            <summary>
            Indicates whether there is already a pending pull for the given input port. If this method returns true 
            then <see cref="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)"/> must return false for that same port.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)">
            <summary>
            Indicates whether there is an element waiting at the given input port. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> can be used to retrieve the
            element. After calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> this method will return false.
            
            If this method returns true then <see cref="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)"/> will return false for that same port.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable``1(Akka.Streams.Inlet{``0})">
            <summary>
            Indicates whether there is an element waiting at the given input port. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> can be used to retrieve the
            element. After calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> this method will return false.
            
            If this method returns true then <see cref="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)"/> will return false for that same port.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsClosed(Akka.Streams.Inlet)">
            <summary>
            Indicates whether the port has been closed. A closed port cannot be pulled.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsClosed``1(Akka.Streams.Inlet{``0})">
            <summary>
            Indicates whether the port has been closed. A closed port cannot be pulled.
            </summary>
            <param name="inlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)">
            <summary>
            Emits an element through the given output port. Calling this method twice before a <see cref="M:Akka.Streams.Stage.GraphStageLogic.Pull``1(Akka.Streams.Inlet{``0})"/> has been arrived
            will fail. There can be only one outstanding push request at any given time. The method <see cref="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)"/> can be
            used to check if the port is ready to be pushed or not.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="element">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="outlet"/> is closed or already pulled.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetKeepGoing(System.Boolean)">
            <summary>
            Controls whether this stage shall shut down when all its ports are closed, which
            is the default. In order to have it keep going past that point this method needs
            to be called with a true argument before all ports are closed, and afterwards
            it will not be closed until this method is called with a false argument or the
            stage is terminated via <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)"/>.
            </summary>
            <param name="enabled">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Complete(Akka.Streams.Outlet)">
            <summary>
            Signals that there will be no more elements emitted on the given port.
            </summary>
            <param name="outlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Complete``1(Akka.Streams.Outlet{``0})">
            <summary>
            Signals that there will be no more elements emitted on the given port.
            </summary>
            <param name="outlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Fail``1(Akka.Streams.Outlet{``0},System.Exception)">
            <summary>
            Signals failure through the given port.
            </summary>
            <param name="outlet">TBD</param>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage">
            <summary>
            Automatically invokes <see cref="M:Akka.Streams.Stage.GraphStageLogic.Cancel``1(Akka.Streams.Inlet{``0})"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.Complete(Akka.Streams.Outlet)"/> on all the input or output ports that have been called,
            then marks the stage as stopped.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)">
            <summary>
            Automatically invokes <see cref="M:Akka.Streams.Stage.GraphStageLogic.Cancel``1(Akka.Streams.Inlet{``0})"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.Fail``1(Akka.Streams.Outlet{``0},System.Exception)"/> on all the input or output ports that have been called,
            then marks the stage as stopped.
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable``1(Akka.Streams.Outlet{``0})">
            <summary>
            Return true if the given output port is ready to be pushed.
            </summary>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsClosed``1(Akka.Streams.Outlet{``0})">
            <summary>
            Indicates whether the port has been closed. A closed port cannot be pushed.
            </summary>
            <param name="outlet">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ReadMany``1(Akka.Streams.Inlet{``0},System.Int32,System.Action{System.Collections.Generic.IEnumerable{``0}},System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Read a number of elements from the given inlet and continue with the given function,
            suspending execution if necessary. This action replaces the <see cref="T:Akka.Streams.Stage.InHandler"/>
            for the given inlet if suspension is needed and reinstalls the current
            handler upon receiving the last <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> signal.
            
            If upstream closes before N elements have been read,
            the <paramref name="onComplete"/> function is invoked with the elements which were read.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
            <param name="n">TBD</param>
            <param name="andThen">TBD</param>
            <param name="onComplete">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="n"/> is less than zero.
            </exception>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the specified <paramref name="inlet"/> is currently reading.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Read``1(Akka.Streams.Inlet{``0},System.Action{``0},System.Action)">
            <summary>
            Read an element from the given inlet and continue with the given function,
            suspending execution if necessary. This action replaces the <see cref="T:Akka.Streams.Stage.InHandler"/>
            for the given inlet if suspension is needed and reinstalls the current
            handler upon receiving the <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> signal (before invoking the <paramref name="andThen"/> function).
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
            <param name="andThen">TBD</param>
            <param name="onClose">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the specified <paramref name="inlet"/> is currently reading.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.AbortReading``1(Akka.Streams.Inlet{``0})">
            <summary>
            Abort outstanding (suspended) reading for the given inlet, if there is any.
            This will reinstall the replaced handler that was in effect before the read
            call.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="inlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>
            Emit a sequence of elements through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="elements">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Emit a sequence of elements through the given outlet, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerator{``0},System.Action)">
            <summary>
            Emit a sequence of elements through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="enumerator">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Emit a sequence of elements through the given outlet, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="enumerator">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0,System.Action)">
            <summary>
            Emit an element through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="element">TBD</param>
            <param name="andThen">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0)">
            <summary>
            Emit an element through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.AbortEmitting``1(Akka.Streams.Outlet{``0})">
            <summary>
            Abort outstanding (suspended) emissions for the given outlet, if there are any.
            This will reinstall the replaced handler that was in effect before the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0,System.Action)"/>
            call.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="outlet">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PassAlong``2(Akka.Streams.Inlet{``1},Akka.Streams.Outlet{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Install a handler on the given inlet that emits received elements on the
            given outlet before pulling for more data. <paramref name="doFinish"/> and <paramref name="doFail"/> control whether
            completion or failure of the given inlet shall lead to stage termination or not.
            <paramref name="doPull"/> instructs to perform one initial pull on the <paramref name="from"/> port.
            </summary>
            <typeparam name="TOut">TBD</typeparam>
            <typeparam name="TIn">TBD</typeparam>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
            <param name="doFinish">TBD</param>
            <param name="doFail">TBD</param>
            <param name="doPull">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback``1(System.Action{``0})">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.GraphStage`1"/> with an asynchronous notification. The delegate returned 
            is safe to be called from other threads and it will in the background thread-safely
            delegate to the passed callback function. I.e. it will be called by the external world and
            the passed handler will be invoked eventually in a thread-safe way by the execution environment.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.GraphStageLogic"/>.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="handler">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback(System.Action)">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.GraphStage`1"/> with an asynchronous notification. The delegate returned 
            is safe to be called from other threads and it will in the background thread-safely
            delegate to the passed callback function. I.e. it will be called by the external world and
            the passed handler will be invoked eventually in a thread-safe way by the execution environment.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.GraphStageLogic"/>.
            </summary>
            <param name="handler">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetStageActor(Akka.Streams.Stage.StageActorRef.Receive)">
            <summary>
            Initialize a <see cref="T:Akka.Streams.Stage.StageActorRef"/> which can be used to interact with from the outside world "as-if" an actor.
            The messages are looped through the <see cref="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback``1(System.Action{``0})"/> mechanism of <see cref="T:Akka.Streams.Stage.GraphStage`1"/> so they are safe to modify
            internal state of this stage.
            
            This method must (the earliest) be called after the <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> constructor has finished running,
            for example from the <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/> callback the graph stage logic provides.
            
            Created <see cref="T:Akka.Streams.Stage.StageActorRef"/> to get messages and watch other actors in synchronous way.
            
            The <see cref="T:Akka.Streams.Stage.StageActorRef"/>'s lifecycle is bound to the Stage, in other words when the Stage is finished,
            the Actor will be terminated as well. The entity backing the <see cref="T:Akka.Streams.Stage.StageActorRef"/> is not a real Actor,
            but the <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> itself, therefore it does not react to <see cref="T:Akka.Actor.PoisonPill"/>.
            </summary>
            <param name="receive">Callback that will be called upon receiving of a message by this special Actor</param>
            <returns>Minimal actor with watch method</returns>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.StageActorName">
            <summary>
            Override and return a name to be given to the StageActor of this stage.
            
            This method will be only invoked and used once, during the first <see cref="M:Akka.Streams.Stage.GraphStageLogic.GetStageActor(Akka.Streams.Stage.StageActorRef.Receive)"/>
            invocation whichc reates the actor, since subsequent `getStageActors` calls function
            like `become`, rather than creating new actors.
            
            Returns an empty string by default, which means that the name will a unique generated String (e.g. "$$a").
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.BeforePreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.AfterPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PreStart">
            <summary>
            Invoked before any external events are processed, at the startup of the stage.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PostStop">
            <summary>
            Invoked after processing of external events stopped because the stage is about to stop or fail.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1">
            <summary>
            INTERNAL API
            
            This allows the dynamic creation of an Inlet for a GraphStage which is
            connected to a Sink that is available for materialization (e.g. using
            the <see cref="P:Akka.Streams.Stage.GraphStageLogic.SubFusingMaterializer"/>). Care needs to be taken to cancel this Inlet
            when the stage shuts down lest the corresponding Sink be left hanging.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.#ctor(Akka.Streams.Stage.GraphStageLogic,System.String)">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.Sink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.SetHandler(Akka.Streams.Stage.InHandler)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.IsAvailable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.IsClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.HasBeenPulled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.Grab">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when this inlet is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.Pull">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when this inlet is closed or already pulled.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.CreateSubSinkInlet``1(System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1">
            <summary>
            INTERNAL API
            
            This allows the dynamic creation of an Outlet for a GraphStage which is
            connected to a Source that is available for materialization (e.g. using
            the <see cref="P:Akka.Streams.Stage.GraphStageLogic.SubFusingMaterializer"/>). Care needs to be taken to complete this
            Outlet when the stage shuts down lest the corresponding Sink be left
            hanging. It is good practice to use the <see cref="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Timeout(System.TimeSpan)"/> method to cancel this
            Outlet in case the corresponding Source is not materialized within a
            given time limit, see e.g. ActorMaterializerSettings.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.#ctor(Akka.Streams.Stage.GraphStageLogic,System.String)">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="name">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Source">
            <summary>
            Get the Source for this dynamic output port.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.IsAvailable">
            <summary>
            Returns true if this output port can be pushed.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.IsClosed">
            <summary>
            Returns true if this output port is closed, but caution
            THIS WORKS DIFFERENTLY THAN THE NORMAL isClosed(out).
            Due to possibly asynchronous shutdown it may not return
            true immediately after <see cref="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Complete"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Fail(System.Exception)"/> have returned.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Timeout(System.TimeSpan)">
            <summary>
            Set the source into timed-out mode if it has not yet been materialized.
            </summary>
            <param name="d">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.SetHandler(Akka.Streams.Stage.IOutHandler)">
            <summary>
            Set OutHandler for this dynamic output port; this needs to be done before
            the first substream callback can arrive.
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Push(`0)">
            <summary>
            Push to this output port.
            </summary>
            <param name="elem">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Complete">
            <summary>
            Complete this output port. 
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Fail(System.Exception)">
            <summary>
            Fail this output port.
            </summary>
            <param name="ex">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Stage.IInHandler">
            <summary>
            Collection of callbacks for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.InHandler">
            <summary>
            Collection of callbacks for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.IOutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IOutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IOutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.OutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.InAndOutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/> and
            for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.InGraphStageLogic">
            <summary>
            A <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> that implements <see cref="T:Akka.Streams.Stage.IInHandler"/>.
            <para/>
            <see cref="M:Akka.Streams.Stage.InGraphStageLogic.OnUpstreamFinish"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/>
            <para/>
            <see cref="M:Akka.Streams.Stage.InGraphStageLogic.OnUpstreamFailure(System.Exception)"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InGraphStageLogic.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inCount">TBD</param>
            <param name="outCount">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InGraphStageLogic.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InGraphStageLogic.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InGraphStageLogic.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InGraphStageLogic.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.OutGraphStageLogic">
            <summary>
            A <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> that implements <see cref="T:Akka.Streams.Stage.IOutHandler"/>.
            <para/>
            <see cref="M:Akka.Streams.Stage.OutGraphStageLogic.OnDownstreamFinish"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutGraphStageLogic.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inCount">TBD</param>
            <param name="outCount">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.OutGraphStageLogic.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.OutGraphStageLogic.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutGraphStageLogic.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.InAndOutGraphStageLogic">
            <summary>
            A <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> that implements <see cref="T:Akka.Streams.Stage.IInHandler"/> and <see cref="T:Akka.Streams.Stage.IOutHandler"/>.
            <para/>
            <see cref="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnUpstreamFinish"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/>
            <para/>
            <see cref="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnUpstreamFailure(System.Exception)"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)"/>
            <para/>
            <see cref="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnDownstreamFinish"/> calls <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inCount">TBD</param>
            <param name="outCount">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet{``0},``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutGraphStageLogic.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StageActorRefNotInitializedException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.StageActorRefNotInitializedException.Instance">
            <summary>
            The singleton instance of this exception
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.EagerTerminateInput">
            <summary>
            Input handler that terminates the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.EagerTerminateInput.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.EagerTerminateInput.OnPush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IgnoreTerminateInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.IgnoreTerminateInput.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IgnoreTerminateInput.OnPush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IgnoreTerminateInput.OnUpstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ConditionalTerminateInput">
            <summary>
            Input handler that terminates the state upon receiving completion 
            if the given condition holds at that time.The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateInput.#ctor(System.Func{System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateInput.OnPush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateInput.OnUpstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.TotallyIgnorantInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion nor failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.TotallyIgnorantInput.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TotallyIgnorantInput.OnPush">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TotallyIgnorantInput.OnUpstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TotallyIgnorantInput.OnUpstreamFailure(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="e">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.EagerTerminateOutput">
            <summary>
            Output handler that terminates the stage upon cancellation.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.EagerTerminateOutput.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.EagerTerminateOutput.OnPull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IgnoreTerminateOutput">
            <summary>
            Output handler that does not terminate the stage upon cancellation.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.IgnoreTerminateOutput.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IgnoreTerminateOutput.OnPull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IgnoreTerminateOutput.OnDownstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ConditionalTerminateOutput">
            <summary>
            Output handler that terminates the state upon receiving completion if the
            given condition holds at that time.The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateOutput.#ctor(System.Func{System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateOutput.OnPull">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.ConditionalTerminateOutput.OnDownstreamFinish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StageActor">
            <summary>
            Minimal actor to work with other actors and watch them in a synchronous ways.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.StageActor.Ref">
            <summary>
            The <see cref="T:Akka.Actor.IActorRef"/> by which this <see cref="T:Akka.Streams.Stage.StageActor"/> can be contacted from the outside.
            This is a full-fledged <see cref="T:Akka.Actor.IActorRef"/> that supports watching and being watched
            as well as location transparent (remote) communication.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StageActor.Become(Akka.Streams.Stage.StageActorRef.Receive)">
            <summary>
            Special `Become` allowing to swap the behaviour of this <see cref="T:Akka.Streams.Stage.StageActor"/>.
            Unbecome is not available.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StageActor.Stop">
            <summary>
            Stops current <see cref="T:Akka.Streams.Stage.StageActor"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StageActor.Watch(Akka.Actor.IActorRef)">
            <summary>
            Makes current <see cref="T:Akka.Streams.Stage.StageActor"/> watch over given <paramref name="actorRef"/>.
            It will be notified when an underlying actor is <see cref="T:Akka.Actor.Terminated"/>.
            </summary>
            <param name="actorRef"></param>
        </member>
        <member name="M:Akka.Streams.Stage.StageActor.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            Makes current <see cref="T:Akka.Streams.Stage.StageActor"/> stop watching previously <see cref="M:Akka.Streams.Stage.StageActor.Watch(Akka.Actor.IActorRef)"/>ed <paramref name="actorRef"/>.
            If <paramref name="actorRef"/> was not watched over, this method has no result.
            </summary>
            <param name="actorRef"></param>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1">
            <summary>
            <para>
            This class wraps callback for <see cref="T:Akka.Streams.Stage.GraphStage`1"/> instances and gracefully handles
            cases when stage is not yet initialized or already finished.
            </para>
            <para>
            While <see cref="T:Akka.Streams.Stage.GraphStage`1"/> is not initialized it adds all requests to list.
            As soon as <see cref="T:Akka.Streams.Stage.GraphStage`1"/> is started it stops collecting requests (pointing
            to real callback function) and runs all callbacks from the list.
            </para>
            <para>
            Intended to be used by <see cref="T:Akka.Streams.Stage.GraphStage`1"/> that share callback with outer world.
            </para>
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="inCount">TBD</param>
            <param name="outCount">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1.#ctor(Akka.Streams.Shape)">
            <summary>
            TBD
            </summary>
            <param name="shape">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1.StopCallback(System.Action{`0})">
            <summary>
            TBD
            </summary>
            <param name="callback">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1.InitCallback(System.Action{`0})">
            <summary>
            TBD
            </summary>
            <param name="callback">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1.InvokeCallbacks(`0)">
            <summary>
            TBD
            </summary>
            <param name="arg">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.IStageLogging">
             <summary>
             Simple way to obtain a <see cref="T:Akka.Event.ILoggingAdapter"/> when used together with an <see cref="T:Akka.Streams.ActorMaterializer"/>.
             If used with a different materializer <see cref="T:Akka.Event.NoLogger"/> will be returned.
            
             Make sure to only access `Log` from GraphStage callbacks (such as `Pull`, `Push` or the async-callback).
            
             Note, abiding to <see cref="T:Akka.Streams.Attributes.LogLevels"/> has to be done manually,
             the logger itself is configured based on the logSource provided to it. Also, the `Log`
             itself would not know if you're calling it from a "on element" context or not, which is why
             these decisions have to be handled by the stage itself.
             </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IStage`2">
            <summary>
            General interface for stream transformation.
            
            Custom <see cref="T:Akka.Streams.Stage.IStage`2"/> implementations are intended to be used with
            <see cref="M:Akka.Streams.Dsl.FlowOperations.Transform``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Stage.IStage{``1,``2}})"/> to extend the <see cref="T:Akka.Streams.Dsl.FlowOperations"/> API when there
            is no specialized operator that performs the transformation.
            
            Custom implementations are subclasses of <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> or
            <see cref="T:Akka.Streams.Stage.DetachedStage`2"/>. Sometimes it is convenient to extend
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> for support of become like behavior.
            
            It is possible to keep state in the concrete <see cref="T:Akka.Streams.Stage.IStage`2"/> instance with
            ordinary instance variables. The <see cref="T:Akka.Streams.ITransformerLike`2"/> is executed by an actor and
            therefore you do not have to add any additional thread safety or memory
            visibility constructs to access the state from the callback methods.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Stage.PushPullStage`2">
            <summary>
            <para>
            <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> implementations participate in 1-bounded regions. For every external non-completion signal these
            stages produce *exactly one* push or pull signal.
            </para>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstream, or you can absorb the
            element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>.
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> has requested more elements with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            <para>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> has support for making it easy to emit more than one element from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/>.
            </para>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>> is called when there is demand from downstream, i.e. you are allowed to push one element
            downstream with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. If you
            always perform transitive pull by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/> from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> you can use 
            <see cref="T:Akka.Streams.Stage.PushStage`2"/> instead of <see cref="T:Akka.Streams.Stage.PushPullStage`2"/>.
            </para>
            <para>
            Stages are allowed to do early completion of downstream and cancel of upstream. This is done with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>,
            which is a combination of cancel/complete.
            </para>
            <para>
            Since OnComplete is not a backpressured signal it is sometimes preferable to push a final element and then
            immediately finish. This combination is exposed as <see cref="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)"/> which enables stages to
            propagate completion events without waiting for an extra round of pull.
            </para>
            <para>
            Another peculiarity is how to convert termination events (complete/failure) into elements. The problem
            here is that the termination events are not backpressured while elements are. This means that simply calling
            <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> as a response to <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> will very likely break boundedness
            and result in a buffer overflow somewhere. Therefore the only allowed command in this case is
            <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> which stops the propagation of the termination signal, and puts the stage in a
            <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/> state. Depending on whether the stage has a pending pull signal it
            has not yet "consumed" by a push its <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> handler might be called immediately or later. From
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> final elements can be pushed before completing downstream with <see cref="M:Akka.Streams.Stage.IContext.Finish"/> or
            <see cref="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)"/>.
            </para>
            <para>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> has support for making it easy to emit final elements.
            </para>
            <para>
            All these rules are enforced by types and runtime checks where needed. Always return the <see cref="T:Akka.Streams.Supervision.Directive"/>
            from the call to the <see cref="T:Akka.Streams.Stage.IContext"/> method, and do only call <see cref="T:Akka.Streams.Stage.IContext"/> commands once per callback.
            </para>
            </summary>
            <seealso cref="T:Akka.Streams.Stage.DetachedStage`2"/>
            <seealso cref="T:Akka.Streams.Stage.StatefulStage`2"/>
            <seealso cref="T:Akka.Streams.Stage.PushStage`2"/>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Stage.PushStage`2">
            <summary>
            <see cref="T:Akka.Streams.Stage.PushStage`2"/> is a <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> that always perform transitive pull by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/> from <see cref="M:Akka.Streams.Stage.PushStage`2.OnPull(Akka.Streams.Stage.IContext{`1})"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.PushStage`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            Always pulls from upstream.
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.DetachedStage`2">
            <summary>
            DetachedStage can be used to implement operations similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Buffer``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,Akka.Streams.OverflowStrategy)"/>,
            <see cref="M:Akka.Streams.Dsl.FlowOperations.Expand``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerator{``2}})"/> and <see cref="M:Akka.Streams.Dsl.FlowOperations.Conflate``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})"/>.
            
            DetachedStage implementations are boundaries between 1-bounded regions. This means that they need to enforce the
            "exactly one" property both on their upstream and downstream regions. As a consequence a DetachedStage can never
            answer an <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> with a <see cref="M:Akka.Streams.Stage.IContext.Pull"/> or answer an <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> with a <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> since such an action
            would "steal" the event from one region (resulting in zero signals) and would inject it to the other region
            (resulting in two signals).
            
            However, DetachedStages have the ability to call <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldUpstream"/> and <see cref="M:Akka.Streams.Stage.IDetachedContext.HoldDownstream"/> as a response to
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> and <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> which temporarily takes the signal off and
            stops execution, at the same time putting the stage in an <see cref="P:Akka.Streams.Stage.IDetachedContext.IsHoldingBoth"/> state.
            If the stage is in a holding state it contains one absorbed signal, therefore in this state the only possible
            command to call is <see cref="M:Akka.Streams.Stage.IDetachedContext.PushAndPull(System.Object)"/> which results in two events making the
            balance right again: 1 hold + 1 external event = 2 external event
            
            This mechanism allows synchronization between the upstream and downstream regions which otherwise can progress
            independently.
            
            @see <see cref="T:Akka.Streams.Stage.PushPullStage`2"/>
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.Stage.DetachedStage`2.IsDetached">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StageState`2">
            <summary>
            The behavior of <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> is defined by these two methods, which
            has the same semantics as corresponding methods in <see cref="T:Akka.Streams.Stage.PushPullStage`2"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage.IAndThen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage.Finish">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.StatefulStage.Finish.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage.Become`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="F:Akka.Streams.Stage.StatefulStage.Become`2.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage.Become`2.#ctor(Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="state">TBD</param>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage.Stay">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.StatefulStage.Stay.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage`2">
            <summary>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> is a <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> that provides convenience to make some things easier.
            
            The behavior is defined in <see cref="T:Akka.Streams.Stage.StageState`2"/> instances. The initial behavior is specified
            by subclass implementing the <see cref="P:Akka.Streams.Stage.StatefulStage`2.Initial"/> method. The behavior can be changed by using <see cref="M:Akka.Streams.Stage.StatefulStage`2.Become(Akka.Streams.Stage.StageState{`0,`1})"/>.
            
            Use <see cref="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1},Akka.Streams.Stage.StageState{`0,`1})"/> or <see cref="M:Akka.Streams.Stage.StatefulStage`2.EmitAndFinish(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})"/> to push more than one element from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or
            <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/>.
            
            Use <see cref="M:Akka.Streams.Stage.StatefulStage`2.TerminationEmit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})"/> to push final elements from <see cref="M:Akka.Streams.Stage.StatefulStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/>.
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.#ctor(Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="current">TBD</param>
        </member>
        <member name="P:Akka.Streams.Stage.StatefulStage`2.Initial">
            <summary>
            Concrete subclass must return the initial behavior from this method.
            **Warning:** This method must not be implemented as `val`.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.StatefulStage`2.Current">
            <summary>
            Current state.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Become(Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            Change the behavior to another <see cref="T:Akka.Streams.Stage.StageState`2"/>.
            </summary>
            <param name="state">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when the specified <paramref name="state"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})">
            <summary>
            Invokes current state.
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            Invokes current state.
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext{`1})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstream.
            </summary>
            <param name="enumerator">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1},Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstream and after that change behavior.
            </summary>
            <param name="enumerator">TBD</param>
            <param name="context">TBD</param>
            <param name="nextState">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when either currently in the emitting state or the specified <paramref name="enumerator"/> is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.TerminationEmit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StatefulStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext{`1})"/> to push final elements downstream
            before completing the stream successfully. Note that if this is used from
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> the failure will be absorbed and the stream will be completed
            successfully.
            </summary>
            <param name="enumerator">TBD</param>
            <param name="context">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when the specified <paramref name="enumerator"/> is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.EmitAndFinish(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstream and after that finish (complete downstream, cancel upstreams).
            </summary>
            <param name="enumerator">TBD</param>
            <param name="context">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when either currently in the emitting state or the specified <paramref name="enumerator"/> is empty.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Stage.EmittingState`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Stage.EmittingState`2.#ctor(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.StatefulStage.IAndThen,System.Func{Akka.Streams.Stage.IContext{`1},Akka.Streams.Stage.ISyncDirective})">
            <summary>
            TBD
            </summary>
            <param name="enumerator">TBD</param>
            <param name="andThen">TBD</param>
            <param name="onPull">TBD</param>
        </member>
        <member name="M:Akka.Streams.Stage.EmittingState`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <exception cref="T:System.NotImplementedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.EmittingState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <param name="context">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when currently in the emitting state.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Stage.EmittingState`2.Copy(System.Collections.Generic.IEnumerator{`1})">
            <summary>
            TBD
            </summary>
            <param name="enumerator">TBD</param>
            <exception cref="T:System.NotImplementedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.StreamLimitReachedException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.StreamLimitReachedException.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.StreamLimitReachedException"/> class.
            </summary>
            <param name="max">The maximum number of streams</param>
        </member>
        <member name="T:Akka.Streams.ISinkRef`1">
            <summary>
            A <see cref="T:Akka.Streams.ISinkRef`1"/> allows sharing a "reference" to a <see cref="T:Akka.Streams.Dsl.Sink`2"/> with others,
            with the main purpose of crossing a network boundary. Usually obtaining a SinkRef would be done via Actor messaging,
            in which one system asks a remote one, to accept some data from it, and the remote one decides to accept the
            request to send data in a back-pressured streaming fashion -- using a sink ref.
            
            To create a <see cref="T:Akka.Streams.ISinkRef`1"/> you have to materialize the <see cref="P:Akka.Streams.ISinkRef`1.Sink"/> that you want to obtain
            a reference to by attaching it to a <see cref="M:Akka.Streams.Dsl.StreamRefs.SinkRef``1"/>.
            
            Stream refs can be seen as Reactive Streams over network boundaries.
            
            For additional configuration see `reference.conf` as well as <see cref="T:Akka.Streams.StreamRefAttributes"/>.
            </summary>
            <seealso cref="T:Akka.Streams.ISourceRef`1"/>
        </member>
        <member name="T:Akka.Streams.ISourceRef`1">
            <summary>
            A SourceRef allows sharing a "reference" with others, with the main purpose of crossing a network boundary.
            Usually obtaining a SourceRef would be done via Actor messaging, in which one system asks a remote one,
            to share some data with it, and the remote one decides to do so in a back-pressured streaming fashion -- using a stream ref.
            
            To create a <see cref="T:Akka.Streams.ISourceRef`1"/> you have to materialize the <see cref="P:Akka.Streams.ISourceRef`1.Source"/> that you want to
            obtain a reference to by attaching it to a <see cref="M:Akka.Streams.Dsl.StreamRefs.SourceRef``1"/>.
            
            Stream refs can be seen as Reactive Streams over network boundaries.
            
            For additional configuration see `reference.conf` as well as <see cref="T:Akka.Streams.StreamRefAttributes"/>.
            </summary>
            <seealso cref="T:Akka.Streams.ISinkRef`1"/>
        </member>
        <member name="T:Akka.Streams.InvalidPartnerActorException">
            <summary>
            Stream refs establish a connection between a local and remote actor, representing the origin and remote sides
            of a stream. Each such actor refers to the other side as its "partner". We make sure that no other actor than
            the initial partner can send demand/messages to the other side accidentally.
            
            This exception is thrown when a message is recived from a non-partner actor,
            which could mean a bug or some actively malicient behavior from the other side.
            
            This is not meant as a security feature, but rather as plain sanity-check.
            </summary>
        </member>
        <member name="T:Akka.Streams.StreamTcpException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.StreamTcpException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.StreamTcpException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Streams.StreamTcpException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.StreamTcpException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.BindFailedException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.BindFailedException.Instance">
            <summary>
            The single instance of this exception
            </summary>
        </member>
        <member name="T:Akka.Streams.ConnectionException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.ConnectionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.ConnectionException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Streams.ConnectionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.ConnectionException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:Akka.Streams.SubstreamCancelStrategy">
            <summary>
            Represents a strategy that decides how to deal with substream events.
            </summary>
        </member>
        <member name="F:Akka.Streams.SubstreamCancelStrategy.Propagate">
            <summary>
            Cancel the stream of streams if any substream is cancelled.
            </summary>
        </member>
        <member name="F:Akka.Streams.SubstreamCancelStrategy.Drain">
            <summary>
            Drain substream on cancellation in order to prevent stalling of the stream of streams.
            </summary>
        </member>
        <member name="T:Akka.Streams.Supervision.Directive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Stop">
            <summary>
            The stream will be completed with failure if application code for processing an element throws an exception..
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Resume">
            <summary>
            The element is dropped and the stream continues if application code for processing an element throws an exception.
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Restart">
            <summary>
            The element is dropped and the stream continues after restarting the stage if application code for processing 
            an element throws an exception. Restarting a stage means that any accumulated state is cleared. 
            This is typically performed by creating a new instance of the stage.
            </summary>
        </member>
        <member name="T:Akka.Streams.Supervision.Decider">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Supervision.Deciders">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Deciders.StoppingDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Deciders.ResumingDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Deciders.RestartingDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Streams.ThrottleMode">
            <summary>
            Represents a mode that decides how to deal exceed rate for Throttle combinator.
            </summary>
        </member>
        <member name="F:Akka.Streams.ThrottleMode.Shaping">
            <summary>
            Tells throttle to make pauses before emitting messages to meet throttle rate
            </summary>
        </member>
        <member name="F:Akka.Streams.ThrottleMode.Enforcing">
            <summary>
            Makes throttle fail with exception when upstream is faster than throttle rate
            </summary>
        </member>
        <member name="T:Akka.Streams.ITransformerLike`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="P:Akka.Streams.ITransformerLike`2.IsComplete">
            <summary>
            Invoked after handing off the elements produced from one input element to the
            downstream subscribers to determine whether to end stream processing at this point;
            in that case the upstream subscription is canceled.
            </summary>
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnNext(`0)">
            <summary>
            Invoked for each element to produce a (possibly empty) sequence of
            output elements.
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnTermination(System.Exception)">
            <summary>
            Invoked before the Transformer terminates (either normal completion or after an onError)
            to produce a (possibly empty) sequence of elements in response to the
            end-of-stream event.
            
            This method is only called if <see cref="M:Akka.Streams.ITransformerLike`2.OnError(System.Exception)"/> does not throw an exception. The default implementation
            of <see cref="M:Akka.Streams.ITransformerLike`2.OnError(System.Exception)"/> throws the received cause forcing the failure to propagate downstream immediately.
            </summary>
            <param name="cause">Contains a non-empty option with the error causing the termination or an empty option
                                if the Transformer was completed normally</param>
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnError(System.Exception)">
            <summary>
            Invoked when failure is signaled from upstream. If this method throws an exception, then onError is immediately
            propagated downstream. If this method completes normally then <see cref="M:Akka.Streams.ITransformerLike`2.OnTermination(System.Exception)"/> is invoked as a final
            step, passing the original cause.
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.Cleanup">
            <summary>
            Invoked after normal completion or failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.TransformerLikeBase`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TIn">TBD</typeparam>
            <typeparam name="TOut">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnNext(`0)">
            <summary>
            Invoked for each element to produce a (possibly empty) sequence of
            output elements.
            </summary>
            <param name="element">TBD</param>
        </member>
        <member name="P:Akka.Streams.TransformerLikeBase`2.IsComplete">
            <summary>
            Invoked after handing off the elements produced from one input element to the
            downstream subscribers to determine whether to end stream processing at this point;
            in that case the upstream subscription is canceled.
            </summary>
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnTermination(System.Exception)">
            <summary>
            Invoked before the Transformer terminates (either normal completion or after an onError)
            to produce a (possibly empty) sequence of elements in response to the
            end-of-stream event.
            
            This method is only called if <see cref="M:Akka.Streams.TransformerLikeBase`2.OnError(System.Exception)"/> does not throw an exception. The default implementation
            of <see cref="M:Akka.Streams.TransformerLikeBase`2.OnError(System.Exception)"/> throws the received cause forcing the failure to propagate downstream immediately.
            </summary>
            <param name="cause">Contains a non-empty option with the error causing the termination or an empty option
                                if the Transformer was completed normally</param>
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnError(System.Exception)">
            <summary>
            Invoked when failure is signaled from upstream. If this method throws an exception, then onError is immediately
            propagated downstream. If this method completes normally then <see cref="M:Akka.Streams.TransformerLikeBase`2.OnTermination(System.Exception)"/> is invoked as a final
            step, passing the original cause.
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.Cleanup">
            <summary>
            Invoked after normal completion or failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Util.EnumeratorEnumerable`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Util.EnumeratorEnumerable`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Util.EnumeratorEnumerable`1"/> class.
            </summary>
            <param name="enumeratorFactory">The method used to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> to iterate over this enumerable.</param>
        </member>
        <member name="M:Akka.Streams.Util.EnumeratorEnumerable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Util.ContinuallyEnumerable`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="T:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator" /> class.
            </summary>
            <param name="enumeratorFactory">The method used to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> to iterate over an enumerable.</param>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator.MoveNext">
            <inheritdoc/>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the enumerator has passed the end of an enumerable.
            </exception>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="P:Akka.Streams.Util.ContinuallyEnumerable`1.ContinuallyEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Streams.Util.ContinuallyEnumerable`1" /> class.
            </summary>
            <param name="enumeratorFactory">The method used to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> to iterate over this enumerable.</param>
        </member>
        <member name="M:Akka.Streams.Util.ContinuallyEnumerable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Streams.Util.Int32Extensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Util.Int32Extensions.NumberOfLeadingZeros(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Util.Int32Extensions.NumberOfTrailingZeros(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="i">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Util.IIterator`1">
            <summary>
            Interface matching Java's iterator semantics.
            Should only be needed in rare circumstances, where knowing whether there are
            more elements without consuming them makes the code easier to write.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Util.IIterator`1.HasNext">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Util.IIterator`1.Next">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Util.IteratorAdapter`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Streams.Util.IteratorAdapter`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            TBD
            </summary>
            <param name="enumerator">TBD</param>
        </member>
        <member name="M:Akka.Streams.Util.IteratorAdapter`1.HasNext">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Util.IteratorAdapter`1.Next">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Util.ObjectExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Util.ObjectExtensions.IsDefaultForType``1(``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.Util.TypeExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Streams.Util.TypeExtensions.GetSubscribedType(System.Type)">
            <summary>
            TBD
            </summary>
            <param name="type">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Streams.Util.TypeExtensions.GetPublishedType(System.Type)">
            <summary>
            TBD
            </summary>
            <param name="type">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Streams.WatchedActorTerminatedException">
            <summary>
            Used as failure exception by an `ask` operator if the target actor terminates.
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Flow`3.Ask``1(Akka.Actor.IActorRef,System.TimeSpan,System.Int32)"/>
            <seealso cref="M:Akka.Streams.Dsl.Source`2.Ask``1(Akka.Actor.IActorRef,System.TimeSpan,System.Int32)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Watch``2(Akka.Streams.Dsl.Flow{``0,``0,``1},Akka.Actor.IActorRef)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Watch``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Actor.IActorRef)"/>
        </member>
    </members>
</doc>
