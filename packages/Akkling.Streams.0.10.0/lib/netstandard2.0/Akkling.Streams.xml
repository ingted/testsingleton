<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Akkling.Streams</name></assembly>
<members>
<member name="M:Akkling.Streams.Framing.json(System.Int32)">
<summary>
 Returns a Flow that implements a &quot;brace counting&quot; based framing stage for emitting valid JSON chunks.
 It scans the incoming data stream for valid JSON objects and returns chunks of ByteStrings containing only those valid chunks.
</summary>
</member>
<member name="M:Akkling.Streams.Framing.simpleProtocol(System.Int32)">
<summary>
 Returns a BidiFlow that implements a simple framing protocol. This is a convenience wrapper over &lt;see cref=&quot;LengthField&quot;/&gt;
 and simply attaches a length field header of four bytes (using big endian encoding) to outgoing messages, and decodes
 such messages in the inbound direction. The decoded messages do not contain the header. 
 This BidiFlow is useful if a simple message framing protocol is needed (for example when TCP is used to send
 individual messages) but no compatibility with existing protocols is necessary. 
 The encoded frames have the layout
 {{{
     [4 bytes length field, Big Endian][User Payload]
 }}}
</summary>
</member>
<member name="P:Akkling.Streams.Framing.lengthField">
<summary>
 Creates a Flow that decodes an incoming stream of unstructured byte chunks into a stream of frames, assuming that
 incoming frames have a field that encodes their length.
 If the input stream finishes before the last frame has been fully decoded this Flow will fail the stream reporting
 a truncated frame.
</summary>
</member>
<member name="M:Akkling.Streams.Framing.lengthFieldWithOffset(System.Int32,Akka.IO.ByteOrder,System.Int32,System.Int32)">
<summary>
 Creates a Flow that decodes an incoming stream of unstructured byte chunks into a stream of frames, assuming that
 incoming frames have a field that encodes their length.
 If the input stream finishes before the last frame has been fully decoded this Flow will fail the stream reporting
 a truncated frame.
</summary>
</member>
<member name="M:Akkling.Streams.Framing.delimiter(System.Boolean,System.Int32,Akka.IO.ByteString)">
<summary>
 Creates a Flow that handles decoding a stream of unstructured byte chunks into a stream of frames where the
 incoming chunk stream uses a specific byte-sequence to mark frame boundaries.
 The decoded frames will not include the separator sequence.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ref``1">
<summary>
 A local sink which materializes a source ref which can be used by other streams (including remote ones),
 to consume data from this local stream, as if they were attached in the spot of the local Sink directly.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.broadcastHub``1(System.Int32)">
<summary>
 A BroadcastHub is a special streaming hub that is able to broadcast streamed elements 
 to a dynamic set of consumers.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.mapMatValue``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Sink{``2,``0})">
<summary>
 Transform the materialized value of this Source, leaving all other properties as they were.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.asStreamWithTimeout(System.TimeSpan)">
<summary>
 Creates a Sink which when materialized will return an stream which it is possible
 to read the values produced by the stream this Sink is attached to.
 This Sink is intended for inter-operation with legacy APIs since it is inherently blocking.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.asStream">
<summary>
 Creates a Sink which when materialized will return an stream which it is possible
 to read the values produced by the stream this Sink is attached to.
 This Sink is intended for inter-operation with legacy APIs since it is inherently blocking.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ofStreamFlushed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.IO.Stream})">
<summary>
 Creates a Sink which writes incoming ByteStrings to a stream created by the given function.
 Stream will be flushed whenever a byte array is written.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ofStream(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.IO.Stream})">
<summary>
 Creates a Sink which writes incoming ByteStrings to a stream created by the given function.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.toFileWithMode(System.IO.FileMode,System.String)">
<summary>
 Creates a Sink which writes incoming ByteString elements to the given file and either overwrites
 or appends to it.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.toFile(System.String)">
<summary>
 Creates a Sink which writes incoming ByteString elements to the given file and either overwrites
 or appends to it.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.toPublisher``1(System.Boolean)">
<summary>
 A sink that materializes into a publisher.
 If fanout is true, the materialized publisher will support multiple subscribers and
 the size of the ActorMaterializerSettings.MaxInputBufferSize configured for this stage becomes the maximum number of elements that
 the fastest subscriber can be ahead of the slowest one before slowing
 the processing down due to back pressure.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.canceled``1">
<summary>
 A sink that immediately cancels its upstream after materialization.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ofGraph``3(``0)">
<summary>
 A graph with the shape of a sink logically is a sink, this method makes it so also in type.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.queue``1">
<summary>
 Creates a sink that is materialized as an ISinkQueue&lt;&apos;t&gt;.
 ISinkQueue{TIn}.AsyncPull method is pulling element from the stream and returns Async&lt;&apos;t option&gt;,
 which completes when element is available.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ofProps``1(Akkling.Props.Props{``0})">
<summary>
 Creates a sink that is materialized to an actor ref which points to an Actor
 created according to the passed in props. Actor created by the props should
 be ActorSubscriberSink&lt;&apos;t&gt;
</summary>
</member>
<member name="M:Akkling.Streams.Sink.toActorRefAck``1(``0,``0,``0,Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akkling.ActorRefs.IActorRef{``0})">
<summary>
 Sends the elements of the stream to the given actor ref that sends back back-pressure signal.
 First element is always initMsg, then stream is waiting for acknowledgement message
 ackMsg from the given actor which means that it is ready to process
 elements. It also requires ackMsg message after each stream element
 to make backpressure work.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.toActorRef``1(``0,Akkling.ActorRefs.IActorRef{``0})">
<summary>
 Sends the elements of the stream to the given Actor ref.
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given completeMsg
 will be sent to the destination actor.
 When the stream is completed with failure a Status.Failure
 message will be sent to the destination actor.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.onComplete``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{System.Exception},Microsoft.FSharp.Core.Unit})">
<summary>
 A sink that when the flow is completed, either through a failure or normal
 completion, apply the provided function with None or Some exn.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 A sink that will invoke the given folder for every received element, giving it its previous
 output (from the second element) and the element as input.
 The returned Async computation will be completed with value of the final
 function evaluation when the input stream ends, or completed with `Failure`
 if there is a failure signaled in the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.fold``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}})">
<summary>
 A sink that will invoke the given folder function for every received element, 
 giving it its previous output (or the given zero value) and the element as input.
 The returned Async computation will be completed with value of the final
 function evaluation when the input stream ends, or completed with the streams exception
 if there is a failure signaled in the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.forEachParallel``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 A sink that will invoke the given function 
 to each of the elements as they pass in. 
 The sink is materialized into an Async computation.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.forEach``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 A sink that will invoke the given function for each received element. 
 The sink is materialized into an Async computation will be completed with success when reaching the
 normal end of the stream, or completed with a failure if there is a failure signaled in
 the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ignore``1">
<summary>
 A sink that will consume the stream and discard the elements.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.fanoutPublisher``1">
<summary>
 A sink that materializes into a publisher that can handle multiple subscribers.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.observable``1">
<summary>
 A sink that materializes into an Observable.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.publisher``1">
<summary>
 A sink that materializes into a publisher that can handle one subscriber.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.tailOption``1">
<summary>
 A sink that materializes into an Async computation of the last value received.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.tail``1">
<summary>
 A sink that materializes into an Async computation of the last value received.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.headOption``1">
<summary>
 A sink that materializes into an Async computation of the first value received.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.head``1">
<summary>
 A sink that materializes into an Async computation of the first value received.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.ofSubscriber``2(``0)">
<summary>
 Helper to create sink from subscriber.
</summary>
</member>
<member name="M:Akkling.Streams.Sink.wrap``3(``0)">
<summary>
 A graph with the shape of a sink logically is a sink, this method makes it so also in type.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.deduplicate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Filters our consecutive duplicated elements from the stream (uniqueness is recognized 
 by provided function).
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.mergeSubstreamsParallel``3(System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Flatten the sub-flows back into the super-flow by performing a merge
 with the given parallelism limit. This means that only up to &apos;n&apos; number of
 substreams will be executed at any given time. Substreams that are not
 yet executed are also not materialized, meaning that back-pressure will
 be exerted at the operator that creates the substreams when the parallelism
 limit is reached.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.mergeSubstreams``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Flatten the sub-flows back into the super-flow by performing a merge
 without parallelism limit (i.e. having an unbounded number of sub-flows
 active concurrently).
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.viaMat``7(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,Akka.Streams.Dsl.SubFlow{``4,``0,``6})">
<summary>
 Passes current subflow via another flow, resolving a returned materialized value using 
 combine function, constructing new type of subflow in the result.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.via``6(``0,Akka.Streams.Dsl.SubFlow{``1,``4,``5})">
<summary>
 Passes current subflow via another flow, constructing new type of subflow in the result.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.orElse``4(``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Provides a secondary source that will be consumed if this stream completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.

 Note that this Flow will be materialized together with the Source and just kept
 from producing elements by asserting back-pressure until its time comes or it gets
 cancelled. 
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.prepend``5(``0,Akka.Streams.Dsl.SubFlow{``3,``2,``4})">
<summary>
 Prepend the given source to this subFlow, meaning that before elements
 are generated from this subFlow, the Source&apos;s elements will be produced until it
 is exhausted, at which point SubFlow elements will start being produced.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.concat``4(``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Concatenate the given source to this subFlow, meaning that once this
 SubFlow’s input is exhausted and all result elements have been generated,
 the Source’s elements will be produced.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.mergeSort``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Merge the given source to this subFlow, taking elements as they arrive from input streams,
 picking always the smallest of the available elements(waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements(and
 does not complete).
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.mergeMat``7(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.SubFlow{``5,``3,``6})">
<summary>
 Merge the given source to this subFlow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.merge``5(``0,Akka.Streams.Dsl.SubFlow{``3,``2,``4})">
<summary>
 Merge the given source to this subFlow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.interleaveMat``7(System.Int32,``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.SubFlow{``5,``3,``6})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this subFlow.
 It first emits count number of elements from this subFlow to downstream, then - same amount for source,
 then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.interleave``4(System.Int32,``0,Akka.Streams.Dsl.SubFlow{``3,``2,``2})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this subFlow.
 It first emits number of elements from this subFlow to downstream, then - same amount for other
 source, then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.zipWith``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,``4}},Akka.Streams.Dsl.SubFlow{``3,``2,``5})">
<summary>
 Put together the elements of current subFlow and the given source
 into a stream of combined elements using a combiner function.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.zip``5(``0,Akka.Streams.Dsl.SubFlow{``3,``2,``4})">
<summary>
 Combine the elements of current subFlow and the given source into a stream of tuples.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.logWithf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.String},Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.logWith``3(System.String,Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.logf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.log``3(System.String,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.initDelay``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Delays the initial element by the specified duration.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.detach``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Detaches upstream demand from downstream demand without detaching the
 stream rates; in other words acts like a buffer of size 1.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.watchTermination``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},``1}},Akka.Streams.Dsl.SubFlow{``2,``0,``1})">
<summary>
 Materializes to Async that completes on getting termination message.
 The task completes with success when received complete message from upstream or cancel
 from downstream. It fails with the same error when received error message from
 downstream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.alsoTo``4(``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Attaches the given sink to this subFlow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.alsoToMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.SubFlow{``1,``3,``5})">
<summary>
 Attaches the given sink graph to this subFlow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.throttleWeighted``3(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.throttle``3(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.keepAlive``4(System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
 stage attempts to maintains a base rate of emitted elements towards the downstream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.backpressureTimeout``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a TimeoutException. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.idleTimeout``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 If the time between two processed elements exceed the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.completeWithin``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.initWithin``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 If the first element has not passed through this stage before the provided timeout, the stream is failed
 with a TimeoutException
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.zipi``3(Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Combine the elements of current flow into a stream of tuples consisting
 of all elements paired with their index. Indices start at 0.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.collectMerge``5(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SubFlow{``0,``3,``4})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by merging, where at most breadth
 substreams are being consumed at any given time.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.collectMap``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SubFlow{``0,``3,``4})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by concatenation,
 fully consuming one Source after the other.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.buffer``3(Akka.Streams.OverflowStrategy,System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Adds a fixed size buffer in the subFlow that allows to store elements from a faster upstream until it becomes full.
 Depending on the defined strategy it might drop elements or backpressure the upstream if
 there is no space available
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.expand``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SubFlow{``0,``3,``4})">
<summary>
 Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
 element until new element comes from the upstream. For example an expand step might repeat the last element for
 the subscriber until it receives an update from upstream.

 This element will never &quot;drop&quot; upstream elements as all elements go through at least one extrapolation step.
 This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
 subscriber.

 Expand does not support restart and resume directives. Exceptions from the extrapolate function will complete the stream with failure.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.batchWeighted``4(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.prefixAndTail``3(System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Takes up to n elements from the stream and returns a pair containing a strict sequence of the taken element
 and a stream representing the remaining elements. If `n` is zero or negative, then this will return a pair
 of an empty collection and a stream containing the whole upstream unchanged.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.batch``4(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.For example a batch step might store received elements in
 an array up to the allowed max limit if the upstream publisher is faster.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.conflate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate does not change the output type of the stream. See conflateSeeded
 for a more flexible version that can take a seed function and transform elements while rolling up.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.conflateSeeded``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate allows to derive a seed from the first element and change the aggregated type to
 be different than the input type. See conflate for a simpler version that does not change types.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.takeWithin``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 duration. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.take``3(System.Int64,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 number of elements. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.skipWithin``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Discard the elements received within the given duration at beginning of the stream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.skip``3(System.Int64,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Discard the given number of elements at the beginning of the stream.
 No elements will be dropped if parameter is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.delayWithStrategy``3(Akka.Streams.DelayOverflowStrategy,System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.Depending on the defined
 strategy it might drop elements or backpressure the upstream if
 there is no space available in the buffer.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.delay``3(System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.groupedWithin``3(System.Int32,System.TimeSpan,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.intersperse``3(``0,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.intersperseBounded``3(``0,``0,``0,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.

 Additionally can inject start and end marker elements to stream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.reduce``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Similar to fold but uses first element as zero element.
 Applies the given function towards its current and next value,
 yielding the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.asyncFold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Similar to fold but with an asynchronous function.
 Applies the given function towards its current and next value,
 yielding the next current value.
 
 If the function fold returns a failure and the supervision decision is
 Directive.Restart current value starts at state again
 the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.fold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Similar to scan but only emits its result when the upstream completes,
 after which it also completes. Applies the given function towards its current and next value,
 yielding the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at state again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.asyncScan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Similar to scan but with a asynchronous function, emits its current value which 
 starts at zero and then applies the current and next value to the given function
 emitting an Async that resolves to the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.scan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 Similar to fold but is not a terminal operation,
 emits its current value which starts at zero and then
 applies the current and next value to the given function,
 emitting the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at zero again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.slidingBy``3(System.Int32,System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.sliding``3(System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.limitWeighted``3(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Ensure stream boundedness by evaluating the cost of incoming elements
 using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
 evaluated cost of each element. If the accumulated cost exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.limit``3(System.Int64,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Ensure stream boundedness by limiting the number of elements from upstream.
 If the number of incoming elements exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter
 is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.windowed``3(System.Int32,Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Chunk up this stream into groups of the given size, with the last group
 possibly smaller than requested due to end-of-stream.
 N must be positive, otherwise ArgumentException is thrown.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.choose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 on which the function is defined (read: returns Some) as they pass through this processing step.
 Non-matching elements are filtered out.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.skipWhile``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Discard elements at the beginning of the stream while predicate function is true.
 All elements will be taken after function returns false first time.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.takeWhile``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after predicate function
 returns false for the first time. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.filter``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Only pass on those elements that satisfy the given predicate function.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.asyncMapUnordered``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstreams. As many asyncs as requested elements by
 downstream may run in parallel and each processed element will be emitted dowstream
 as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
 in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.asyncMap``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstream. The number of tasks
 that shall run in parallel is given as the first argument.
 These tasks may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.collect``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SubFlow{``0,``3,``4})">
<summary>
 Transform each input element into a sequence of output elements that is
 then flattened into the output stream.

 The returned sequence MUST NOT contain NULL values,
 as they are illegal as stream elements - according to the Reactive Streams specification.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SubFlow{``0,``2,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.mapError``4(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 While similar to recover, this stage can be used to transform an error signal to a different one without logging
 it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e =&gt; throw e2) since Recover
 would log the e2 error. 
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.recoverWithRetries``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.SubFlow{``1,``2,``3})">
<summary>
 RecoverWith allows to switch to alternative Source on subFlow failure. It will stay in effect after
 a failure has been recovered so that each time there is a failure it is fed into the &lt;paramref name=&quot;partialFunc&quot;/&gt; and a new
 Source may be materialized.
</summary>
</member>
<member name="M:Akkling.Streams.SubFlow.recover``3(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpOption{``0}},Akka.Streams.Dsl.SubFlow{``0,``1,``2})">
<summary>
 Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This stage can recover the failure signal, but not the skipped elements, which will be dropped.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.joinMat``7(Akka.Streams.Dsl.Flow{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.BidiFlow{``5,``0,``1,``6,``3})">
<summary>
 Add provided flow as a final step of a bidirectional flow transformation.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.join``6(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.Dsl.BidiFlow{``3,``0,``1,``4,``5})">
<summary>
 Add provided flow as a final step of a bidirectional flow transformation.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.atopMat``9(Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``5,Microsoft.FSharp.Core.FSharpFunc{``4,``6}},Akka.Streams.Dsl.BidiFlow{``7,``0,``3,``8,``5})">
<summary>
 Add the fist BidiFlow as the next step of a second BidiFlow.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.atop``8(Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4},Akka.Streams.Dsl.BidiFlow{``5,``0,``3,``6,``7})">
<summary>
 Add the first BidiFlow as the next step of a second BidiFlow.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.rev``5(Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4})">
<summary>
 Reverses the direction of current BidiFlow.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.async``5(Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4})">
<summary>
 Marks currend BidiFlow stage as asynchronous, setting an async boundary in that place.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.named``5(System.String,Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4})">
<summary>
 Changes the name of a target BidiFlow stage.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.attrs``5(Akka.Streams.Attributes,Akka.Streams.Dsl.BidiFlow{``0,``1,``2,``3,``4})">
<summary>
 Replaces existing set of attributes attached to provided BidiFlow with new one.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.idle``2(System.TimeSpan)">
<summary>
 If the time between two processed elements (in any direction) exceed the 
 provided timeout, the stream is failed with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.ofFun``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Create a BidiFlow where the top and bottom flows are just one simple mapping
 stage each, expressed by the two functions.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.ofFlows``8(``0,``4)">
<summary>
 Wraps two flows into a single BidiFlow, ignoring inherited materialized values.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.ofFlowsMat``9(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``5}},``6)">
<summary>
 Wraps two flows into a single BidiFlow.
</summary>
</member>
<member name="M:Akkling.Streams.BidiFlow.ofGraph``6(``0)">
<summary>
 A graph with the shape of a flow logically is a flow, this method makes it so also in type.
</summary>
</member>
<member name="M:Akkling.Streams.Operators.graph``1(Akka.Streams.Dsl.GraphDsl.Builder{``0})">
<summary>
 A computation expression for building graph workflows using akka streams API.
</summary>
</member>
<member name="M:Akkling.Streams.Graph.named``2(``0,System.String)">
<summary>
 Add a name attribute to this Graph.
</summary>
</member>
<member name="M:Akkling.Streams.Graph.addAttributes``2(Akka.Streams.Attributes,``0)">
<summary>
 Add the given attributes to this &lt;see cref=&quot;T:Akka.Streams.IGraph`1&quot; /&gt;.
 Further calls to &lt;see cref=&quot;M:Akka.Streams.Dsl.IRunnableGraph`1.WithAttributes(Akka.Streams.Attributes)&quot; /&gt;
 will not remove these attributes. Note that this operation has no effect on an empty Flow (because the attributes apply
 only to the contained processing stages).
</summary>
</member>
<member name="M:Akkling.Streams.Graph.withAttributes``2(Akka.Streams.Attributes,``0)">
<summary>
 Change the attributes of this &lt;see cref=&quot;T:Akka.Streams.IGraph`1&quot; /&gt; to the given ones and seal the list 
 of attributes. This means that further calls will not be able to remove these attributes, but instead add new ones. 
 Note that this operation has no effect on an empty Flow (because the attributes apply only to the contained 
 processing stages).
</summary>
</member>
<member name="M:Akkling.Streams.Graph.mapMaterializedValue``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Transform only the materialized value of this RunnableGraph, leaving all other properties as they were.
</summary>
</member>
<member name="M:Akkling.Streams.Graph.run``3(``0,``1)">
<summary>
 Executes provided graph using provided materializer.
</summary>
</member>
<member name="M:Akkling.Streams.Graph.create``2(Microsoft.FSharp.Core.FSharpFunc{Akka.Streams.Dsl.GraphDsl.Builder{``0},``1})">
<summary>
 Creates a new partial graph using provided builder function
</summary>
</member>
<member name="M:Akkling.Streams.Flow.withContext``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Akka.Streams.Dsl.Flow{``2,``3,``5})">
<summary>
 Turns a Flow into a FlowWithContext which manages a context per element along a stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.ask``3(System.TimeSpan,Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Flow{``0,``0,``1})">
<summary>
 Use the `ask` pattern to send a request-reply message to the target `actorRef`.
 If any of the asks times out it will fail the stream with a `AskTimeoutException`.
 
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated,
 or with an `TimeoutException` in case the ask exceeds the timeout passed in.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.askParallel``3(System.Int32,System.TimeSpan,Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Flow{``0,``0,``1})">
<summary>
 Use the `ask` pattern to send a request-reply message to the target `actorRef`.
 If any of the asks times out it will fail the stream with a `AskTimeoutException`.
 
 Parallelism limits the number of how many asks can be &quot;in flight&quot; at the same time.
 Please note that the elements emitted by this operator are in-order with regards to the asks being issued
 (i.e. same behaviour as `asyncMap`).
 
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated,
 or with an `TimeoutException` in case the ask exceeds the timeout passed in.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.watch``3(Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Flow{``1,``1,``2})">
<summary>
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.managedDelay``2(Akkling.Streams.DelayStrategy{``0},Akka.Streams.Dsl.Flow{``0,``0,``1})">
<summary>
 Flow stage for universal delay management, allows to manage delay through a given strategy.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.pulse``2(System.Boolean,System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``0,``1})">
<summary>
 Pulse stage signals demand only once every &quot;pulse&quot; interval and then back-pressures.
 Requested element is emitted downstream if there is demand.
 It can be used to implement simple time-window processing
 where data is aggregated for predefined amount of time and the computed aggregate is emitted once per this time.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.valve``1(Akka.Streams.Dsl.SwitchMode)">
<summary>
 Materializes into an Async of switch which provides method flip that stops or restarts the flow of elements passing through the stage. 
 As long as the valve is closed it will backpressure.
 Note that closing the valve could result in one element being buffered inside the stage, and if the stream completes or fails while being closed, that element may be lost.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.deduplicate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Filters our consecutive duplicated elements from the stream (uniqueness is recognized 
 by provided function).
</summary>
</member>
<member name="M:Akkling.Streams.Flow.toProcessor``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Joins a provided flow with given sink, returning a new sink in the result.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.toSink``5(``0,Akka.Streams.Dsl.Flow{``3,``1,``4})">
<summary>
 Joins a provided flow with given sink, returning a new sink in the result.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.retrySimple``5(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.Flow{``0,Microsoft.FSharp.Core.FSharpResult{``2,``3},Akka.NotUsed},``1)">
 <summary>    
 Retry flow factory. Given a flow that produces `Result<'out, #exn>`, this wrapping flow may be used to try
 and pass failed elements through the flow again. More accurately, the given flow consumes a tuple
 of `input` and `state`, and produces a tuple of `Result<'out, #exn> of `output` and `state`.
 If the flow emits an Error element, the `retryWith` function is fed with the failed element 
 and `state` of it, and may produce a new state to pass through the original flow. 
 The function may also yield `None` instead of `Some state`, which means not to retry a failed element.
 </summary>

 <param name="flow">the flow to retry</param>
 <param name="retryWith">if output was failure, we can optionaly recover from it,
 and retry with a new pair of input and new state we get from this function.</param>
 <typeparam name="'i">input elements type</typeparam>
 <typeparam name="'s">state to create a new `(I,S)` to retry with</typeparam>
 <typeparam name="'out">output elements type</typeparam>
 <example>
 
 let plainFlow = Flow.id |> Flow.map (fun x -> if x = 2 then Error (exn "it's 3 and we fail") else Ok x)
 let retryFlow = 
     (plainFlow, 0)
     ||> retry (fun (i: int, attempt: int) ->
           printfn "Elem %d, Attempt %d" i attempt
           if attempt > 3 then None else Some (attempt + 1)
         )
        
 [1..3]
 |> Source.ofList
 |> Source.via retryFlow
 |> Source.runForEach mat (printfn "got %A")
 |> Async.RunSynchronously

 </example>
</member>
<member name="M:Akkling.Streams.Flow.joinMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{``3,``5}},Akka.Streams.Dsl.Flow{``2,``1,``4})">
<summary>
 Joins two flows by cross connecting their inputs and outputs with a materialized value determined by `fn` function.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.join``5(``0,Akka.Streams.Dsl.Flow{``2,``1,``4})">
<summary>
 Joins two flows by cross connecting their inputs and outputs.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.ofSinkAndSourceMat``7(``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}},``5)">
<summary>
 Builds a flow from provided sink and source graphs returning a materialized value being result of combineFn.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.ofSinkAndSource``5(``0,``3)">
<summary>
 Builds a flow from provided sink and source graphs.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.ofProcMat``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,``3}})">
<summary>
 Creates flow from the Reactive Streams Processor and returns a materialized value.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.ofProc``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates flow from the Reactive Streams Processor.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.id``2">
<summary>
 An identity flow, mapping incoming values to themselves.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.toMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Flow{``5,``1,``3})">
<summary>
 Connect this source to a sink concatenating the processing steps of both.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.viaMat``7(``0,Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{``3,``5}},Akka.Streams.Dsl.Flow{``6,``1,``4})">
<summary>
 Transform this flow by appending the given processing steps.
 The combine function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.via``6(``0,Akka.Streams.Dsl.Flow{``4,``1,``5})">
<summary>
 Transform this flow by appending the given processing steps.
 The materialized value of the combined source will be the materialized
 value of the current flow (ignoring the other flow’s value).
</summary>
</member>
<member name="M:Akkling.Streams.Flow.mapMatValue``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``2,``3,``0})">
<summary>
 Transform the materialized value of this Flow, leaving all other properties as they were.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.attrs``3(Akka.Streams.Attributes,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Nests the current Source and returns a Source with the given Attributes
</summary>
</member>
<member name="M:Akkling.Streams.Flow.named``3(System.String,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Add a name attribute to this Source.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.async``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Put an asynchronous boundary around this Flow.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.orElseMat``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,Akka.Streams.Dsl.Flow{``4,``4,``0})">
<summary>
 Provides a secondary source that will be consumed if this source completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.orElse``3(``0,Akka.Streams.Dsl.Flow{``1,``1,``2})">
<summary>
 Provides a secondary source that will be consumed if this stream completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.

 Note that this Flow will be materialized together with the Source and just kept
 from producing elements by asserting back-pressure until its time comes or it gets
 cancelled.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.prepend``5(``0,Akka.Streams.Dsl.Flow{``3,``4,``2})">
<summary>
 Prepend the given source to this flow, meaning that before elements
 are generated from this flow, the Source&apos;s elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.concat``4(``0,Akka.Streams.Dsl.Flow{``3,``1,``2})">
<summary>
 Concatenate the given source to this flow, meaning that once this
 Flow’s input is exhausted and all result elements have been generated,
 the Source’s elements will be produced.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.mergeSort``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},Akka.Streams.Dsl.Flow{``3,``1,``2})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking always the smallest of the available elements(waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements(and
 does not complete).
</summary>
</member>
<member name="M:Akkling.Streams.Flow.mergeMat``7(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Flow{``5,``6,``3})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.merge``5(``0,Akka.Streams.Dsl.Flow{``3,``4,``2})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.interleaveMat``7(System.Int32,``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Flow{``5,``6,``3})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this flow.
 It first emits count number of elements from this flow to downstream, then - same amount for source,
 then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.interleave``5(System.Int32,``0,Akka.Streams.Dsl.Flow{``3,``4,``2})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this flow.
 It first emits number of elements from this flow to downstream, then - same amount for other
 source, then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.zipWith``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,``4}},Akka.Streams.Dsl.Flow{``5,``3,``2})">
<summary>
 Put together the elements of current flow and the given source
 into a stream of combined elements using a combiner function.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.zip``5(``0,Akka.Streams.Dsl.Flow{``3,``4,``2})">
<summary>
 Combine the elements of current flow and the given source into a stream of tuples.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.logWithf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.String},Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.logWith``3(System.String,Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.logf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.log``3(System.String,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.initDelay``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Delays the initial element by the specified duration.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.detach``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Detaches upstream demand from downstream demand without detaching the
 stream rates; in other words acts like a buffer of size 1.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.monitor``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Akka.Streams.IFlowMonitor,``1}},Akka.Streams.Dsl.Flow{``2,``3,``0})">
<summary>
 Materializes to IFlowMonitor that allows monitoring of the the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.
 The &apos;combine&apos; function is used to combine the IFlowMonitor with this flow&apos;s materialized value.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.watchTermination``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},``1}},Akka.Streams.Dsl.Flow{``2,``2,``0})">
<summary>
 Materializes to Async that completes on getting termination message.
 The task completes with success when received complete message from upstream or cancel
 from downstream. It fails with the same error when received error message from
 downstream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.alsoTo``4(``0,Akka.Streams.Dsl.Flow{``3,``1,``2})">
<summary>
 Attaches the given sink to this flow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.alsoToMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Flow{``5,``1,``3})">
<summary>
 Attaches the given sink graph to this flow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.throttleWeighted``3(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.throttle``3(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.keepAlive``4(System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Akka.Streams.Dsl.Flow{``1,``2,``3})">
<summary>
 Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
 stage attempts to maintains a base rate of emitted elements towards the downstream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.backpressureTimeout``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a TimeoutException. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
</summary>
</member>
<member name="M:Akkling.Streams.Flow.idleTimeout``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 If the time between two processed elements exceed the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.completeWithin``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.initWithin``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 If the first element has not passed through this stage before the provided timeout, the stream is failed
 with a TimeoutException
</summary>
</member>
<member name="M:Akkling.Streams.Flow.zipi``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Combine the elements of current flow into a stream of tuples consisting
 of all elements paired with their index. Indices start at 0.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.collectMerge``5(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``4,``0,``3})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by merging, where at most breadth
 substreams are being consumed at any given time.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.collectMap``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``4,``0,``3})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by concatenation,
 fully consuming one Source after the other.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.splitAfterCancellable``3(Akka.Streams.SubstreamCancelStrategy,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.splitAfter``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.splitWhenCancellable``3(Akka.Streams.SubstreamCancelStrategy,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.splitWhen``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.groupBy``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 This operation demultiplexes the incoming stream into separate output
 streams, one for each element key. The key is computed for each element
 using the given function. When a new key is encountered for the first time
 it is emitted to the downstream subscriber together with a fresh
 flow that will eventually produce all the elements of the substream
 for that key. Not consuming the elements from the created streams will
 stop this processor from processing more elements, therefore you must take
 care to unblock (or cancel) all of the produced streams even if you want
 to consume only one of them.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.prefixAndTail``3(System.Int32,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Takes up to n elements from the stream and returns a pair containing a strict sequence of the taken element
 and a stream representing the remaining elements. If `n` is zero or negative, then this will return a pair
 of an empty collection and a stream containing the whole upstream unchanged.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.buffer``3(Akka.Streams.OverflowStrategy,System.Int32,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
 Depending on the defined strategy it might drop elements or backpressure the upstream if
 there is no space available
</summary>
</member>
<member name="M:Akkling.Streams.Flow.expand``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``3,``0,``4})">
<summary>
 Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
 element until new element comes from the upstream. For example an expand step might repeat the last element for
 the subscriber until it receives an update from upstream.

 This element will never &quot;drop&quot; upstream elements as all elements go through at least one extrapolation step.
 This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
 subscriber.

 Expand does not support restart and resume directives. Exceptions from the extrapolate function will complete the stream with failure.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.batchWeighted``4(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.batch``4(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.For example a batch step might store received elements in
 an array up to the allowed max limit if the upstream publisher is faster.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.conflate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate does not change the output type of the stream. See conflateSeeded
 for a more flexible version that can take a seed function and transform elements while rolling up.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.conflateSeeded``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Akka.Streams.Dsl.Flow{``2,``1,``3})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate allows to derive a seed from the first element and change the aggregated type to
 be different than the input type. See conflate for a simpler version that does not change types.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.takeWithin``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 duration. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.take``3(System.Int64,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 number of elements. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.skipWithin``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Discard the elements received within the given duration at beginning of the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.skip``3(System.Int64,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Discard the given number of elements at the beginning of the stream.
 No elements will be dropped if parameter is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.delayWithStrategy``3(Akka.Streams.DelayOverflowStrategy,System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.Depending on the defined
 strategy it might drop elements or backpressure the upstream if
 there is no space available in the buffer.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.Flow.delay``3(System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.Flow.groupedWithin``3(System.Int32,System.TimeSpan,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.intersperse``3(``0,Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.intersperseBounded``3(``0,``0,``0,Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.

 Additionally can inject start and end marker elements to stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.reduce``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Similar to fold but uses first element as zero element.
 Applies the given function towards its current and next value,
 yielding the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.asyncFold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.Flow{``2,``1,``3})">
<summary>
 Similar to fold but with an asynchronous function.
 Applies the given function towards its current and next value,
 yielding the next current value.
 
 If the function &apos;folder&apos; returns a failure and the supervision decision is
 Directive.Restart current value starts at &apos;state&apos; again
 the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.fold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.Flow{``2,``1,``3})">
<summary>
 Similar to scan but only emits its result when the upstream completes,
 after which it also completes. Applies the given function towards its current and next value,
 yielding the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at state again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.asyncScan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.Flow{``2,``1,``3})">
<summary>
 Similar to scan but with a asynchronous function, emits its current value which 
 starts at zero and then applies the current and next value to the given function
 emitting an Async that resolves to the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.scan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.Flow{``2,``1,``3})">
<summary>
 Similar to fold but is not a terminal operation,
 emits its current value which starts at zero and then
 applies the current and next value to the given function,
 emitting the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at zero again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.slidingBy``3(System.Int32,System.Int32,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.sliding``3(System.Int32,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.limitWeighted``3(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Ensure stream boundedness by evaluating the cost of incoming elements
 using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
 evaluated cost of each element. If the accumulated cost exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.limit``3(System.Int64,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Ensure stream boundedness by limiting the number of elements from upstream.
 If the number of incoming elements exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter
 is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.windowed``3(System.Int32,Akka.Streams.Dsl.Flow{``0,``1,``2})">
<summary>
 Chunk up this stream into groups of the given size, with the last group
 possibly smaller than requested due to end-of-stream.
 N must be positive, otherwise ArgumentException is thrown.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.choose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 on which the function is defined (read: returns Some) as they pass through this processing step.
 Non-matching elements are filtered out.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.skipWhile``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Discard elements at the beginning of the stream while predicate function is true.
 All elements will be taken after function returns false first time.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.takeWhile``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Terminate processing (and cancel the upstream publisher) after predicate function
 returns false for the first time. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.filter``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Only pass on those elements that satisfy the given predicate function.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.asyncMapUnordered``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstreams. As many asyncs as requested elements by
 downstream may run in parallel and each processed element will be emitted dowstream
 as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
 in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.taskMap``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns a Task and the
 value of that computation will be emitted downstream. The number of tasks
 that shall run in parallel is given as the first argument.
 These tasks may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.asyncMap``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstream. The number of tasks
 that shall run in parallel is given as the first argument.
 These tasks may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.statefulCollect``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}},``0,Akka.Streams.Dsl.Flow{``1,``1,``4})">
<summary>
 Givien initial state, transforms each input element into new output state and a 
 sequence-like structure of output elements, that is then flattened into the output stream.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.collect``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``3,``0,``4})">
<summary>
 Transform each input element into a sequence of output elements that is
 then flattened into the output stream.

 The returned sequence MUST NOT contain NULL values,
 as they are illegal as stream elements - according to the Reactive Streams specification.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Flow{``2,``0,``3})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.mapError``4(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.Flow{``1,``2,``3})">
<summary>
 While similar to recover, this stage can be used to transform an error signal to a different one without logging
 it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e =&gt; throw e2) since Recover
 would log the e2 error. 
</summary>
</member>
<member name="M:Akkling.Streams.Flow.recoverWithRetries``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.Flow{``3,``1,``2})">
<summary>
 RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered so that each time there is a failure it is fed into the &lt;paramref name=&quot;partialFunc&quot;/&gt; and a new
 Source may be materialized.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.recover``3(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpOption{``0}},Akka.Streams.Dsl.Flow{``1,``0,``2})">
<summary>
 Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This stage can recover the failure signal, but not the skipped elements, which will be dropped.
</summary>
</member>
<member name="M:Akkling.Streams.Flow.empty``2">
<summary>
 Creates a new empty flow.
</summary>
</member>
<member name="M:Akkling.Streams.KillSwitch.ofCancellationTokenAbrupt``1(System.Threading.CancellationToken)">
<summary>
 Creates a flow stage out of the cancellation token that will abruptly shutdown the stream with
 `OperationCanceledException` once cancellation token will be triggered. It can be injected into the flow
 using `Flow.via` function.
</summary>
</member>
<member name="M:Akkling.Streams.KillSwitch.ofCancellationTokenGraceful``1(System.Threading.CancellationToken)">
<summary>
 Creates a flow stage out of the cancellation token that will gracefully shutdown the stream once
 cancellation token will be triggered. It can be injected into the flow using `Flow.via` function.
</summary>
</member>
<member name="M:Akkling.Streams.KillSwitch.singleBidi``2">
<summary>
 Creates a new shape of bidi flow that materializes to an external switch that allows external completion
 of that unique materialization. Different materializations result in different, independent switches.
</summary>
</member>
<member name="M:Akkling.Streams.KillSwitch.single``1">
<summary>
 Creates a new shape of flow that materializes to an external switch that allows external completion
 of that unique materialization. Different materializations result in different, independent switches.
</summary>
</member>
<member name="M:Akkling.Streams.KillSwitch.shared(System.String)">
<summary>
 Creates a new SharedKillSwitch with the given name that can be used to control 
 the completion of multiple streams from the outside simultaneously.
</summary>
</member>
<member name="M:Akkling.Streams.Source.withContext``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Turns a source into a SourceWithContext which manages a context per element along a stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ask``3(System.TimeSpan,Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Use the `ask` pattern to send a request-reply message to the target `actorRef`.
 If any of the asks times out it will fail the stream with a `AskTimeoutException`.
 
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated,
 or with an `TimeoutException` in case the ask exceeds the timeout passed in.
</summary>
</member>
<member name="M:Akkling.Streams.Source.askParallel``3(System.Int32,System.TimeSpan,Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Use the `ask` pattern to send a request-reply message to the target `actorRef`.
 If any of the asks times out it will fail the stream with a `AskTimeoutException`.
 
 Parallelism limits the number of how many asks can be &quot;in flight&quot; at the same time.
 Please note that the elements emitted by this operator are in-order with regards to the asks being issued
 (i.e. same behaviour as `asyncMap`).
 
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated,
 or with an `TimeoutException` in case the ask exceeds the timeout passed in.
</summary>
</member>
<member name="M:Akkling.Streams.Source.watch``3(Akkling.ActorRefs.IActorRef{``0},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 The operator fails with an `WatchedActorTerminatedException` if the target actor is terminated.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ref``1">
<summary>
 A local source which materializes a sink ref which can be used by other streams (including remote ones),
 to consume data from this local stream, as if they were attached in the spot of the local Sink directly.
</summary>
</member>
<member name="M:Akkling.Streams.Source.managedDelay``2(Akkling.Streams.DelayStrategy{``0},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Flow stage for universal delay management, allows to manage delay through a given strategy.
</summary>
</member>
<member name="M:Akkling.Streams.Source.pulse``2(System.Boolean,System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Pulse stage signals demand only once every &quot;pulse&quot; interval and then back-pressures.
 Requested element is emitted downstream if there is demand.
 It can be used to implement simple time-window processing
 where data is aggregated for predefined amount of time and the computed aggregate is emitted once per this time.
</summary>
</member>
<member name="M:Akkling.Streams.Source.deduplicate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Filters our consecutive duplicated elements from the stream (uniqueness is recognized 
 by provided function).
</summary>
</member>
<member name="M:Akkling.Streams.Source.toSink``4(``0,Akka.Streams.Dsl.Source{``1,``3})">
<summary>
 Combines current source with provided sink, resulting in a completed runnable graph.
</summary>
</member>
<member name="M:Akkling.Streams.Source.mergeHub``1(System.Int32)">
<summary>
 A MergeHub is a special streaming hub that is able to collect streamed elements from a 
 dynamic set of producers
</summary>
</member>
<member name="M:Akkling.Streams.Source.runForEach``3(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Shortcut for running this source with a foreach procedure. The given procedure is invoked
 for each received element.
 The returned Async computation will be completed with Success when reaching the
 normal end of the stream, or completed with Failure if there is a failure signaled in
 the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.runReduce``3(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Shortcut for running this surce with a reduce function.
 The given function is invoked for every received element, giving it its previous
 output (from the second element) and the element as input.
 The returned Async computation will be completed with value of the final
 function evaluation when the input stream ends, or completed with Failure
 if there is a failure signaled in the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.runFold``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``1}},``1,Akka.Streams.Dsl.Source{``2,``3})">
<summary>
 Shortcut for running this source with a fold function.
 The given function is invoked for every received element, giving it its previous
 output (or the given zero value) and the element as input.
 The returned Async computation will be completed with value of the final
 function evaluation when the input stream ends, or completed with Failure
 if there is a failure signaled in the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.runWith``5(``0,``1,Akka.Streams.Dsl.Source{``2,``4})">
<summary>
 Connect this source to a sink and run it. The returned value is the materialized value of the sink
</summary>
</member>
<member name="M:Akkling.Streams.Source.toMat``5(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Source{``1,``3})">
<summary>
 Connect this source to a sink concatenating the processing steps of both.
</summary>
</member>
<member name="M:Akkling.Streams.Source.viaMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{``3,``5}},Akka.Streams.Dsl.Source{``1,``4})">
<summary>
 Transform this source by appending the given processing steps.
 The combine function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
</summary>
</member>
<member name="M:Akkling.Streams.Source.via``5(``0,Akka.Streams.Dsl.Source{``1,``4})">
<summary>
 Transform this source by appending the given processing steps.
 The materialized value of the combined source will be the materialized
 value of the current flow (ignoring the other flow’s value).
</summary>
</member>
<member name="M:Akkling.Streams.Source.mapMatValue``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``2,``0})">
<summary>
 Transform the materialized value of this Source, leaving all other properties as they were.
</summary>
</member>
<member name="M:Akkling.Streams.Source.attrs``2(Akka.Streams.Attributes,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Nests the current Source and returns a Source with the given Attributes
</summary>
</member>
<member name="M:Akkling.Streams.Source.named``2(System.String,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Add a name attribute to this Source.
</summary>
</member>
<member name="M:Akkling.Streams.Source.async``2(Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Put an asynchronous boundary around this Source.
</summary>
</member>
<member name="M:Akkling.Streams.Source.orElseMat``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,Akka.Streams.Dsl.Source{``4,``0})">
<summary>
 Provides a secondary source that will be consumed if this source completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
</summary>
</member>
<member name="M:Akkling.Streams.Source.orElse``3(``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Provides a secondary source that will be consumed if this stream completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
</summary>
</member>
<member name="M:Akkling.Streams.Source.prepend``4(``0,Akka.Streams.Dsl.Source{``3,``2})">
<summary>
 Prepend the given source to this flow, meaning that before elements
 are generated from this flow, the Source&apos;s elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
</summary>
</member>
<member name="M:Akkling.Streams.Source.concat``3(``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Concatenate the given source to this flow, meaning that once this
 Flow’s input is exhausted and all result elements have been generated,
 the Source’s elements will be produced.
</summary>
</member>
<member name="M:Akkling.Streams.Source.mergeSort``3(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking always the smallest of the available elements(waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements(and
 does not complete).
</summary>
</member>
<member name="M:Akkling.Streams.Source.mergeMat``6(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Source{``5,``3})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.Source.merge``4(``0,Akka.Streams.Dsl.Source{``3,``2})">
<summary>
 Merge the given source to this flow, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
</summary>
</member>
<member name="M:Akkling.Streams.Source.interleaveMat``6(System.Int32,``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Source{``5,``3})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this flow.
 It first emits count number of elements from this flow to downstream, then - same amount for source,
 then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.Source.interleave``4(System.Int32,``0,Akka.Streams.Dsl.Source{``3,``2})">
<summary>
 Interleave is a deterministic merge of the given source with elements of this flow.
 It first emits number of elements from this flow to downstream, then - same amount for other
 source, then repeat process.
</summary>
</member>
<member name="M:Akkling.Streams.Source.zipWith``5(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,``4}},Akka.Streams.Dsl.Source{``3,``2})">
<summary>
 Put together the elements of current flow and the given source
 into a stream of combined elements using a combiner function.
</summary>
</member>
<member name="M:Akkling.Streams.Source.zip``4(``0,Akka.Streams.Dsl.Source{``3,``2})">
<summary>
 Combine the elements of current flow and the given source into a stream of tuples.
</summary>
</member>
<member name="M:Akkling.Streams.Source.logWithf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Source.logWith``2(System.String,Akka.Event.ILoggingAdapter,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Source.logf``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Source.log``2(System.String,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Logs elements flowing through the stream as well as completion and erroring.
</summary>
</member>
<member name="M:Akkling.Streams.Source.initDelay``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Delays the initial element by the specified duration.
</summary>
</member>
<member name="M:Akkling.Streams.Source.detach``2(Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Detaches upstream demand from downstream demand without detaching the
 stream rates; in other words acts like a buffer of size 1.
</summary>
</member>
<member name="M:Akkling.Streams.Source.monitor``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Akka.Streams.IFlowMonitor,``1}},Akka.Streams.Dsl.Source{``2,``0})">
<summary>
 Materializes to IFlowMonitor that allows monitoring of the the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.  
</summary>
</member>
<member name="M:Akkling.Streams.Source.watchTermination``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},``1}},Akka.Streams.Dsl.Source{``2,``0})">
<summary>
 Materializes to Async that completes on getting termination message.
 The task completes with success when received complete message from upstream or cancel
 from downstream. It fails with the same error when received error message from
 downstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.alsoTo``3(``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Attaches the given sink to this flow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.Source.alsoToMat``5(``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``2,``4}},Akka.Streams.Dsl.Source{``1,``3})">
<summary>
 Attaches the given sink graph to this flow, meaning that elements that passes
 through will also be sent to the sink.
</summary>
</member>
<member name="M:Akkling.Streams.Source.throttleWeighted``2(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.Source.throttle``2(Akka.Streams.ThrottleMode,System.Int32,System.Int32,System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Sends elements downstream with speed limited to n/per timeout. In other words, this stage set the maximum rate
 for emitting messages. This combinator works for streams where all elements have the same cost or length.

 Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
 Tokens drops into the bucket at a given rate and can be &quot;spared&quot; for later use up to bucket capacity
 to allow some burstyness. Whenever stream wants to send an element, it takes as many
 tokens from the bucket as number of elements. If there isn&apos;t any, throttle waits until the
 bucket accumulates enough tokens.
</summary>
</member>
<member name="M:Akkling.Streams.Source.keepAlive``3(System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
 stage attempts to maintains a base rate of emitted elements towards the downstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.backpressureTimeout``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
 the stream is failed with a TimeoutException. The timeout is checked periodically,
 so the resolution of the check is one period (equals to timeout value).
</summary>
</member>
<member name="M:Akkling.Streams.Source.idleTimeout``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 If the time between two processed elements exceed the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.Source.completeWithin``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 If the completion of the stream does not happen until the provided timeout, the stream is failed
 with a TimeoutException.
</summary>
</member>
<member name="M:Akkling.Streams.Source.initWithin``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 If the first element has not passed through this stage before the provided timeout, the stream is failed
 with a TimeoutException
</summary>
</member>
<member name="M:Akkling.Streams.Source.zipi``2(Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Combine the elements of current flow into a stream of tuples consisting
 of all elements paired with their index. Indices start at 0.
</summary>
</member>
<member name="M:Akkling.Streams.Source.collectMerge``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``3})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by merging, where at most breadth
 substreams are being consumed at any given time.
</summary>
</member>
<member name="M:Akkling.Streams.Source.collectMap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``3})">
<summary>
 Transform each input element into a source of output elements that is
 then flattened into the output stream by concatenation,
 fully consuming one Source after the other.
</summary>
</member>
<member name="M:Akkling.Streams.Source.splitAfterCancellable``2(Akka.Streams.SubstreamCancelStrategy,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true.
</summary>
</member>
<member name="M:Akkling.Streams.Source.splitAfter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams. It *ends* the current substream when the
 predicate is true.
</summary>
</member>
<member name="M:Akkling.Streams.Source.splitWhenCancellable``2(Akka.Streams.SubstreamCancelStrategy,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.
</summary>
</member>
<member name="M:Akkling.Streams.Source.splitWhen``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 This operation applies the given predicate to all incoming elements and
 emits them to a stream of output streams, always beginning a new one with
 the current element if the given predicate returns true for it.
</summary>
</member>
<member name="M:Akkling.Streams.Source.groupBy``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 This operation demultiplexes the incoming stream into separate output
 streams, one for each element key. The key is computed for each element
 using the given function. When a new key is encountered for the first time
 it is emitted to the downstream subscriber together with a fresh
 flow that will eventually produce all the elements of the substream
 for that key. Not consuming the elements from the created streams will
 stop this processor from processing more elements, therefore you must take
 care to unblock (or cancel) all of the produced streams even if you want
 to consume only one of them.
</summary>
</member>
<member name="M:Akkling.Streams.Source.prefixAndTail``2(System.Int32,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Takes up to n elements from the stream and returns a pair containing a strict sequence of the taken element
 and a stream representing the remaining elements. If `n` is zero or negative, then this will return a pair
 of an empty collection and a stream containing the whole upstream unchanged.
</summary>
</member>
<member name="M:Akkling.Streams.Source.buffer``2(Akka.Streams.OverflowStrategy,System.Int32,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
 Depending on the defined strategy it might drop elements or backpressure the upstream if
 there is no space available
</summary>
</member>
<member name="M:Akkling.Streams.Source.expand``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``3})">
<summary>
 Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
 element until new element comes from the upstream. For example an expand step might repeat the last element for
 the subscriber until it receives an update from upstream.

 This element will never &quot;drop&quot; upstream elements as all elements go through at least one extrapolation step.
 This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
 subscriber.

 Expand does not support restart and resume directives. Exceptions from the extrapolate function will complete the stream with failure.
</summary>
</member>
<member name="M:Akkling.Streams.Source.batchWeighted``3(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.
</summary>
</member>
<member name="M:Akkling.Streams.Source.batch``3(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
 until the subscriber is ready to accept them.For example a batch step might store received elements in
 an array up to the allowed max limit if the upstream publisher is faster.
</summary>
</member>
<member name="M:Akkling.Streams.Source.conflate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate does not change the output type of the stream. See conflateSeeded
 for a more flexible version that can take a seed function and transform elements while rolling up.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.Source.conflateSeeded``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
 until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
 upstream publisher is faster.

 This version of conflate allows to derive a seed from the first element and change the aggregated type to
 be different than the input type. See conflate for a simpler version that does not change types.

 This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
 duplicate elements.
</summary>
</member>
<member name="M:Akkling.Streams.Source.takeWithin``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 duration. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.Source.take``2(System.Int64,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Terminate processing (and cancel the upstream publisher) after the given
 number of elements. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Source.skipWithin``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Discard the elements received within the given duration at beginning of the stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.skip``2(System.Int64,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Discard the given number of elements at the beginning of the stream.
 No elements will be dropped if parameter is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Source.delayWithStrategy``2(Akka.Streams.DelayOverflowStrategy,System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.Depending on the defined
 strategy it might drop elements or backpressure the upstream if
 there is no space available in the buffer.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.Source.delay``2(System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Shifts elements emission in time by a specified amount. It allows to store elements
 in internal buffer while waiting for next element to be emitted.

 Delay precision is 10ms to avoid unnecessary timer scheduling cycles
</summary>
</member>
<member name="M:Akkling.Streams.Source.groupedWithin``2(System.Int32,System.TimeSpan,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Chunk up this stream into groups of elements received within a time window,
 or limited by the given number of elements, whatever happens first.
 Empty groups will not be emitted if no elements are received from upstream.
 The last group before end-of-stream will contain the buffered elements
 since the previously emitted group.
</summary>
</member>
<member name="M:Akkling.Streams.Source.intersperse``2(``0,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.
</summary>
</member>
<member name="M:Akkling.Streams.Source.intersperseBounded``2(``0,``0,``0,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Intersperses stream with provided element, similar to how string.Join
 injects a separator between a collection&apos;s elements.

 Additionally can inject start and end marker elements to stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Similar to fold but uses first element as zero element.
 Applies the given function towards its current and next value,
 yielding the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asyncFold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Similar to fold but with an asynchronous function.
 Applies the given function towards its current and next value,
 yielding the next current value.
 
 If the function &apos;folder&apos; returns a failure and the supervision decision is
 Directive.Restart current value starts at &apos;state&apos; again
 the stream will continue. 
</summary>
</member>
<member name="M:Akkling.Streams.Source.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Similar to scan but only emits its result when the upstream completes,
 after which it also completes. Applies the given function towards its current and next value,
 yielding the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at state again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asyncScan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Similar to scan but with a asynchronous function, emits its current value which 
 starts at zero and then applies the current and next value to the given function
 emitting an Async that resolves to the next current value.
</summary>
</member>
<member name="M:Akkling.Streams.Source.scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 Similar to fold but is not a terminal operation,
 emits its current value which starts at zero and then
 applies the current and next value to the given function,
 emitting the next current value.

 If the function throws an exception and the supervision decision is
 restart current value starts at zero again the stream will continue.
</summary>
</member>
<member name="M:Akkling.Streams.Source.slidingBy``2(System.Int32,System.Int32,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.sliding``2(System.Int32,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Apply a sliding window over the stream and return the windows as groups of elements, with the last group
 possibly smaller than requested due to end-of-stream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.limitWeighted``2(System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Ensure stream boundedness by evaluating the cost of incoming elements
 using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
 evaluated cost of each element. If the accumulated cost exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter is zero
 or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Source.limit``2(System.Int64,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Ensure stream boundedness by limiting the number of elements from upstream.
 If the number of incoming elements exceeds max parameter, it will signal
 upstream failure StreamLimitReachedException downstream.

 Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.

 The stream will be completed without producing any elements if max parameter
 is zero or negative.
</summary>
</member>
<member name="M:Akkling.Streams.Source.windowed``2(System.Int32,Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Chunk up this stream into groups of the given size, with the last group
 possibly smaller than requested due to end-of-stream.
 N must be positive, otherwise ArgumentException is thrown.
</summary>
</member>
<member name="M:Akkling.Streams.Source.choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Transform this stream by applying the given function to each of the elements
 on which the function is defined (read: returns Some) as they pass through this processing step.
 Non-matching elements are filtered out.
</summary>
</member>
<member name="M:Akkling.Streams.Source.skipWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Discard elements at the beginning of the stream while predicate function is true.
 All elements will be taken after function returns false first time.
</summary>
</member>
<member name="M:Akkling.Streams.Source.takeWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Terminate processing (and cancel the upstream publisher) after predicate function
 returns false for the first time. Due to input buffering some elements may have been
 requested from upstream publishers that will then not be processed downstream
 of this step.
</summary>
</member>
<member name="M:Akkling.Streams.Source.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Only pass on those elements that satisfy the given predicate function.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asyncMapUnordered``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstreams. As many asyncs as requested elements by
 downstream may run in parallel and each processed element will be emitted dowstream
 as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
 in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.taskMap``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns a Task and the
 value of that computation will be emitted downstream. The number of tasks
 that shall run in parallel is given as the first argument.
 These tasks may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asyncMap``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step. The function returns an Async and the
 value of that computation will be emitted downstream. The number of tasks
 that shall run in parallel is given as the first argument.
 These tasks may complete in any order, but the elements that
 are emitted downstream are in the same order as received from upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.collect``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``3})">
<summary>
 Transform each input element into a sequence of output elements that is
 then flattened into the output stream.

 The returned sequence MUST NOT contain NULL values,
 as they are illegal as stream elements - according to the Reactive Streams specification.
</summary>
</member>
<member name="M:Akkling.Streams.Source.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``0,``2})">
<summary>
 Transform this stream by applying the given function to each of the elements
 as they pass through this processing step.
</summary>
</member>
<member name="M:Akkling.Streams.Source.mapError``3(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 While similar to recover, this stage can be used to transform an error signal to a different one without logging
 it as an error in the process. So in that sense it is NOT exactly equivalent to Recover(e =&gt; throw e2) since Recover
 would log the e2 error. 
</summary>
</member>
<member name="M:Akkling.Streams.Source.recoverWithRetries``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Akka.Streams.Dsl.Source{``1,``2})">
<summary>
 RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
 a failure has been recovered so that each time there is a failure it is fed into the &lt;paramref name=&quot;partialFunc&quot;/&gt; and a new
 Source may be materialized.
</summary>
</member>
<member name="M:Akkling.Streams.Source.recover``2(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpOption{``0}},Akka.Streams.Dsl.Source{``0,``1})">
<summary>
 Recover allows to send last element on failure and gracefully complete the stream
 Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
 This stage can recover the failure signal, but not the skipped elements, which will be dropped.
</summary>
</member>
<member name="M:Akkling.Streams.Source.queue``1(Akka.Streams.OverflowStrategy,System.Int32)">
<summary>
 Creates a source that is materialized as an source queue.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
</summary>
</member>
<member name="M:Akkling.Streams.Source.actorRef``1(Akka.Streams.OverflowStrategy,System.Int32)">
<summary>
 Creates a source that is materialized as an actor ref
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofProps``1(Akkling.Props.Props{``0})">
<summary>
 Creates a source that is materialized to an actor ref which points to an Actor
 created according to the passed in props. Actor created by the props must
 be ActorPublisher&lt;&apos;t&gt;.
</summary>
</member>
<member name="M:Akkling.Streams.Source.subscriber``1">
<summary>
 Creates a source that is materialized as a subscriber
</summary>
</member>
<member name="M:Akkling.Streams.Source.raise``1(System.Exception)">
<summary>
 Create a source that immediately ends the stream with the error to every connected sink.
</summary>
</member>
<member name="M:Akkling.Streams.Source.option``1">
<summary>
 Create a source which materializes a completion result which controls what element
 will be emitted by the Source.
</summary>
</member>
<member name="M:Akkling.Streams.Source.empty``1">
<summary>
 A source with no elements, i.e. an empty stream that is completed immediately for every connected sink.
</summary>
</member>
<member name="M:Akkling.Streams.Source.infiniteUnfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.ValueTuple{``0,``1}},``0)">
<summary>
 Simpler unfold, for infinite sequences.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asyncUnfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.ValueTuple{``0,``1}}}},``0)">
<summary>
 Same as unfold, but uses an async function to generate the next state-element tuple.
</summary>
</member>
<member name="M:Akkling.Streams.Source.unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.ValueTuple{``0,``1}}},``0)">
<summary>
 Create a source that will unfold a value of one type into
 a pair of the next state and output elements of type another type
</summary>
</member>
<member name="M:Akkling.Streams.Source.replicate``1(``0)">
<summary>
 Create a source that will continually emit the given element.
</summary>
</member>
<member name="M:Akkling.Streams.Source.tick``1(System.TimeSpan,System.TimeSpan,``0)">
<summary>
 Elements are emitted periodically with the specified interval.
 The tick element will be delivered to downstream consumers that has requested any elements.
 If a consumer has not requested any elements at the point in time when the tick
 element is produced it will not receive that tick element later. It will
 receive new tick elements as soon as it has requested more elements.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofAsync``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Start a new source from the given Async computation. The stream will consist of
 one element when the computation is completed with a successful value, which
 may happen before or after materializing the flow.
 The stream terminates with a failure if the task is completed with a failure.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofGraph``3(``0)">
<summary>
 A graph with the shape of a source logically is a source, this method makes
 it so also in type.
</summary>
</member>
<member name="M:Akkling.Streams.Source.mapMaterializedValue``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.Source{``2,``0})">
<summary>
 Transforms only the materialized value of the Source.
</summary>
</member>
<member name="M:Akkling.Streams.Source.singleton``1(``0)">
<summary>
 Create a source with one element.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofObservableBounded``1(Akka.Streams.OverflowStrategy,System.Int32,System.IObservable{``0})">
<summary>
 Start a new source attached to an existing `observable`. In case when upstream (an observable)
 is producing events in a faster pace, than downstream is able to consume them, a buffering will occur.
 It can be configured via `maxCapacity` and `overflowStrategy` parameters.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Helper to create source from list.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofArray``1(``0[])">
<summary>
 Helper to create source from array.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Helper to create source from seq.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofPublisher``2(``0)">
<summary>
 Construct a transformation starting with given publisher. The transformation steps
 are executed by a series of processor instances
 that mediate the flow of elements downstream and the propagation of
 back-pressure upstream.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofFileChunked(System.Int32,System.String)">
<summary>
 Creates a Source from a Files contents.
 Emitted elements are chunkSize sized ByteString elements,
 except the final element, which will be up to chunkSize in size.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofFile(System.String)">
<summary>
 Creates a Source from a Files contents.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asStreamWithTimeout(System.TimeSpan)">
<summary>
 Creates a source which when materialized will return an stream which it is possible
 to write the ByteStrings to the stream this Source is attached to.
 This Source is intended for inter-operation with legacy APIs since it is inherently blocking.
</summary>
</member>
<member name="M:Akkling.Streams.Source.asStream">
<summary>
 Creates a source which when materialized will return an stream which it is possible
 to write the ByteStrings to the stream this Source is attached to.
 This Source is intended for inter-operation with legacy APIs since it is inherently blocking.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofStreamChunked(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.IO.Stream})">
<summary>
 Creates a source from an stream created by the given function.
 Emitted elements are chunk sized ByteString elements,
 except the final element, which will be up to chunkSize in size.
</summary>
</member>
<member name="M:Akkling.Streams.Source.ofStream(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.IO.Stream})">
<summary>
 Creates a source from an stream created by the given function.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.mapContext``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SourceWithContext{``0,``2,``3})">
<summary>
 Apply the given function to each context element (leaving the data elements unchanged).
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.sliding``3(System.Int32,Akka.Streams.Dsl.SourceWithContext{``0,``1,``2})">
<summary>
 Context-preserving variant of `Source.sliding`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.windowed``3(System.Int32,Akka.Streams.Dsl.SourceWithContext{``0,``1,``2})">
<summary>
 Context-preserving variant of `Source.windowed`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.filter``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.SourceWithContext{``1,``0,``2})">
<summary>
 Context-preserving variant of `Source.filter`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.choose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.SourceWithContext{``2,``0,``3})">
<summary>
 Context-preserving variant of `Source.choose`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.taskMap``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},Akka.Streams.Dsl.SourceWithContext{``2,``0,``3})">
<summary>
 Context-preserving variant of `Source.taskMap`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.asyncMap``4(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.SourceWithContext{``2,``0,``3})">
<summary>
 Context-preserving variant of `Source.asyncMap`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.collect``4(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},Akka.Streams.Dsl.SourceWithContext{``2,``0,``3})">
<summary>
 Context-preserving variant of `Source.collect`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.SourceWithContext{``2,``0,``3})">
<summary>
 Context-preserving variant of `Source.map`.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.viaMat``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,Akka.Streams.Dsl.SourceWithContext{``5,``4,``0})">
<summary>
 Transform this flow by the regular flow. The given flow must support manual context propagation by
 taking and producing tuples of (data, context).
 
 This can be used as an escape hatch for operations that are not (yet) provided with automatic
 context propagation here.
 
 The `fn` function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.via``7(``0,Akka.Streams.Dsl.SourceWithContext{``2,``1,``6})">
<summary>
 Transform this source by the regular source. The given flow must support manual context propagation by
 taking and producing tuples of (data, context).
 
 This can be used as an escape hatch for operations that are not (yet) provided with automatic
 context propagation here.
</summary>
</member>
<member name="M:Akkling.Streams.SourceWithContext.asSource``3(Akka.Streams.Dsl.SourceWithContext{``0,``1,``2})">
<summary>
 Stops automatic context propagation from here and converts this to a regular
 stream of a pair of (data, context).
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.mapContext``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.FlowWithContext{``0,``2,``0,``3,``4})">
<summary>
 Apply the given function to each context element (leaving the data elements unchanged).
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.sliding``4(System.Int32,Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3})">
<summary>
 Context-preserving variant of `Flow.sliding`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.windowed``4(System.Int32,Akka.Streams.Dsl.FlowWithContext{``0,``1,``0,``2,``3})">
<summary>
 Context-preserving variant of `Flow.windowed`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.filter``4(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Akka.Streams.Dsl.FlowWithContext{``1,``2,``1,``0,``3})">
<summary>
 Context-preserving variant of `Flow.filter`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.choose``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Akka.Streams.Dsl.FlowWithContext{``2,``3,``2,``0,``4})">
<summary>
 Context-preserving variant of `Flow.choose`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.taskMap``5(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},Akka.Streams.Dsl.FlowWithContext{``2,``3,``2,``0,``4})">
<summary>
 Context-preserving variant of `Flow.taskMap`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.asyncMap``5(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Akka.Streams.Dsl.FlowWithContext{``2,``3,``2,``0,``4})">
<summary>
 Context-preserving variant of `Flow.asyncMap`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.collect``5(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},Akka.Streams.Dsl.FlowWithContext{``2,``3,``2,``0,``4})">
<summary>
 Context-preserving variant of `Flow.collect`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.map``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Akka.Streams.Dsl.FlowWithContext{``2,``3,``2,``0,``4})">
<summary>
 Context-preserving variant of `Flow.map`.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.viaMat``10(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,Akka.Streams.Dsl.FlowWithContext{``8,``9,``5,``4,``0})">
<summary>
 Transform this flow by the regular flow. The given flow must support manual context propagation by
 taking and producing tuples of (data, context).
 
 This can be used as an escape hatch for operations that are not (yet) provided with automatic
 context propagation here.
 
 The `fn` function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.via``9(``0,Akka.Streams.Dsl.FlowWithContext{``6,``7,``2,``1,``8})">
<summary>
 Transform this flow by the regular flow. The given flow must support manual context propagation by
 taking and producing tuples of (data, context).
 
 This can be used as an escape hatch for operations that are not (yet) provided with automatic
 context propagation here.
</summary>
</member>
<member name="M:Akkling.Streams.FlowWithContext.asFlow``5(Akka.Streams.Dsl.FlowWithContext{``0,``1,``2,``3,``4})">
<summary>
 Stops automatic context propagation from here and converts this to a regular
 stream of a pair of (data, context).
</summary>
</member>
<member name="M:Akkling.Streams.Tcp.outgoing(System.String,System.Int32,Akka.Streams.Dsl.TcpExt)">
<summary>
 Creates an async client TCP connection.
</summary>
</member>
<member name="M:Akkling.Streams.Tcp.bindAndHandle``1(``0,System.String,System.Int32,Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,Microsoft.FSharp.Core.Unit},Akka.Streams.Dsl.TcpExt)">
<summary>
 Asynchronously creates a TCP server binding for a given host and port.
</summary>
</member>
<member name="M:Akkling.Streams.Tcp.bind(System.String,System.Int32,Akka.Streams.Dsl.TcpExt)">
<summary>
 Asynchronously creates a TCP server binding for a given host and port.
</summary>
</member>
</members>
</doc>
